{"version":3,"file":"noble_hashes.min.mjs","sources":["../../node_modules/@noble/hashes/esm/legacy.js","../../node_modules/@noble/hashes/esm/sha1.js","../../node_modules/@noble/hashes/esm/ripemd160.js","../../../../src/crypto/hash/md5.ts","../../src/crypto/hash/noble_hashes.js"],"sourcesContent":["/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n * @deprecated\n */\nimport { SHA1 as SHA1n, sha1 as sha1n } from \"./legacy.js\";\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const SHA1 = SHA1n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const sha1 = sha1n;\n//# sourceMappingURL=sha1.js.map","/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nimport { RIPEMD160 as RIPEMD160n, ripemd160 as ripemd160n } from \"./legacy.js\";\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const RIPEMD160 = RIPEMD160n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const ripemd160 = ripemd160n;\n//# sourceMappingURL=ripemd160.js.map","// Copied from https://github.com/paulmillr/noble-hashes/blob/main/test/misc/md5.ts\n\nimport { HashMD } from '@noble/hashes/_md';\nimport { rotl, wrapConstructor } from '@noble/hashes/utils';\n\n// Per-round constants\nconst K = Array.from({ length: 64 }, (_, i) => Math.floor(2 ** 32 * Math.abs(Math.sin(i + 1))));\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Initial state (same as sha1, but 4 u32 instead of 5)\nconst IV = /* @__PURE__ */ new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n// Temporary buffer, not used to store anything between runs\n// Named this way for SHA1 compat\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\nclass MD5 extends HashMD<MD5> {\n  private A = IV[0] | 0;\n  private B = IV[1] | 0;\n  private C = IV[2] | 0;\n  private D = IV[3] | 0;\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      // eslint-disable-next-line one-var, one-var-declaration-per-line\n      let F, g, s;\n      if (i < 16) {\n        // eslint-disable-next-line new-cap\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        // eslint-disable-next-line new-cap\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean() {\n    MD5_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\nexport const md5 = /* @__PURE__ */ wrapConstructor(() => new MD5());\n","/**\n * This file is needed to dynamic import the noble-hashes.\n * Separate dynamic imports are not convenient as they result in too many chunks,\n * which share a lot of code anyway.\n */\n\nimport { sha1 } from '@noble/hashes/sha1';\nimport { sha224, sha256 } from '@noble/hashes/sha256';\nimport { sha384, sha512 } from '@noble/hashes/sha512';\nimport { sha3_256, sha3_512 } from '@noble/hashes/sha3';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { md5 } from './md5';\n\nexport const nobleHashes = new Map(Object.entries({\n  md5,\n  sha1,\n  sha224,\n  sha256,\n  sha384,\n  sha512,\n  sha3_256,\n  sha3_512,\n  ripemd160\n}));\n"],"names":["SHA1_IV","Uint32Array","from","SHA1_W","SHA1","HashMD","constructor","super","this","A","B","C","D","E","get","set","process","view","offset","i","getUint32","rotl","F","K","Chi","Maj","T","roundClean","clean","destroy","buffer","sha1","createHasher","Rho160","Uint8Array","Id160","Array","fill","map","_","Pi160","idxLR","res","j","push","k","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","x","y","z","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","destroyed","sha1n","ripemd160","length","Math","floor","abs","sin","a","b","c","IV","MD5_W","MD5","g","s","nobleHashes","Map","Object","entries","md5","wrapConstructor","sha224","sha256","sha384","sha512","sha3_256","sha3_512"],"mappings":"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","x_google_ignoreList":[0,1,2]}