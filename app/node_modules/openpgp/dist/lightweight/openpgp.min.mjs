/*! OpenPGP.js v6.0.0 - 2024-11-04 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
const e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=Symbol("doneWritingPromise"),r=Symbol("doneWritingResolve"),i=Symbol("doneWritingReject"),n=Symbol("readingIndex");class s extends Array{constructor(){super(),Object.setPrototypeOf(this,s.prototype),this[t]=new Promise(((e,t)=>{this[r]=e,this[i]=t})),this[t].catch((()=>{}))}}function a(e){return e&&e.getReader&&Array.isArray(e)}function o(e){if(!a(e)){const t=e.getWriter(),r=t.releaseLock;return t.releaseLock=()=>{t.closed.catch((function(){})),r.call(t)},t}this.stream=e}function c(t){if(a(t))return"array";if(e.ReadableStream&&e.ReadableStream.prototype.isPrototypeOf(t))return"web";if(t&&!(e.ReadableStream&&t instanceof e.ReadableStream)&&"function"==typeof t._read&&"object"==typeof t._readableState)throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");return!(!t||!t.getReader)&&"web-like"}function u(e){return Uint8Array.prototype.isPrototypeOf(e)}function h(e){if(1===e.length)return e[0];let t=0;for(let r=0;r<e.length;r++){if(!u(e[r]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");t+=e[r].length}const r=new Uint8Array(t);let i=0;return e.forEach((function(e){r.set(e,i),i+=e.length})),r}s.prototype.getReader=function(){return void 0===this[n]&&(this[n]=0),{read:async()=>(await this[t],this[n]===this.length?{value:void 0,done:!0}:{value:this[this[n]++],done:!1})}},s.prototype.readToEnd=async function(e){await this[t];const r=e(this.slice(this[n]));return this.length=0,r},s.prototype.clone=function(){const e=new s;return e[t]=this[t].then((()=>{e.push(...this)})),e},o.prototype.write=async function(e){this.stream.push(e)},o.prototype.close=async function(){this.stream[r]()},o.prototype.abort=async function(e){return this.stream[i](e),e},o.prototype.releaseLock=function(){},"object"==typeof e.process&&e.process.versions;const y=new WeakSet,l=Symbol("externalBuffer");function p(e){if(this.stream=e,e[l]&&(this[l]=e[l].slice()),a(e)){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{},void(this._cancel=()=>{})}if(c(e)){const t=e.getReader();return this._read=t.read.bind(t),this._releaseLock=()=>{t.closed.catch((function(){})),t.releaseLock()},void(this._cancel=t.cancel.bind(t))}let t=!1;this._read=async()=>t||y.has(e)?{value:void 0,done:!0}:(t=!0,{value:e,done:!1}),this._releaseLock=()=>{if(t)try{y.add(e)}catch(e){}}}function g(e){return c(e)?e:new ReadableStream({start(t){t.enqueue(e),t.close()}})}function d(e){if(c(e))return e;const t=new s;return(async()=>{const r=C(t);await r.write(e),await r.close()})(),t}function f(e){return e.some((e=>c(e)&&!a(e)))?function(e){e=e.map(g);const t=b((async function(e){await Promise.all(i.map((t=>D(t,e))))}));let r=Promise.resolve();const i=e.map(((i,n)=>v(i,((i,s)=>(r=r.then((()=>m(i,t.writable,{preventClose:n!==e.length-1}))),r)))));return t.readable}(e):e.some((e=>a(e)))?function(e){const t=new s;let r=Promise.resolve();return e.forEach(((i,n)=>(r=r.then((()=>m(i,t,{preventClose:n!==e.length-1}))),r))),t}(e):"string"==typeof e[0]?e.join(""):h(e)}async function m(e,t,{preventClose:r=!1,preventAbort:i=!1,preventCancel:n=!1}={}){if(c(e)&&!a(e)){e=g(e);try{if(e[l]){const r=C(t);for(let t=0;t<e[l].length;t++)await r.ready,await r.write(e[l][t]);r.releaseLock()}await e.pipeTo(t,{preventClose:r,preventAbort:i,preventCancel:n})}catch(e){}return}const s=I(e=d(e)),o=C(t);try{for(;;){await o.ready;const{done:e,value:t}=await s.read();if(e){r||await o.close();break}await o.write(t)}}catch(e){i||await o.abort(e)}finally{s.releaseLock(),o.releaseLock()}}function w(e,t){const r=new TransformStream(t);return m(e,r.writable),r.readable}function b(e){let t,r,i,n=!1,s=!1;return{readable:new ReadableStream({start(e){i=e},pull(){t?t():n=!0},async cancel(t){s=!0,e&&await e(t),r&&r(t)}},{highWaterMark:0}),writable:new WritableStream({write:async function(e){if(s)throw Error("Stream is cancelled");i.enqueue(e),n?n=!1:(await new Promise(((e,i)=>{t=e,r=i})),t=null,r=null)},close:i.close.bind(i),abort:i.error.bind(i)})}}function k(e,t=()=>{},r=()=>{}){if(a(e)){const i=new s;return(async()=>{const n=C(i);try{const i=await U(e),s=t(i),a=r();let o;o=void 0!==s&&void 0!==a?f([s,a]):void 0!==s?s:a,await n.write(o),await n.close()}catch(e){await n.abort(e)}})(),i}if(c(e))return w(e,{async transform(e,r){try{const i=await t(e);void 0!==i&&r.enqueue(i)}catch(e){r.error(e)}},async flush(e){try{const t=await r();void 0!==t&&e.enqueue(t)}catch(t){e.error(t)}}});const i=t(e),n=r();return void 0!==i&&void 0!==n?f([i,n]):void 0!==i?i:n}function v(e,t){if(c(e)&&!a(e)){let r;const i=new TransformStream({start(e){r=e}}),n=m(e,i.writable),s=b((async function(e){r.error(e),await n,await new Promise(setTimeout)}));return t(i.readable,s.writable),s.readable}e=d(e);const r=new s;return t(e,r),r}function A(e,t){let r;const i=v(e,((e,n)=>{const s=I(e);s.remainder=()=>(s.releaseLock(),m(e,n),i),r=t(s)}));return r}function K(e){if(a(e))return e.clone();if(c(e)){const t=function(e){if(a(e))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(c(e)){const t=g(e).tee();return t[0][l]=t[1][l]=e[l],t}return[P(e),P(e)]}(e);return S(e,t[0]),t[1]}return P(e)}function E(e){return a(e)?K(e):c(e)?new ReadableStream({start(t){const r=v(e,(async(e,r)=>{const i=I(e),n=C(r);try{for(;;){await n.ready;const{done:e,value:r}=await i.read();if(e){try{t.close()}catch(e){}return void await n.close()}try{t.enqueue(r)}catch(e){}await n.write(r)}}catch(e){t.error(e),await n.abort(e)}}));S(e,r)}}):P(e)}function S(e,t){Object.entries(Object.getOwnPropertyDescriptors(e.constructor.prototype)).forEach((([r,i])=>{"constructor"!==r&&(i.value?i.value=i.value.bind(t):i.get=i.get.bind(t),Object.defineProperty(e,r,i))}))}function P(e,t=0,r=1/0){if(a(e))throw Error("Not implemented");if(c(e)){if(t>=0&&r>=0){let i=0;return w(e,{transform(e,n){i<r?(i+e.length>=t&&n.enqueue(P(e,Math.max(t-i,0),r-i)),i+=e.length):n.terminate()}})}if(t<0&&(r<0||r===1/0)){let i=[];return k(e,(e=>{e.length>=-t?i=[e]:i.push(e)}),(()=>P(f(i),t,r)))}if(0===t&&r<0){let i;return k(e,(e=>{const n=i?f([i,e]):e;if(n.length>=-r)return i=P(n,r),P(n,t,r);i=n}))}return console.warn(`stream.slice(input, ${t}, ${r}) not implemented efficiently.`),x((async()=>P(await U(e),t,r)))}return e[l]&&(e=f(e[l].concat([e]))),u(e)?e.subarray(t,r===1/0?e.length:r):e.slice(t,r)}async function U(e,t=f){return a(e)?e.readToEnd(t):c(e)?I(e).readToEnd(t):e}async function D(e,t){if(c(e)){if(e.cancel){const r=await e.cancel(t);return await new Promise(setTimeout),r}if(e.destroy)return e.destroy(t),await new Promise(setTimeout),t}}function x(e){const t=new s;return(async()=>{const r=C(t);try{await r.write(await e()),await r.close()}catch(e){await r.abort(e)}})(),t}function I(e){return new p(e)}function C(e){return new o(e)}p.prototype.read=async function(){if(this[l]&&this[l].length){return{done:!1,value:this[l].shift()}}return this._read()},p.prototype.releaseLock=function(){this[l]&&(this.stream[l]=this[l]),this._releaseLock()},p.prototype.cancel=function(e){return this._cancel(e)},p.prototype.readLine=async function(){let e,t=[];for(;!e;){let{done:r,value:i}=await this.read();if(i+="",r)return t.length?f(t):void 0;const n=i.indexOf("\n")+1;n&&(e=f(t.concat(i.substr(0,n))),t=[]),n!==i.length&&t.push(i.substr(n))}return this.unshift(...t),e},p.prototype.readByte=async function(){const{done:e,value:t}=await this.read();if(e)return;const r=t[0];return this.unshift(P(t,1)),r},p.prototype.readBytes=async function(e){const t=[];let r=0;for(;;){const{done:i,value:n}=await this.read();if(i)return t.length?f(t):void 0;if(t.push(n),r+=n.length,r>=e){const r=f(t);return this.unshift(P(r,e)),P(r,0,e)}}},p.prototype.peekBytes=async function(e){const t=await this.readBytes(e);return this.unshift(t),t},p.prototype.unshift=function(...e){this[l]||(this[l]=[]),1===e.length&&u(e[0])&&this[l].length&&e[0].length&&this[l][0].byteOffset>=e[0].length?this[l][0]=new Uint8Array(this[l][0].buffer,this[l][0].byteOffset-e[0].length,this[l][0].byteLength+e[0].length):this[l].unshift(...e.filter((e=>e&&e.length)))},p.prototype.readToEnd=async function(e=f){const t=[];for(;;){const{done:e,value:r}=await this.read();if(e)break;t.push(r)}return e(t)};const B=Symbol("byValue");var T={curve:{nistP256:"nistP256",p256:"nistP256",nistP384:"nistP384",p384:"nistP384",nistP521:"nistP521",p521:"nistP521",secp256k1:"secp256k1",ed25519Legacy:"ed25519Legacy",ed25519:"ed25519Legacy",curve25519Legacy:"curve25519Legacy",curve25519:"curve25519Legacy",brainpoolP256r1:"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,argon2:4,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11,sha3_256:12,sha3_512:14},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,gcm:3,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20,padding:21},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuerKeyID:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34,preferredCipherSuites:39},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4,seipdv2:8},write:function(e,t){if("number"==typeof t&&(t=this.read(e,t)),void 0!==e[t])return e[t];throw Error("Invalid enum value.")},read:function(e,t){if(e[B]||(e[B]=[],Object.entries(e).forEach((([t,r])=>{e[B][r]=t}))),void 0!==e[B][t])return e[B][t];throw Error("Invalid enum value.")}},M={preferredHashAlgorithm:T.hash.sha512,preferredSymmetricAlgorithm:T.symmetric.aes256,preferredCompressionAlgorithm:T.compression.uncompressed,aeadProtect:!1,parseAEADEncryptedV4KeysAsLegacy:!1,preferredAEADAlgorithm:T.aead.gcm,aeadChunkSizeByte:12,v6Keys:!1,enableParsingV5Entities:!1,s2kType:T.s2k.iterated,s2kIterationCountByte:224,s2kArgon2Params:{passes:3,parallelism:4,memoryExponent:16},allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,minRSABits:2047,passwordCollisionCheck:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,allowMissingKeyFlags:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([T.symmetric.aes128,T.symmetric.aes192,T.symmetric.aes256]),ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 6.0.0",commentString:"https://openpgpjs.org",maxUserIDLength:5120,knownNotations:[],nonDeterministicSignaturesViaNotation:!0,useEllipticFallback:!0,rejectHashAlgorithms:new Set([T.hash.md5,T.hash.ripemd]),rejectMessageHashAlgorithms:new Set([T.hash.md5,T.hash.ripemd,T.hash.sha1]),rejectPublicKeyAlgorithms:new Set([T.publicKey.elgamal,T.publicKey.dsa]),rejectCurves:new Set([T.curve.secp256k1])};const L=(()=>{try{return"development"===process.env.NODE_ENV}catch(e){}return!1})(),F={isString:function(e){return"string"==typeof e||e instanceof String},nodeRequire:()=>{},isArray:function(e){return e instanceof Array},isUint8Array:u,isStream:c,getNobleCurve:async(e,t)=>{if(!M.useEllipticFallback)throw Error("This curve is only supported in the full build of OpenPGP.js");const{nobleCurves:r}=await import("./noble_curves.min.mjs");switch(e){case T.publicKey.ecdh:case T.publicKey.ecdsa:{const e=r.get(t);if(!e)throw Error("Unsupported curve");return e}case T.publicKey.x448:return r.get("x448");case T.publicKey.ed448:return r.get("ed448");default:throw Error("Unsupported curve")}},readNumber:function(e){let t=0;for(let r=0;r<e.length;r++)t+=256**r*e[e.length-1-r];return t},writeNumber:function(e,t){const r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e>>8*(t-i-1)&255;return r},readDate:function(e){const t=F.readNumber(e);return new Date(1e3*t)},writeDate:function(e){const t=Math.floor(e.getTime()/1e3);return F.writeNumber(t,4)},normalizeDate:function(e=Date.now()){return null===e||e===1/0?e:new Date(1e3*Math.floor(+e/1e3))},readMPI:function(e){const t=(e[0]<<8|e[1])+7>>>3;return F.readExactSubarray(e,2,2+t)},readExactSubarray:function(e,t,r){if(e.length<r-t)throw Error("Input array too short");return e.subarray(t,r)},leftPad(e,t){if(e.length>t)throw Error("Input array too long");const r=new Uint8Array(t),i=t-e.length;return r.set(e,i),r},uint8ArrayToMPI:function(e){const t=F.uint8ArrayBitLength(e);if(0===t)throw Error("Zero MPI");const r=e.subarray(e.length-Math.ceil(t/8)),i=new Uint8Array([(65280&t)>>8,255&t]);return F.concatUint8Array([i,r])},uint8ArrayBitLength:function(e){let t;for(t=0;t<e.length&&0===e[t];t++);if(t===e.length)return 0;const r=e.subarray(t);return 8*(r.length-1)+F.nbits(r[0])},hexToUint8Array:function(e){const t=new Uint8Array(e.length>>1);for(let r=0;r<e.length>>1;r++)t[r]=parseInt(e.substr(r<<1,2),16);return t},uint8ArrayToHex:function(e){const t="0123456789abcdef";let r="";return e.forEach((e=>{r+=t[e>>4]+t[15&e]})),r},stringToUint8Array:function(e){return k(e,(e=>{if(!F.isString(e))throw Error("stringToUint8Array: Data must be in the form of a string");const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}))},uint8ArrayToString:function(e){const t=[],r=16384,i=(e=new Uint8Array(e)).length;for(let n=0;n<i;n+=r)t.push(String.fromCharCode.apply(String,e.subarray(n,n+r<i?n+r:i)));return t.join("")},encodeUTF8:function(e){const t=new TextEncoder("utf-8");function r(e,r=!1){return t.encode(e,{stream:!r})}return k(e,r,(()=>r("",!0)))},decodeUTF8:function(e){const t=new TextDecoder("utf-8");function r(e,r=!1){return t.decode(e,{stream:!r})}return k(e,r,(()=>r(new Uint8Array,!0)))},concat:f,concatUint8Array:h,equalsUint8Array:function(e,t){if(!F.isUint8Array(e)||!F.isUint8Array(t))throw Error("Data must be in the form of a Uint8Array");if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0},writeChecksum:function(e){let t=0;for(let r=0;r<e.length;r++)t=t+e[r]&65535;return F.writeNumber(t,2)},printDebug:function(e){L&&console.log("[OpenPGP.js debug]",e)},printDebugError:function(e){L&&console.error("[OpenPGP.js debug]",e)},nbits:function(e){let t=1,r=e>>>16;return 0!==r&&(e=r,t+=16),r=e>>8,0!==r&&(e=r,t+=8),r=e>>4,0!==r&&(e=r,t+=4),r=e>>2,0!==r&&(e=r,t+=2),r=e>>1,0!==r&&(e=r,t+=1),t},double:function(e){const t=new Uint8Array(e.length),r=e.length-1;for(let i=0;i<r;i++)t[i]=e[i]<<1^e[i+1]>>7;return t[r]=e[r]<<1^135*(e[0]>>7),t},shiftRight:function(e,t){if(t)for(let r=e.length-1;r>=0;r--)e[r]>>=t,r>0&&(e[r]|=e[r-1]<<8-t);return e},getWebCrypto:function(){const t=void 0!==e&&e.crypto&&e.crypto.subtle||this.getNodeCrypto()?.webcrypto.subtle;if(!t)throw Error("The WebCrypto API is not available");return t},getNodeCrypto:function(){return this.nodeRequire("crypto")},getNodeZlib:function(){return this.nodeRequire("zlib")},getNodeBuffer:function(){return(this.nodeRequire("buffer")||{}).Buffer},getHardwareConcurrency:function(){if("undefined"!=typeof navigator)return navigator.hardwareConcurrency||1;return this.nodeRequire("os").cpus().length},isEmailAddress:function(e){if(!F.isString(e))return!1;return/^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(e)},canonicalizeEOL:function(e){let t=!1;return k(e,(e=>{let r;t&&(e=F.concatUint8Array([new Uint8Array([13]),e])),13===e[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;const i=[];for(let t=0;r=e.indexOf(10,t)+1,r;t=r)13!==e[r-2]&&i.push(r);if(!i.length)return e;const n=new Uint8Array(e.length+i.length);let s=0;for(let t=0;t<i.length;t++){const r=e.subarray(i[t-1]||0,i[t]);n.set(r,s),s+=r.length,n[s-1]=13,n[s]=10,s++}return n.set(e.subarray(i[i.length-1]||0),s),n}),(()=>t?new Uint8Array([13]):void 0))},nativeEOL:function(e){let t=!1;return k(e,(e=>{let r;13===(e=t&&10!==e[0]?F.concatUint8Array([new Uint8Array([13]),e]):new Uint8Array(e))[e.length-1]?(t=!0,e=e.subarray(0,-1)):t=!1;let i=0;for(let t=0;t!==e.length;t=r){r=e.indexOf(13,t)+1,r||(r=e.length);const n=r-(10===e[r]?1:0);t&&e.copyWithin(i,t,n),i+=n-t}return e.subarray(0,i)}),(()=>t?new Uint8Array([13]):void 0))},removeTrailingSpaces:function(e){return e.split("\n").map((e=>{let t=e.length-1;for(;t>=0&&(" "===e[t]||"\t"===e[t]||"\r"===e[t]);t--);return e.substr(0,t+1)})).join("\n")},wrapError:function(e,t){if(!t)return Error(e);try{t.message=e+": "+t.message}catch(e){}return t},constructAllowedPackets:function(e){const t={};return e.forEach((e=>{if(!e.tag)throw Error("Invalid input: expected a packet class");t[e.tag]=e})),t},anyPromise:function(e){return new Promise((async(t,r)=>{let i;await Promise.all(e.map((async e=>{try{t(await e)}catch(e){i=e}}))),r(i)}))},selectUint8Array:function(e,t,r){const i=Math.max(t.length,r.length),n=new Uint8Array(i);let s=0;for(let i=0;i<n.length;i++)n[i]=t[i]&256-e|r[i]&255+e,s+=e&i<t.length|1-e&i<r.length;return n.subarray(0,s)},selectUint8:function(e,t,r){return t&256-e|r&255+e},isAES:function(e){return e===T.symmetric.aes128||e===T.symmetric.aes192||e===T.symmetric.aes256}},R=F.getNodeBuffer();let N,z;function j(e){let t=new Uint8Array;return k(e,(e=>{t=F.concatUint8Array([t,e]);const r=[],i=Math.floor(t.length/45),n=45*i,s=N(t.subarray(0,n));for(let e=0;e<i;e++)r.push(s.substr(60*e,60)),r.push("\n");return t=t.subarray(n),r.join("")}),(()=>t.length?N(t)+"\n":""))}function O(e){let t="";return k(e,(e=>{t+=e;let r=0;const i=[" ","\t","\r","\n"];for(let e=0;e<i.length;e++){const n=i[e];for(let e=t.indexOf(n);-1!==e;e=t.indexOf(n,e+1))r++}let n=t.length;for(;n>0&&(n-r)%4!=0;n--)i.includes(t[n])&&r--;const s=z(t.substr(0,n));return t=t.substr(n),s}),(()=>z(t)))}function H(e){return O(e.replace(/-/g,"+").replace(/_/g,"/"))}function _(e,t){let r=j(e).replace(/[\r\n]/g,"");return r=r.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,""),r}function G(e){const t=e.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!t)throw Error("Unknown ASCII armor type");return/MESSAGE, PART \d+\/\d+/.test(t[1])?T.armor.multipartSection:/MESSAGE, PART \d+/.test(t[1])?T.armor.multipartLast:/SIGNED MESSAGE/.test(t[1])?T.armor.signed:/MESSAGE/.test(t[1])?T.armor.message:/PUBLIC KEY BLOCK/.test(t[1])?T.armor.publicKey:/PRIVATE KEY BLOCK/.test(t[1])?T.armor.privateKey:/SIGNATURE/.test(t[1])?T.armor.signature:void 0}function q(e,t){let r="";return t.showVersion&&(r+="Version: "+t.versionString+"\n"),t.showComment&&(r+="Comment: "+t.commentString+"\n"),e&&(r+="Comment: "+e+"\n"),r+="\n",r}function V(e){const t=function(e){let t=13501623;return k(e,(e=>{const r=$?Math.floor(e.length/4):0,i=new Uint32Array(e.buffer,e.byteOffset,r);for(let e=0;e<r;e++)t^=i[e],t=W[0][t>>24&255]^W[1][t>>16&255]^W[2][t>>8&255]^W[3][255&t];for(let i=4*r;i<e.length;i++)t=t>>8^W[0][255&t^e[i]]}),(()=>new Uint8Array([t,t>>8,t>>16])))}(e);return j(t)}R?(N=e=>R.from(e).toString("base64"),z=e=>{const t=R.from(e,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}):(N=e=>btoa(F.uint8ArrayToString(e)),z=e=>F.stringToUint8Array(atob(e)));const W=[Array(255),Array(255),Array(255),Array(255)];for(let e=0;e<=255;e++){let t=e<<16;for(let e=0;e<8;e++)t=t<<1^(8388608&t?8801531:0);W[0][e]=(16711680&t)>>16|65280&t|(255&t)<<16}for(let e=0;e<=255;e++)W[1][e]=W[0][e]>>8^W[0][255&W[0][e]];for(let e=0;e<=255;e++)W[2][e]=W[1][e]>>8^W[0][255&W[1][e]];for(let e=0;e<=255;e++)W[3][e]=W[2][e]>>8^W[0][255&W[2][e]];const $=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,255,!0),255===new Int16Array(e)[0]}();function Q(e){for(let t=0;t<e.length;t++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e[t])||F.printDebugError(Error("Improperly formatted armor header: "+e[t])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e[t])||F.printDebugError(Error("Unknown header: "+e[t]))}function X(e){let t=e;const r=e.lastIndexOf("=");return r>=0&&r!==e.length-1&&(t=e.slice(0,r)),t}function Y(e){return new Promise((async(t,r)=>{try{const i=/^-----[^-]+-----$/m,n=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let s;const a=[];let o,c,u=a,h=[];const y=O(v(e,(async(e,l)=>{const p=I(e);try{for(;;){let e=await p.readLine();if(void 0===e)throw Error("Misformed armored text");if(e=F.removeTrailingSpaces(e.replace(/[\r\n]/g,"")),s)if(o)c||s!==T.armor.signed||(i.test(e)?(h=h.join("\r\n"),c=!0,Q(u),u=[],o=!1):h.push(e.replace(/^- /,"")));else if(i.test(e)&&r(Error("Mandatory blank line missing between armor headers and armor data")),n.test(e)){if(Q(u),o=!0,c||s!==T.armor.signed){t({text:h,data:y,headers:a,type:s});break}}else u.push(e);else i.test(e)&&(s=G(e))}}catch(e){return void r(e)}const g=C(l);try{for(;;){await g.ready;const{done:e,value:t}=await p.read();if(e)throw Error("Misformed armored text");const r=t+"";if(-1!==r.indexOf("=")||-1!==r.indexOf("-")){let e=await p.readToEnd();e.length||(e=""),e=r+e,e=F.removeTrailingSpaces(e.replace(/\r/g,""));const t=e.split(i);if(1===t.length)throw Error("Misformed armored text");const n=X(t[0].slice(0,-1));await g.write(n);break}await g.write(r)}await g.ready,await g.close()}catch(e){await g.abort(e)}})))}catch(e){r(e)}})).then((async e=>(a(e.data)&&(e.data=await U(e.data)),e)))}function Z(e,t,r,i,n,s=!1,a=M){let o,c;e===T.armor.signed&&(o=t.text,c=t.hash,t=t.data);const u=s&&E(t),h=[];switch(e){case T.armor.multipartSection:h.push("-----BEGIN PGP MESSAGE, PART "+r+"/"+i+"-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP MESSAGE, PART "+r+"/"+i+"-----\n");break;case T.armor.multipartLast:h.push("-----BEGIN PGP MESSAGE, PART "+r+"-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP MESSAGE, PART "+r+"-----\n");break;case T.armor.signed:h.push("-----BEGIN PGP SIGNED MESSAGE-----\n"),h.push(c?`Hash: ${c}\n\n`:"\n"),h.push(o.replace(/^-/gm,"- -")),h.push("\n-----BEGIN PGP SIGNATURE-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP SIGNATURE-----\n");break;case T.armor.message:h.push("-----BEGIN PGP MESSAGE-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP MESSAGE-----\n");break;case T.armor.publicKey:h.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP PUBLIC KEY BLOCK-----\n");break;case T.armor.privateKey:h.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP PRIVATE KEY BLOCK-----\n");break;case T.armor.signature:h.push("-----BEGIN PGP SIGNATURE-----\n"),h.push(q(n,a)),h.push(j(t)),u&&h.push("=",V(u)),h.push("-----END PGP SIGNATURE-----\n")}return F.concat(h)}async function J(e){switch(e){case T.symmetric.aes128:case T.symmetric.aes192:case T.symmetric.aes256:throw Error("Not a legacy cipher");case T.symmetric.cast5:case T.symmetric.blowfish:case T.symmetric.twofish:case T.symmetric.tripledes:{const{legacyCiphers:t}=await import("./legacy_ciphers.min.mjs"),r=t.get(e);if(!r)throw Error("Unsupported cipher algorithm");return r}default:throw Error("Unsupported cipher algorithm")}}function ee(e){switch(e){case T.symmetric.aes128:case T.symmetric.aes192:case T.symmetric.aes256:case T.symmetric.twofish:return 16;case T.symmetric.blowfish:case T.symmetric.cast5:case T.symmetric.tripledes:return 8;default:throw Error("Unsupported cipher")}}function te(e){switch(e){case T.symmetric.aes128:case T.symmetric.blowfish:case T.symmetric.cast5:return 16;case T.symmetric.aes192:case T.symmetric.tripledes:return 24;case T.symmetric.aes256:case T.symmetric.twofish:return 32;default:throw Error("Unsupported cipher")}}function re(e){return{keySize:te(e),blockSize:ee(e)}}var ie=/*#__PURE__*/Object.freeze({__proto__:null,getCipherParams:re,getLegacyCipher:J});function ne(e,t){let r=e[0],i=e[1],n=e[2],s=e[3];r=ae(r,i,n,s,t[0],7,-680876936),s=ae(s,r,i,n,t[1],12,-389564586),n=ae(n,s,r,i,t[2],17,606105819),i=ae(i,n,s,r,t[3],22,-1044525330),r=ae(r,i,n,s,t[4],7,-176418897),s=ae(s,r,i,n,t[5],12,1200080426),n=ae(n,s,r,i,t[6],17,-1473231341),i=ae(i,n,s,r,t[7],22,-45705983),r=ae(r,i,n,s,t[8],7,1770035416),s=ae(s,r,i,n,t[9],12,-1958414417),n=ae(n,s,r,i,t[10],17,-42063),i=ae(i,n,s,r,t[11],22,-1990404162),r=ae(r,i,n,s,t[12],7,1804603682),s=ae(s,r,i,n,t[13],12,-40341101),n=ae(n,s,r,i,t[14],17,-1502002290),i=ae(i,n,s,r,t[15],22,1236535329),r=oe(r,i,n,s,t[1],5,-165796510),s=oe(s,r,i,n,t[6],9,-1069501632),n=oe(n,s,r,i,t[11],14,643717713),i=oe(i,n,s,r,t[0],20,-373897302),r=oe(r,i,n,s,t[5],5,-701558691),s=oe(s,r,i,n,t[10],9,38016083),n=oe(n,s,r,i,t[15],14,-660478335),i=oe(i,n,s,r,t[4],20,-405537848),r=oe(r,i,n,s,t[9],5,568446438),s=oe(s,r,i,n,t[14],9,-1019803690),n=oe(n,s,r,i,t[3],14,-187363961),i=oe(i,n,s,r,t[8],20,1163531501),r=oe(r,i,n,s,t[13],5,-1444681467),s=oe(s,r,i,n,t[2],9,-51403784),n=oe(n,s,r,i,t[7],14,1735328473),i=oe(i,n,s,r,t[12],20,-1926607734),r=ce(r,i,n,s,t[5],4,-378558),s=ce(s,r,i,n,t[8],11,-2022574463),n=ce(n,s,r,i,t[11],16,1839030562),i=ce(i,n,s,r,t[14],23,-35309556),r=ce(r,i,n,s,t[1],4,-1530992060),s=ce(s,r,i,n,t[4],11,1272893353),n=ce(n,s,r,i,t[7],16,-155497632),i=ce(i,n,s,r,t[10],23,-1094730640),r=ce(r,i,n,s,t[13],4,681279174),s=ce(s,r,i,n,t[0],11,-358537222),n=ce(n,s,r,i,t[3],16,-722521979),i=ce(i,n,s,r,t[6],23,76029189),r=ce(r,i,n,s,t[9],4,-640364487),s=ce(s,r,i,n,t[12],11,-421815835),n=ce(n,s,r,i,t[15],16,530742520),i=ce(i,n,s,r,t[2],23,-995338651),r=ue(r,i,n,s,t[0],6,-198630844),s=ue(s,r,i,n,t[7],10,1126891415),n=ue(n,s,r,i,t[14],15,-1416354905),i=ue(i,n,s,r,t[5],21,-57434055),r=ue(r,i,n,s,t[12],6,1700485571),s=ue(s,r,i,n,t[3],10,-1894986606),n=ue(n,s,r,i,t[10],15,-1051523),i=ue(i,n,s,r,t[1],21,-2054922799),r=ue(r,i,n,s,t[8],6,1873313359),s=ue(s,r,i,n,t[15],10,-30611744),n=ue(n,s,r,i,t[6],15,-1560198380),i=ue(i,n,s,r,t[13],21,1309151649),r=ue(r,i,n,s,t[4],6,-145523070),s=ue(s,r,i,n,t[11],10,-1120210379),n=ue(n,s,r,i,t[2],15,718787259),i=ue(i,n,s,r,t[9],21,-343485551),e[0]=pe(r,e[0]),e[1]=pe(i,e[1]),e[2]=pe(n,e[2]),e[3]=pe(s,e[3])}function se(e,t,r,i,n,s){return t=pe(pe(t,e),pe(i,s)),pe(t<<n|t>>>32-n,r)}function ae(e,t,r,i,n,s,a){return se(t&r|~t&i,e,t,n,s,a)}function oe(e,t,r,i,n,s,a){return se(t&i|r&~i,e,t,n,s,a)}function ce(e,t,r,i,n,s,a){return se(t^r^i,e,t,n,s,a)}function ue(e,t,r,i,n,s,a){return se(r^(t|~i),e,t,n,s,a)}function he(e){const t=[];let r;for(r=0;r<64;r+=4)t[r>>2]=e.charCodeAt(r)+(e.charCodeAt(r+1)<<8)+(e.charCodeAt(r+2)<<16)+(e.charCodeAt(r+3)<<24);return t}const ye="0123456789abcdef".split("");function le(e){let t="",r=0;for(;r<4;r++)t+=ye[e>>8*r+4&15]+ye[e>>8*r&15];return t}function pe(e,t){return e+t&4294967295}const ge=F.getWebCrypto(),de=F.getNodeCrypto(),fe=de&&de.getHashes();function me(e){if(de&&fe.includes(e))return async function(t){const r=de.createHash(e);return k(t,(e=>{r.update(e)}),(()=>new Uint8Array(r.digest())))}}function we(e,t){const r=async()=>{const{nobleHashes:t}=await import("./noble_hashes.min.mjs"),r=t.get(e);if(!r)throw Error("Unsupported hash");return r};return async function(e){if(a(e)&&(e=await U(e)),F.isStream(e)){const t=(await r()).create();return k(e,(e=>{t.update(e)}),(()=>t.digest()))}if(ge&&t)return new Uint8Array(await ge.digest(t,e));return(await r())(e)}}var be={md5:me("md5")||async function(e){const t=function(e){const t=e.length,r=[1732584193,-271733879,-1732584194,271733878];let i;for(i=64;i<=e.length;i+=64)ne(r,he(e.substring(i-64,i)));e=e.substring(i-64);const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(i=0;i<e.length;i++)n[i>>2]|=e.charCodeAt(i)<<(i%4<<3);if(n[i>>2]|=128<<(i%4<<3),i>55)for(ne(r,n),i=0;i<16;i++)n[i]=0;return n[14]=8*t,ne(r,n),r}(F.uint8ArrayToString(e));return F.hexToUint8Array(function(e){for(let t=0;t<e.length;t++)e[t]=le(e[t]);return e.join("")}(t))},sha1:me("sha1")||we("sha1","SHA-1"),sha224:me("sha224")||we("sha224"),sha256:me("sha256")||we("sha256","SHA-256"),sha384:me("sha384")||we("sha384","SHA-384"),sha512:me("sha512")||we("sha512","SHA-512"),ripemd:me("ripemd160")||we("ripemd160"),sha3_256:me("sha3-256")||we("sha3_256"),sha3_512:me("sha3-512")||we("sha3_512"),digest:function(e,t){switch(e){case T.hash.md5:return this.md5(t);case T.hash.sha1:return this.sha1(t);case T.hash.ripemd:return this.ripemd(t);case T.hash.sha256:return this.sha256(t);case T.hash.sha384:return this.sha384(t);case T.hash.sha512:return this.sha512(t);case T.hash.sha224:return this.sha224(t);case T.hash.sha3_256:return this.sha3_256(t);case T.hash.sha3_512:return this.sha3_512(t);default:throw Error("Unsupported hash function")}},getHashByteLength:function(e){switch(e){case T.hash.md5:return 16;case T.hash.sha1:case T.hash.ripemd:return 20;case T.hash.sha256:return 32;case T.hash.sha384:return 48;case T.hash.sha512:return 64;case T.hash.sha224:return 28;case T.hash.sha3_256:return 32;case T.hash.sha3_512:return 64;default:throw Error("Invalid hash algorithm.")}}};function ke(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function ve(e,...t){if(!ke(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Ae(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function Ke(e,t){ve(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const Ee=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),Se=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Pe=e=>new DataView(e.buffer,e.byteOffset,e.byteLength);if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw Error("Non little-endian hardware is not supported");function Ue(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw Error("string expected, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!ke(e))throw Error("Uint8Array expected, got "+typeof e);e=Be(e)}return e}function De(e,t){if(e.length!==t.length)return!1;let r=0;for(let i=0;i<e.length;i++)r|=e[i]^t[i];return 0===r}const xe=(e,t)=>(Object.assign(t,e),t);function Ie(e,t,r,i){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,i);const n=BigInt(32),s=BigInt(4294967295),a=Number(r>>n&s),o=Number(r&s);e.setUint32(t+0,a,i),e.setUint32(t+4,o,i)}function Ce(e){return e.byteOffset%4==0}function Be(e){return Uint8Array.from(e)}function Te(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Me=16,Le=/* @__PURE__ */new Uint8Array(16),Fe=Se(Le),Re=e=>(e>>>0&255)<<24|(e>>>8&255)<<16|(e>>>16&255)<<8|e>>>24&255;class Ne{constructor(e,t){this.blockLen=Me,this.outputLen=Me,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,ve(e=Ue(e),16);const r=Pe(e);let i=r.getUint32(0,!1),n=r.getUint32(4,!1),s=r.getUint32(8,!1),a=r.getUint32(12,!1);const o=[];for(let e=0;e<128;e++)o.push({s0:Re(i),s1:Re(n),s2:Re(s),s3:Re(a)}),({s0:i,s1:n,s2:s,s3:a}={s3:(h=s)<<31|(y=a)>>>1,s2:(u=n)<<31|h>>>1,s1:(c=i)<<31|u>>>1,s0:c>>>1^225<<24&-(1&y)});var c,u,h,y;const l=(e=>e>65536?8:e>1024?4:2)(t||1024);if(![1,2,4,8].includes(l))throw Error(`ghash: wrong window size=${l}, should be 2, 4 or 8`);this.W=l;const p=128/l,g=this.windowSize=2**l,d=[];for(let e=0;e<p;e++)for(let t=0;t<g;t++){let r=0,i=0,n=0,s=0;for(let a=0;a<l;a++){if(!(t>>>l-a-1&1))continue;const{s0:c,s1:u,s2:h,s3:y}=o[l*e+a];r^=c,i^=u,n^=h,s^=y}d.push({s0:r,s1:i,s2:n,s3:s})}this.t=d}_updateBlock(e,t,r,i){e^=this.s0,t^=this.s1,r^=this.s2,i^=this.s3;const{W:n,t:s,windowSize:a}=this;let o=0,c=0,u=0,h=0;const y=(1<<n)-1;let l=0;for(const p of[e,t,r,i])for(let e=0;e<4;e++){const t=p>>>8*e&255;for(let e=8/n-1;e>=0;e--){const r=t>>>n*e&y,{s0:i,s1:p,s2:g,s3:d}=s[l*a+r];o^=i,c^=p,u^=g,h^=d,l+=1}}this.s0=o,this.s1=c,this.s2=u,this.s3=h}update(e){e=Ue(e),Ae(this);const t=Se(e),r=Math.floor(e.length/Me),i=e.length%Me;for(let e=0;e<r;e++)this._updateBlock(t[4*e+0],t[4*e+1],t[4*e+2],t[4*e+3]);return i&&(Le.set(e.subarray(r*Me)),this._updateBlock(Fe[0],Fe[1],Fe[2],Fe[3]),Te(Fe)),this}destroy(){const{t:e}=this;for(const t of e)t.s0=0,t.s1=0,t.s2=0,t.s3=0}digestInto(e){Ae(this),Ke(e,this),this.finished=!0;const{s0:t,s1:r,s2:i,s3:n}=this,s=Se(e);return s[0]=t,s[1]=r,s[2]=i,s[3]=n,e}digest(){const e=new Uint8Array(Me);return this.digestInto(e),this.destroy(),e}}class ze extends Ne{constructor(e,t){const r=function(e){e.reverse();const t=1&e[15];let r=0;for(let t=0;t<e.length;t++){const i=e[t];e[t]=i>>>1|r,r=(1&i)<<7}return e[0]^=225&-t,e}(Be(e=Ue(e)));super(r,t),Te(r)}update(e){e=Ue(e),Ae(this);const t=Se(e),r=e.length%Me,i=Math.floor(e.length/Me);for(let e=0;e<i;e++)this._updateBlock(Re(t[4*e+3]),Re(t[4*e+2]),Re(t[4*e+1]),Re(t[4*e+0]));return r&&(Le.set(e.subarray(i*Me)),this._updateBlock(Re(Fe[3]),Re(Fe[2]),Re(Fe[1]),Re(Fe[0])),Te(Fe)),this}digestInto(e){Ae(this),Ke(e,this),this.finished=!0;const{s0:t,s1:r,s2:i,s3:n}=this,s=Se(e);return s[0]=t,s[1]=r,s[2]=i,s[3]=n,e.reverse()}}function je(e){const t=(t,r)=>e(r,t.length).update(Ue(t)).digest(),r=e(new Uint8Array(16),0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=(t,r)=>e(t,r),t}const Oe=je(((e,t)=>new Ne(e,t)));je(((e,t)=>new ze(e,t)));const He=16,_e=new Uint8Array(He),Ge=283;function qe(e){return e<<1^Ge&-(e>>7)}function Ve(e,t){let r=0;for(;t>0;t>>=1)r^=e&-(1&t),e=qe(e);return r}const We=/* @__PURE__ */(()=>{const e=new Uint8Array(256);for(let t=0,r=1;t<256;t++,r^=qe(r))e[t]=r;const t=new Uint8Array(256);t[0]=99;for(let r=0;r<255;r++){let i=e[255-r];i|=i<<8,t[e[r]]=255&(i^i>>4^i>>5^i>>6^i>>7^99)}return Te(e),t})(),$e=/* @__PURE__ */We.map(((e,t)=>We.indexOf(t))),Qe=e=>e<<24|e>>>8,Xe=e=>e<<8|e>>>24,Ye=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function Ze(e,t){if(256!==e.length)throw Error("Wrong sbox length");const r=new Uint32Array(256).map(((r,i)=>t(e[i]))),i=r.map(Xe),n=i.map(Xe),s=n.map(Xe),a=new Uint32Array(65536),o=new Uint32Array(65536),c=new Uint16Array(65536);for(let t=0;t<256;t++)for(let u=0;u<256;u++){const h=256*t+u;a[h]=r[t]^i[u],o[h]=n[t]^s[u],c[h]=e[t]<<8|e[u]}return{sbox:e,sbox2:c,T0:r,T1:i,T2:n,T3:s,T01:a,T23:o}}const Je=/* @__PURE__ */Ze(We,(e=>Ve(e,3)<<24|e<<16|e<<8|Ve(e,2))),et=/* @__PURE__ */Ze($e,(e=>Ve(e,11)<<24|Ve(e,13)<<16|Ve(e,9)<<8|Ve(e,14))),tt=/* @__PURE__ */(()=>{const e=new Uint8Array(16);for(let t=0,r=1;t<16;t++,r=qe(r))e[t]=r;return e})();function rt(e){ve(e);const t=e.length;if(![16,24,32].includes(t))throw Error("aes: wrong key size: should be 16, 24 or 32, got: "+t);const{sbox2:r}=Je,i=[];Ce(e)||i.push(e=Be(e));const n=Se(e),s=n.length,a=e=>st(r,e,e,e,e),o=new Uint32Array(t+28);o.set(n);for(let e=s;e<o.length;e++){let t=o[e-1];e%s==0?t=a(Qe(t))^tt[e/s-1]:s>6&&e%s==4&&(t=a(t)),o[e]=o[e-s]^t}return Te(...i),o}function it(e){const t=rt(e),r=t.slice(),i=t.length,{sbox2:n}=Je,{T0:s,T1:a,T2:o,T3:c}=et;for(let e=0;e<i;e+=4)for(let n=0;n<4;n++)r[e+n]=t[i-e-4+n];Te(t);for(let e=4;e<i-4;e++){const t=r[e],i=st(n,t,t,t,t);r[e]=s[255&i]^a[i>>>8&255]^o[i>>>16&255]^c[i>>>24]}return r}function nt(e,t,r,i,n,s){return e[r<<8&65280|i>>>8&255]^t[n>>>8&65280|s>>>24&255]}function st(e,t,r,i,n){return e[255&t|65280&r]|e[i>>>16&255|n>>>16&65280]<<16}function at(e,t,r,i,n){const{sbox2:s,T01:a,T23:o}=Je;let c=0;t^=e[c++],r^=e[c++],i^=e[c++],n^=e[c++];const u=e.length/4-2;for(let s=0;s<u;s++){const s=e[c++]^nt(a,o,t,r,i,n),u=e[c++]^nt(a,o,r,i,n,t),h=e[c++]^nt(a,o,i,n,t,r),y=e[c++]^nt(a,o,n,t,r,i);t=s,r=u,i=h,n=y}return{s0:e[c++]^st(s,t,r,i,n),s1:e[c++]^st(s,r,i,n,t),s2:e[c++]^st(s,i,n,t,r),s3:e[c++]^st(s,n,t,r,i)}}function ot(e,t,r,i,n){const{sbox2:s,T01:a,T23:o}=et;let c=0;t^=e[c++],r^=e[c++],i^=e[c++],n^=e[c++];const u=e.length/4-2;for(let s=0;s<u;s++){const s=e[c++]^nt(a,o,t,n,i,r),u=e[c++]^nt(a,o,r,t,n,i),h=e[c++]^nt(a,o,i,r,t,n),y=e[c++]^nt(a,o,n,i,r,t);t=s,r=u,i=h,n=y}return{s0:e[c++]^st(s,t,n,i,r),s1:e[c++]^st(s,r,t,n,i),s2:e[c++]^st(s,i,r,t,n),s3:e[c++]^st(s,n,i,r,t)}}function ct(e,t){if(void 0===t)return new Uint8Array(e);if(ve(t),t.length<e)throw Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);if(!Ce(t))throw Error("unaligned dst");return t}function ut(e,t,r,i){ve(t,He),ve(r);const n=r.length;i=ct(n,i);const s=t,a=Se(s);let{s0:o,s1:c,s2:u,s3:h}=at(e,a[0],a[1],a[2],a[3]);const y=Se(r),l=Se(i);for(let t=0;t+4<=y.length;t+=4){l[t+0]=y[t+0]^o,l[t+1]=y[t+1]^c,l[t+2]=y[t+2]^u,l[t+3]=y[t+3]^h;let r=1;for(let e=s.length-1;e>=0;e--)r=r+(255&s[e])|0,s[e]=255&r,r>>>=8;({s0:o,s1:c,s2:u,s3:h}=at(e,a[0],a[1],a[2],a[3]))}const p=He*Math.floor(y.length/4);if(p<n){const e=new Uint32Array([o,c,u,h]),t=Ee(e);for(let e=p,s=0;e<n;e++,s++)i[e]=r[e]^t[s];Te(e)}return i}function ht(e,t,r,i,n){ve(r,He),ve(i),n=ct(i.length,n);const s=r,a=Se(s),o=Pe(s),c=Se(i),u=Se(n),h=t?0:12,y=i.length;let l=o.getUint32(h,t),{s0:p,s1:g,s2:d,s3:f}=at(e,a[0],a[1],a[2],a[3]);for(let r=0;r+4<=c.length;r+=4)u[r+0]=c[r+0]^p,u[r+1]=c[r+1]^g,u[r+2]=c[r+2]^d,u[r+3]=c[r+3]^f,l=l+1>>>0,o.setUint32(h,l,t),({s0:p,s1:g,s2:d,s3:f}=at(e,a[0],a[1],a[2],a[3]));const m=He*Math.floor(c.length/4);if(m<y){const e=new Uint32Array([p,g,d,f]),t=Ee(e);for(let e=m,r=0;e<y;e++,r++)n[e]=i[e]^t[r];Te(e)}return n}const yt=xe({blockSize:16,nonceLength:16},(function(e,t){function r(r,i){if(ve(r),void 0!==i&&(ve(i),!Ce(i)))throw Error("unaligned destination");const n=rt(e),s=Be(t),a=[n,s];Ce(r)||a.push(r=Be(r));const o=ut(n,s,r,i);return Te(...a),o}return ve(e),ve(t,He),{encrypt:(e,t)=>r(e,t),decrypt:(e,t)=>r(e,t)}}));const lt=xe({blockSize:16,nonceLength:16},(function(e,t,r={}){ve(e),ve(t,16);const i=!r.disablePadding;return{encrypt(r,n){const s=rt(e),{b:a,o,out:c}=function(e,t,r){ve(e);let i=e.length;const n=i%He;if(!t&&0!==n)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");Ce(e)||(e=Be(e));const s=Se(e);if(t){let e=He-n;e||(e=He),i+=e}const a=ct(i,r);return{b:s,o:Se(a),out:a}}(r,i,n);let u=t;const h=[s];Ce(u)||h.push(u=Be(u));const y=Se(u);let l=y[0],p=y[1],g=y[2],d=y[3],f=0;for(;f+4<=a.length;)l^=a[f+0],p^=a[f+1],g^=a[f+2],d^=a[f+3],({s0:l,s1:p,s2:g,s3:d}=at(s,l,p,g,d)),o[f++]=l,o[f++]=p,o[f++]=g,o[f++]=d;if(i){const e=function(e){const t=new Uint8Array(16),r=Se(t);t.set(e);const i=He-e.length;for(let e=He-i;e<He;e++)t[e]=i;return r}(r.subarray(4*f));l^=e[0],p^=e[1],g^=e[2],d^=e[3],({s0:l,s1:p,s2:g,s3:d}=at(s,l,p,g,d)),o[f++]=l,o[f++]=p,o[f++]=g,o[f++]=d}return Te(...h),c},decrypt(r,n){!function(e){if(ve(e),e.length%He!=0)throw Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16")}(r);const s=it(e);let a=t;const o=[s];Ce(a)||o.push(a=Be(a));const c=Se(a),u=ct(r.length,n);Ce(r)||o.push(r=Be(r));const h=Se(r),y=Se(u);let l=c[0],p=c[1],g=c[2],d=c[3];for(let e=0;e+4<=h.length;){const t=l,r=p,i=g,n=d;l=h[e+0],p=h[e+1],g=h[e+2],d=h[e+3];const{s0:a,s1:o,s2:c,s3:u}=ot(s,l,p,g,d);y[e++]=a^t,y[e++]=o^r,y[e++]=c^i,y[e++]=u^n}return Te(...o),function(e,t){if(!t)return e;const r=e.length;if(!r)throw Error("aes/pcks5: empty ciphertext not allowed");const i=e[r-1];if(i<=0||i>16)throw Error("aes/pcks5: wrong padding");const n=e.subarray(0,-i);for(let t=0;t<i;t++)if(e[r-t-1]!==i)throw Error("aes/pcks5: wrong padding");return n}(u,i)}}})),pt=xe({blockSize:16,nonceLength:16},(function(e,t){function r(r,i,n){ve(r);const s=r.length;n=ct(s,n);const a=rt(e);let o=t;const c=[a];Ce(o)||c.push(o=Be(o)),Ce(r)||c.push(r=Be(r));const u=Se(r),h=Se(n),y=i?h:u,l=Se(o);let p=l[0],g=l[1],d=l[2],f=l[3];for(let e=0;e+4<=u.length;){const{s0:t,s1:r,s2:i,s3:n}=at(a,p,g,d,f);h[e+0]=u[e+0]^t,h[e+1]=u[e+1]^r,h[e+2]=u[e+2]^i,h[e+3]=u[e+3]^n,p=y[e++],g=y[e++],d=y[e++],f=y[e++]}const m=He*Math.floor(u.length/4);if(m<s){({s0:p,s1:g,s2:d,s3:f}=at(a,p,g,d,f));const e=Ee(new Uint32Array([p,g,d,f]));for(let t=m,i=0;t<s;t++,i++)n[t]=r[t]^e[i];Te(e)}return Te(...c),n}return ve(e),ve(t,16),{encrypt:(e,t)=>r(e,!0,t),decrypt:(e,t)=>r(e,!1,t)}}));const gt=xe({blockSize:16,nonceLength:12,tagLength:16},(function(e,t,r){if(ve(e),ve(t),void 0!==r&&ve(r),t.length<8)throw Error("aes/gcm: invalid nonce length");const i=16;function n(e,t,i){const n=function(e,t,r,i,n){const s=null==n?0:n.length,a=e.create(r,i.length+s);n&&a.update(n),a.update(i);const o=new Uint8Array(16),c=Pe(o);n&&Ie(c,0,BigInt(8*s),t),Ie(c,8,BigInt(8*i.length),t),a.update(o);const u=a.digest();return Te(o),u}(Oe,!1,e,i,r);for(let e=0;e<t.length;e++)n[e]^=t[e];return n}function s(){const r=rt(e),i=_e.slice(),n=_e.slice();if(ht(r,!1,n,n,i),12===t.length)n.set(t);else{const e=_e.slice();Ie(Pe(e),8,BigInt(8*t.length),!1);const r=Oe.create(i).update(t).update(e);r.digestInto(n),r.destroy()}return{xk:r,authKey:i,counter:n,tagMask:ht(r,!1,n,_e)}}return{encrypt(e){ve(e);const{xk:t,authKey:r,counter:a,tagMask:o}=s(),c=new Uint8Array(e.length+i),u=[t,r,a,o];Ce(e)||u.push(e=Be(e)),ht(t,!1,a,e,c);const h=n(r,o,c.subarray(0,c.length-i));return u.push(h),c.set(h,e.length),Te(...u),c},decrypt(e){if(ve(e),e.length<i)throw Error("aes/gcm: ciphertext less than tagLen (16)");const{xk:t,authKey:r,counter:a,tagMask:o}=s(),c=[t,r,o,a];Ce(e)||c.push(e=Be(e));const u=e.subarray(0,-16),h=e.subarray(-16),y=n(r,o,u);if(c.push(y),!De(y,h))throw Error("aes/gcm: invalid ghash tag");const l=ht(t,!1,a,u);return Te(...c),l}}}));function dt(e){return null!=e&&"object"==typeof e&&(e instanceof Uint32Array||"Uint32Array"===e.constructor.name)}function ft(e,t){if(ve(t,16),!dt(e))throw Error("_encryptBlock accepts result of expandKeyLE");const r=Se(t);let{s0:i,s1:n,s2:s,s3:a}=at(e,r[0],r[1],r[2],r[3]);return r[0]=i,r[1]=n,r[2]=s,r[3]=a,t}function mt(e,t){if(ve(t,16),!dt(e))throw Error("_decryptBlock accepts result of expandKeyLE");const r=Se(t);let{s0:i,s1:n,s2:s,s3:a}=ot(e,r[0],r[1],r[2],r[3]);return r[0]=i,r[1]=n,r[2]=s,r[3]=a,t}const wt={encrypt(e,t){if(t.length>=2**32)throw Error("plaintext should be less than 4gb");const r=rt(e);if(16===t.length)ft(r,t);else{const e=Se(t);let i=e[0],n=e[1];for(let t=0,s=1;t<6;t++)for(let t=2;t<e.length;t+=2,s++){const{s0:a,s1:o,s2:c,s3:u}=at(r,i,n,e[t],e[t+1]);i=a,n=o^Ye(s),e[t]=c,e[t+1]=u}e[0]=i,e[1]=n}r.fill(0)},decrypt(e,t){if(t.length-8>=2**32)throw Error("ciphertext should be less than 4gb");const r=it(e),i=t.length/8-1;if(1===i)mt(r,t);else{const e=Se(t);let n=e[0],s=e[1];for(let t=0,a=6*i;t<6;t++)for(let t=2*i;t>=1;t-=2,a--){s^=Ye(a);const{s0:i,s1:o,s2:c,s3:u}=ot(r,n,s,e[t],e[t+1]);n=i,s=o,e[t]=c,e[t+1]=u}e[0]=n,e[1]=s}r.fill(0)}},bt=new Uint8Array(8).fill(166),kt=xe({blockSize:8},(e=>({encrypt(t){if(ve(t),!t.length||t.length%8!=0)throw Error("invalid plaintext length");if(8===t.length)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");const r=function(...e){let t=0;for(let r=0;r<e.length;r++){const i=e[r];ve(i),t+=i.length}const r=new Uint8Array(t);for(let t=0,i=0;t<e.length;t++){const n=e[t];r.set(n,i),i+=n.length}return r}(bt,t);return wt.encrypt(e,r),r},decrypt(t){if(ve(t),t.length%8!=0||t.length<24)throw Error("invalid ciphertext length");const r=Be(t);if(wt.decrypt(e,r),!De(r.subarray(0,8),bt))throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8)}}))),vt={expandKeyLE:rt,expandKeyDecLE:it,encrypt:at,decrypt:ot,encryptBlock:ft,decryptBlock:mt,ctrCounter:ut,ctr32:ht},At=F.getWebCrypto(),Kt=F.getNodeCrypto(),Et=Kt?Kt.getCiphers():[],St={idea:Et.includes("idea-cfb")?"idea-cfb":void 0,tripledes:Et.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:Et.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:Et.includes("bf-cfb")?"bf-cfb":void 0,aes128:Et.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:Et.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:Et.includes("aes-256-cfb")?"aes-256-cfb":void 0};class Pt{constructor(e,t,r){const{blockSize:i}=re(e);this.key=t,this.prevBlock=r,this.nextBlock=new Uint8Array(i),this.i=0,this.blockSize=i,this.zeroBlock=new Uint8Array(this.blockSize)}static async isSupported(e){const{keySize:t}=re(e);return At.importKey("raw",new Uint8Array(t),"aes-cbc",!1,["encrypt"]).then((()=>!0),(()=>!1))}async _runCBC(e,t){const r="AES-CBC";this.keyRef=this.keyRef||await At.importKey("raw",this.key,r,!1,["encrypt"]);const i=await At.encrypt({name:r,iv:t||this.zeroBlock},this.keyRef,e);return new Uint8Array(i).subarray(0,e.length)}async encryptChunk(e){const t=this.nextBlock.length-this.i,r=e.subarray(0,t);if(this.nextBlock.set(r,this.i),this.i+e.length>=2*this.blockSize){const r=(e.length-t)%this.blockSize,i=F.concatUint8Array([this.nextBlock,e.subarray(t,e.length-r)]),n=F.concatUint8Array([this.prevBlock,i.subarray(0,i.length-this.blockSize)]),s=await this._runCBC(n);return Dt(s,i),this.prevBlock=s.slice(-this.blockSize),r>0&&this.nextBlock.set(e.subarray(-r)),this.i=r,s}let i;if(this.i+=r.length,this.i===this.nextBlock.length){const t=this.nextBlock;i=await this._runCBC(this.prevBlock),Dt(i,t),this.prevBlock=i.slice(),this.i=0;const n=e.subarray(r.length);this.nextBlock.set(n,this.i),this.i+=n.length}else i=new Uint8Array;return i}async finish(){let e;if(0===this.i)e=new Uint8Array;else{this.nextBlock=this.nextBlock.subarray(0,this.i);const t=this.nextBlock,r=await this._runCBC(this.prevBlock);Dt(r,t),e=r.subarray(0,t.length)}return this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.keyRef=null,this.key=null}async encrypt(e){const t=(await this._runCBC(F.concatUint8Array([new Uint8Array(this.blockSize),e]),this.iv)).subarray(0,e.length);return Dt(t,e),this.clearSensitiveData(),t}}class Ut{constructor(e,t,r,i){this.forEncryption=e;const{blockSize:n}=re(t);this.key=vt.expandKeyLE(r),i.byteOffset%4!=0&&(i=i.slice()),this.prevBlock=xt(i),this.nextBlock=new Uint8Array(n),this.i=0,this.blockSize=n}_runCFB(e){const t=xt(e),r=new Uint8Array(e.length),i=xt(r);for(let e=0;e+4<=i.length;e+=4){const{s0:r,s1:n,s2:s,s3:a}=vt.encrypt(this.key,this.prevBlock[0],this.prevBlock[1],this.prevBlock[2],this.prevBlock[3]);i[e+0]=t[e+0]^r,i[e+1]=t[e+1]^n,i[e+2]=t[e+2]^s,i[e+3]=t[e+3]^a,this.prevBlock=(this.forEncryption?i:t).slice(e,e+4)}return r}async processChunk(e){const t=this.nextBlock.length-this.i,r=e.subarray(0,t);if(this.nextBlock.set(r,this.i),this.i+e.length>=2*this.blockSize){const r=(e.length-t)%this.blockSize,i=F.concatUint8Array([this.nextBlock,e.subarray(t,e.length-r)]),n=this._runCFB(i);return r>0&&this.nextBlock.set(e.subarray(-r)),this.i=r,n}let i;if(this.i+=r.length,this.i===this.nextBlock.length){i=this._runCFB(this.nextBlock),this.i=0;const t=e.subarray(r.length);this.nextBlock.set(t,this.i),this.i+=t.length}else i=new Uint8Array;return i}async finish(){let e;if(0===this.i)e=new Uint8Array;else{e=this._runCFB(this.nextBlock).subarray(0,this.i)}return this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.key.fill(0)}}function Dt(e,t){const r=Math.min(e.length,t.length);for(let i=0;i<r;i++)e[i]=e[i]^t[i]}const xt=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4));var It=/*#__PURE__*/Object.freeze({__proto__:null,decrypt:async function(e,t,r,i){const n=T.read(T.symmetric,e);if(Kt&&St[n])return function(e,t,r,i){const n=T.read(T.symmetric,e),s=new Kt.createDecipheriv(St[n],t,i);return k(r,(e=>new Uint8Array(s.update(e))))}(e,t,r,i);if(F.isAES(e))return async function(e,t,r,i){if(F.isStream(r)){const n=new Ut(!1,e,t,i);return k(r,(e=>n.processChunk(e)),(()=>n.finish()))}return pt(t,i).decrypt(r)}(e,t,r,i);const s=new(await J(e))(t),a=s.blockSize;let o=i,c=new Uint8Array;const u=e=>{e&&(c=F.concatUint8Array([c,e]));const t=new Uint8Array(c.length);let r,i=0;for(;e?c.length>=a:c.length;){const e=s.encrypt(o);for(o=c.subarray(0,a),r=0;r<a;r++)t[i++]=o[r]^e[r];c=c.subarray(a)}return t.subarray(0,i)};return k(r,u,u)},encrypt:async function(e,t,r,i,n){const s=T.read(T.symmetric,e);if(F.getNodeCrypto()&&St[s])return function(e,t,r,i){const n=T.read(T.symmetric,e),s=new Kt.createCipheriv(St[n],t,i);return k(r,(e=>new Uint8Array(s.update(e))))}(e,t,r,i);if(F.isAES(e))return async function(e,t,r,i){if(At&&await Pt.isSupported(e)){const n=new Pt(e,t,i);return F.isStream(r)?k(r,(e=>n.encryptChunk(e)),(()=>n.finish())):n.encrypt(r)}if(F.isStream(r)){const n=new Ut(!0,e,t,i);return k(r,(e=>n.processChunk(e)),(()=>n.finish()))}return pt(t,i).encrypt(r)}(e,t,r,i);const a=new(await J(e))(t),o=a.blockSize,c=i.slice();let u=new Uint8Array;const h=e=>{e&&(u=F.concatUint8Array([u,e]));const t=new Uint8Array(u.length);let r,i=0;for(;e?u.length>=o:u.length;){const e=a.encrypt(c);for(r=0;r<o;r++)c[r]=u[r]^e[r],t[i++]=c[r];u=u.subarray(o)}return t.subarray(0,i)};return k(r,h,h)}});const Ct=F.getWebCrypto(),Bt=F.getNodeCrypto(),Tt=16;function Mt(e,t){const r=e.length-Tt;for(let i=0;i<Tt;i++)e[i+r]^=t[i];return e}const Lt=new Uint8Array(Tt);async function Ft(e){const t=await Rt(e),r=F.double(await t(Lt)),i=F.double(r);return async function(e){return(await t(function(e,t,r){if(e.length&&e.length%Tt==0)return Mt(e,t);const i=new Uint8Array(e.length+(Tt-e.length%Tt));return i.set(e),i[e.length]=128,Mt(i,r)}(e,r,i))).subarray(-Tt)}}async function Rt(e){if(F.getNodeCrypto())return async function(t){const r=new Bt.createCipheriv("aes-"+8*e.length+"-cbc",e,Lt).update(t);return new Uint8Array(r)};if(F.getWebCrypto())try{return e=await Ct.importKey("raw",e,{name:"AES-CBC",length:8*e.length},!1,["encrypt"]),async function(t){const r=await Ct.encrypt({name:"AES-CBC",iv:Lt,length:8*Tt},e,t);return new Uint8Array(r).subarray(0,r.byteLength-Tt)}}catch(t){if("NotSupportedError"!==t.name&&(24!==e.length||"OperationError"!==t.name))throw t;F.printDebugError("Browser did not support operation: "+t.message)}return async function(t){return lt(e,Lt,{disablePadding:!0}).encrypt(t)}}const Nt=F.getWebCrypto(),zt=F.getNodeCrypto(),jt=F.getNodeBuffer(),Ot=16,Ht=Ot,_t=Ot,Gt=new Uint8Array(Ot),qt=new Uint8Array(Ot);qt[Ot-1]=1;const Vt=new Uint8Array(Ot);async function Wt(e){const t=await Ft(e);return function(e,r){return t(F.concatUint8Array([e,r]))}}async function $t(e){if(F.getNodeCrypto())return async function(t,r){const i=new zt.createCipheriv("aes-"+8*e.length+"-ctr",e,r),n=jt.concat([i.update(t),i.final()]);return new Uint8Array(n)};if(F.getWebCrypto())try{const t=await Nt.importKey("raw",e,{name:"AES-CTR",length:8*e.length},!1,["encrypt"]);return async function(e,r){const i=await Nt.encrypt({name:"AES-CTR",counter:r,length:8*Ot},t,e);return new Uint8Array(i)}}catch(t){if("NotSupportedError"!==t.name&&(24!==e.length||"OperationError"!==t.name))throw t;F.printDebugError("Browser did not support operation: "+t.message)}return async function(t,r){return yt(e,r).encrypt(t)}}async function Qt(e,t){if(e!==T.symmetric.aes128&&e!==T.symmetric.aes192&&e!==T.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[r,i]=await Promise.all([Wt(t),$t(t)]);return{encrypt:async function(e,t,n){const[s,a]=await Promise.all([r(Gt,t),r(qt,n)]),o=await i(e,s),c=await r(Vt,o);for(let e=0;e<_t;e++)c[e]^=a[e]^s[e];return F.concatUint8Array([o,c])},decrypt:async function(e,t,n){if(e.length<_t)throw Error("Invalid EAX ciphertext");const s=e.subarray(0,-_t),a=e.subarray(-_t),[o,c,u]=await Promise.all([r(Gt,t),r(qt,n),r(Vt,s)]),h=u;for(let e=0;e<_t;e++)h[e]^=c[e]^o[e];if(!F.equalsUint8Array(a,h))throw Error("Authentication tag mismatch");return await i(s,o)}}}Vt[Ot-1]=2,Qt.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[8+e]^=t[e];return r},Qt.blockLength=Ot,Qt.ivLength=Ht,Qt.tagLength=_t;const Xt=16,Yt=16;function Zt(e){let t=0;for(let r=1;!(e&r);r<<=1)t++;return t}function Jt(e,t){for(let r=0;r<e.length;r++)e[r]^=t[r];return e}function er(e,t){return Jt(e.slice(),t)}const tr=new Uint8Array(Xt),rr=new Uint8Array([1]);async function ir(e,t){const{keySize:r}=re(e);if(!F.isAES(e)||t.length!==r)throw Error("Unexpected algorithm or key size");let i=0;const n=lt(t,tr,{disablePadding:!0}),s=e=>n.encrypt(e),a=e=>n.decrypt(e);let o;function c(e,t,r,n){const a=t.length/Xt|0;!function(e,t){const r=F.nbits(Math.max(e.length,t.length)/Xt|0)-1;for(let e=i+1;e<=r;e++)o[e]=F.double(o[e-1]);i=r}(t,n);const c=F.concatUint8Array([tr.subarray(0,15-r.length),rr,r]),u=63&c[15];c[15]&=192;const h=s(c),y=F.concatUint8Array([h,er(h.subarray(0,8),h.subarray(1,9))]),l=F.shiftRight(y.subarray(0+(u>>3),17+(u>>3)),8-(7&u)).subarray(1),p=new Uint8Array(Xt),g=new Uint8Array(t.length+Yt);let d,f=0;for(d=0;d<a;d++)Jt(l,o[Zt(d+1)]),g.set(Jt(e(er(l,t)),l),f),Jt(p,e===s?t:g.subarray(f)),t=t.subarray(Xt),f+=Xt;if(t.length){Jt(l,o.x);const r=s(l);g.set(er(t,r),f);const i=new Uint8Array(Xt);i.set(e===s?t:g.subarray(f,-16),0),i[t.length]=128,Jt(p,i),f+=t.length}const m=Jt(s(Jt(Jt(p,l),o.$)),function(e){if(!e.length)return tr;const t=e.length/Xt|0,r=new Uint8Array(Xt),i=new Uint8Array(Xt);for(let n=0;n<t;n++)Jt(r,o[Zt(n+1)]),Jt(i,s(er(r,e))),e=e.subarray(Xt);if(e.length){Jt(r,o.x);const t=new Uint8Array(Xt);t.set(e,0),t[e.length]=128,Jt(t,r),Jt(i,s(t))}return i}(n));return g.set(m,f),g}return function(){const e=s(tr),t=F.double(e);o=[],o[0]=F.double(t),o.x=e,o.$=t}(),{encrypt:async function(e,t,r){return c(s,e,t,r)},decrypt:async function(e,t,r){if(e.length<Yt)throw Error("Invalid OCB ciphertext");const i=e.subarray(-16);e=e.subarray(0,-16);const n=c(a,e,t,r);if(F.equalsUint8Array(i,n.subarray(-16)))return n.subarray(0,-16);throw Error("Authentication tag mismatch")}}}ir.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[7+e]^=t[e];return r},ir.blockLength=Xt,ir.ivLength=15,ir.tagLength=Yt;const nr=F.getWebCrypto(),sr=F.getNodeCrypto(),ar=F.getNodeBuffer(),or=16,cr="AES-GCM";async function ur(e,t){if(e!==T.symmetric.aes128&&e!==T.symmetric.aes192&&e!==T.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(F.getNodeCrypto())return{encrypt:async function(e,r,i=new Uint8Array){const n=new sr.createCipheriv("aes-"+8*t.length+"-gcm",t,r);n.setAAD(i);const s=ar.concat([n.update(e),n.final(),n.getAuthTag()]);return new Uint8Array(s)},decrypt:async function(e,r,i=new Uint8Array){const n=new sr.createDecipheriv("aes-"+8*t.length+"-gcm",t,r);n.setAAD(i),n.setAuthTag(e.slice(e.length-or,e.length));const s=ar.concat([n.update(e.slice(0,e.length-or)),n.final()]);return new Uint8Array(s)}};if(F.getWebCrypto())try{const e=await nr.importKey("raw",t,{name:cr},!1,["encrypt","decrypt"]),r=navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/)||navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);return{encrypt:async function(i,n,s=new Uint8Array){if(r&&!i.length)return gt(t,n,s).encrypt(i);const a=await nr.encrypt({name:cr,iv:n,additionalData:s,tagLength:128},e,i);return new Uint8Array(a)},decrypt:async function(i,n,s=new Uint8Array){if(r&&i.length===or)return gt(t,n,s).decrypt(i);try{const t=await nr.decrypt({name:cr,iv:n,additionalData:s,tagLength:128},e,i);return new Uint8Array(t)}catch(e){if("OperationError"===e.name)throw Error("Authentication tag mismatch")}}}}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;F.printDebugError("Browser did not support operation: "+e.message)}return{encrypt:async function(e,r,i){return gt(t,r,i).encrypt(e)},decrypt:async function(e,r,i){return gt(t,r,i).decrypt(e)}}}ur.getNonce=function(e,t){const r=e.slice();for(let e=0;e<t.length;e++)r[4+e]^=t[e];return r},ur.blockLength=16,ur.ivLength=12,ur.tagLength=or;var hr={cfb:It,gcm:ur,experimentalGCM:ur,eax:Qt,ocb:ir};const yr=BigInt(0),lr=BigInt(1);function pr(e){const t="0123456789ABCDEF";let r="";return e.forEach((e=>{r+=t[e>>4]+t[15&e]})),BigInt("0x0"+r)}function gr(e,t){const r=e%t;return r<yr?r+t:r}function dr(e,t,r){if(r===yr)throw Error("Modulo cannot be zero");if(r===lr)return BigInt(0);if(t<yr)throw Error("Unsopported negative exponent");let i=t,n=e;n%=r;let s=BigInt(1);for(;i>yr;){const e=i&lr;i>>=lr;s=e?s*n%r:s,n=n*n%r}return s}function fr(e){return e>=yr?e:-e}function mr(e,t){const{gcd:r,x:i}=function(e,t){let r=BigInt(0),i=BigInt(1),n=BigInt(1),s=BigInt(0),a=fr(e),o=fr(t);const c=e<yr,u=t<yr;for(;o!==yr;){const e=a/o;let t=r;r=n-e*r,n=t,t=i,i=s-e*i,s=t,t=o,o=a%o,a=t}return{x:c?-n:n,y:u?-s:s,gcd:a}}(e,t);if(r!==lr)throw Error("Inverse does not exist");return gr(i+t,t)}function wr(e){const t=Number(e);if(t>Number.MAX_SAFE_INTEGER)throw Error("Number can only safely store up to 53 bits");return t}function br(e,t){return(e>>BigInt(t)&lr)===yr?0:1}function kr(e){const t=e<yr?BigInt(-1):yr;let r=1,i=e;for(;(i>>=lr)!==t;)r++;return r}function vr(e){const t=e<yr?BigInt(-1):yr,r=BigInt(8);let i=1,n=e;for(;(n>>=r)!==t;)i++;return i}function Ar(e,t="be",r){let i=e.toString(16);i.length%2==1&&(i="0"+i);const n=i.length/2,s=new Uint8Array(r||n),a=r?r-n:0;let o=0;for(;o<n;)s[o+a]=parseInt(i.slice(2*o,2*o+2),16),o++;return"be"!==t&&s.reverse(),s}const Kr=F.getNodeCrypto();function Er(e){const t="undefined"!=typeof crypto?crypto:Kr?.webcrypto;if(t?.getRandomValues){const r=new Uint8Array(e);return t.getRandomValues(r)}throw Error("No secure random number generator available.")}function Sr(e,t){if(t<e)throw Error("Illegal parameter value: max <= min");const r=t-e;return gr(pr(Er(vr(r)+8)),r)+e}var Pr=/*#__PURE__*/Object.freeze({__proto__:null,getRandomBigInteger:Sr,getRandomBytes:Er});const Ur=BigInt(1);function Dr(e,t,r){const i=BigInt(30),n=Ur<<BigInt(e-1),s=[1,6,5,4,3,2,1,4,3,2,1,2,1,4,3,2,1,2,1,4,3,2,1,6,5,4,3,2,1,2];let a=Sr(n,n<<Ur),o=wr(gr(a,i));do{a+=BigInt(s[o]),o=(o+s[o])%s.length,kr(a)>e&&(a=gr(a,n<<Ur),a+=n,o=wr(gr(a,i)))}while(!xr(a,t,r));return a}function xr(e,t,r){return(!t||function(e,t){let r=e,i=t;for(;i!==yr;){const e=i;i=r%i,r=e}return r}(e-Ur,t)===Ur)&&(!!function(e){const t=BigInt(0);return Ir.every((r=>gr(e,r)!==t))}(e)&&(!!function(e,t=BigInt(2)){return dr(t,e-Ur,e)===Ur}(e)&&!!function(e,t){const r=kr(e);t||(t=Math.max(1,r/48|0));const i=e-Ur;let n=0;for(;!br(i,n);)n++;const s=e>>BigInt(n);for(;t>0;t--){let t,r=dr(Sr(BigInt(2),i),s,e);if(r!==Ur&&r!==i){for(t=1;t<n;t++){if(r=gr(r*r,e),r===Ur)return!1;if(r===i)break}if(t===n)return!1}}return!0}(e,r)))}const Ir=[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999].map((e=>BigInt(e)));const Cr=[];function Br(e,t){const r=e.length;if(r>t-11)throw Error("Message too long");const i=function(e){const t=new Uint8Array(e);let r=0;for(;r<e;){const i=Er(e-r);for(let e=0;e<i.length;e++)0!==i[e]&&(t[r++]=i[e])}return t}(t-r-3),n=new Uint8Array(t);return n[1]=2,n.set(i,2),n.set(e,t-r),n}function Tr(e,t){let r=2,i=1;for(let t=r;t<e.length;t++)i&=0!==e[t],r+=i;const n=r-2,s=e.subarray(r+1),a=0===e[0]&2===e[1]&n>=8&!i;if(t)return F.selectUint8Array(a,s,t);if(a)return s;throw Error("Decryption error")}function Mr(e,t,r){let i;if(t.length!==be.getHashByteLength(e))throw Error("Invalid hash length");const n=new Uint8Array(Cr[e].length);for(i=0;i<Cr[e].length;i++)n[i]=Cr[e][i];const s=n.length+t.length;if(r<s+11)throw Error("Intended encoded message length too short");const a=new Uint8Array(r-s-3).fill(255),o=new Uint8Array(r);return o[1]=1,o.set(a,2),o.set(n,r-s),o.set(t,r-t.length),o}Cr[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],Cr[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],Cr[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],Cr[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],Cr[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],Cr[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],Cr[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];var Lr=/*#__PURE__*/Object.freeze({__proto__:null,emeDecode:Tr,emeEncode:Br,emsaEncode:Mr});const Fr=F.getWebCrypto(),Rr=F.getNodeCrypto(),Nr=BigInt(1);async function zr(e,t,r,i,n,s){const a=pr(i),o=pr(n),c=pr(r);let u=gr(c,o-Nr),h=gr(c,a-Nr);return h=Ar(h),u=Ar(u),{kty:"RSA",n:_(e),e:_(t),d:_(r),p:_(n),q:_(i),dp:_(u),dq:_(h),qi:_(s),ext:!0}}function jr(e,t){return{kty:"RSA",n:_(e),e:_(t),ext:!0}}function Or(e,t){return{n:H(e.n),e:Ar(t),d:H(e.d),p:H(e.q),q:H(e.p),u:H(e.qi)}}var Hr=/*#__PURE__*/Object.freeze({__proto__:null,decrypt:async function(e,t,r,i,n,s,a,o){if(F.getNodeCrypto()&&!o)try{return await async function(e,t,r,i,n,s,a){const o=await zr(t,r,i,n,s,a),c={key:o,format:"jwk",type:"pkcs1",padding:Rr.constants.RSA_PKCS1_PADDING};try{return new Uint8Array(Rr.privateDecrypt(c,e))}catch(e){throw Error("Decryption error")}}(e,t,r,i,n,s,a)}catch(e){F.printDebugError(e)}return async function(e,t,r,i,n,s,a,o){if(e=pr(e),t=pr(t),r=pr(r),i=pr(i),n=pr(n),s=pr(s),a=pr(a),e>=t)throw Error("Data too large.");const c=gr(i,s-Nr),u=gr(i,n-Nr),h=Sr(BigInt(2),t),y=dr(mr(h,t),r,t);e=gr(e*y,t);const l=dr(e,u,n),p=dr(e,c,s),g=gr(a*(p-l),s);let d=g*n+l;return d=gr(d*h,t),Tr(Ar(d,"be",vr(t)),o)}(e,t,r,i,n,s,a,o)},encrypt:async function(e,t,r){return F.getNodeCrypto()?async function(e,t,r){const i=jr(t,r),n={key:i,format:"jwk",type:"pkcs1",padding:Rr.constants.RSA_PKCS1_PADDING};return new Uint8Array(Rr.publicEncrypt(n,e))}(e,t,r):async function(e,t,r){if(t=pr(t),e=pr(Br(e,vr(t))),r=pr(r),e>=t)throw Error("Message size cannot exceed modulus size");return Ar(dr(e,r,t),"be",vr(t))}(e,t,r)},generate:async function(e,t){if(t=BigInt(t),F.getWebCrypto()){const r={name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:Ar(t),hash:{name:"SHA-1"}},i=await Fr.generateKey(r,!0,["sign","verify"]);return Or(await Fr.exportKey("jwk",i.privateKey),t)}if(F.getNodeCrypto()){const r={modulusLength:e,publicExponent:wr(t),publicKeyEncoding:{type:"pkcs1",format:"jwk"},privateKeyEncoding:{type:"pkcs1",format:"jwk"}},i=await new Promise(((e,t)=>{Rr.generateKeyPair("rsa",r,((r,i,n)=>{r?t(r):e(n)}))}));return Or(i,t)}let r,i,n;do{i=Dr(e-(e>>1),t,40),r=Dr(e>>1,t,40),n=r*i}while(kr(n)!==e);const s=(r-Nr)*(i-Nr);return i<r&&([r,i]=[i,r]),{n:Ar(n),e:Ar(t),d:Ar(mr(t,s)),p:Ar(r),q:Ar(i),u:Ar(mr(r,i))}},sign:async function(e,t,r,i,n,s,a,o,c){if(be.getHashByteLength(e)>=r.length)throw Error("Digest size cannot exceed key modulus size");if(t&&!F.isStream(t))if(F.getWebCrypto())try{return await async function(e,t,r,i,n,s,a,o){const c=await zr(r,i,n,s,a,o),u={name:"RSASSA-PKCS1-v1_5",hash:{name:e}},h=await Fr.importKey("jwk",c,u,!1,["sign"]);return new Uint8Array(await Fr.sign("RSASSA-PKCS1-v1_5",h,t))}(T.read(T.webHash,e),t,r,i,n,s,a,o)}catch(e){F.printDebugError(e)}else if(F.getNodeCrypto())return async function(e,t,r,i,n,s,a,o){const c=Rr.createSign(T.read(T.hash,e));c.write(t),c.end();const u=await zr(r,i,n,s,a,o);return new Uint8Array(c.sign({key:u,format:"jwk",type:"pkcs1"}))}(e,t,r,i,n,s,a,o);return async function(e,t,r,i){t=pr(t);const n=pr(Mr(e,i,vr(t)));return r=pr(r),Ar(dr(n,r,t),"be",vr(t))}(e,r,n,c)},validateParams:async function(e,t,r,i,n,s){if(e=pr(e),(i=pr(i))*(n=pr(n))!==e)return!1;const a=BigInt(2);if(gr(i*(s=pr(s)),n)!==BigInt(1))return!1;t=pr(t),r=pr(r);const o=Sr(a,a<<BigInt(Math.floor(kr(e)/3))),c=o*r*t;return!(gr(c,i-Nr)!==o||gr(c,n-Nr)!==o)},verify:async function(e,t,r,i,n,s){if(t&&!F.isStream(t))if(F.getWebCrypto())try{return await async function(e,t,r,i,n){const s=jr(i,n),a=await Fr.importKey("jwk",s,{name:"RSASSA-PKCS1-v1_5",hash:{name:e}},!1,["verify"]);return Fr.verify("RSASSA-PKCS1-v1_5",a,r,t)}(T.read(T.webHash,e),t,r,i,n)}catch(e){F.printDebugError(e)}else if(F.getNodeCrypto())return async function(e,t,r,i,n){const s=jr(i,n),a={key:s,format:"jwk",type:"pkcs1"},o=Rr.createVerify(T.read(T.hash,e));o.write(t),o.end();try{return o.verify(a,r)}catch(e){return!1}}(e,t,r,i,n);return async function(e,t,r,i,n){if(r=pr(r),t=pr(t),i=pr(i),t>=r)throw Error("Signature size cannot exceed modulus size");const s=Ar(dr(t,i,r),"be",vr(r)),a=Mr(e,n,vr(r));return F.equalsUint8Array(s,a)}(e,r,i,n,s)}});const _r=BigInt(1);var Gr=/*#__PURE__*/Object.freeze({__proto__:null,decrypt:async function(e,t,r,i,n){return e=pr(e),t=pr(t),r=pr(r),Tr(Ar(gr(mr(dr(e,i=pr(i),r),r)*t,r),"be",vr(r)),n)},encrypt:async function(e,t,r,i){t=pr(t),r=pr(r),i=pr(i);const n=pr(Br(e,vr(t))),s=Sr(_r,t-_r);return{c1:Ar(dr(r,s,t)),c2:Ar(gr(dr(i,s,t)*n,t))}},validateParams:async function(e,t,r,i){if(e=pr(e),t=pr(t),r=pr(r),t<=_r||t>=e)return!1;const n=BigInt(kr(e));if(n<BigInt(1023))return!1;if(dr(t,e-_r,e)!==_r)return!1;let s=t,a=BigInt(1);const o=BigInt(2),c=o<<BigInt(17);for(;a<c;){if(s=gr(s*t,e),s===_r)return!1;a++}i=pr(i);const u=Sr(o<<n-_r,o<<n);return r===dr(t,(e-_r)*u+i,e)}});const qr="object"==typeof e&&"crypto"in e?e.crypto:void 0,Vr={};var Wr=function(e){var t,r=new Float64Array(16);if(e)for(t=0;t<e.length;t++)r[t]=e[t];return r},$r=function(){throw Error("no PRNG")},Qr=new Uint8Array(32);Qr[0]=9;var Xr=Wr(),Yr=Wr([1]),Zr=Wr([56129,1]),Jr=Wr([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),ei=Wr([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),ti=Wr([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),ri=Wr([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),ii=Wr([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function ni(e,t,r,i){e[t]=r>>24&255,e[t+1]=r>>16&255,e[t+2]=r>>8&255,e[t+3]=255&r,e[t+4]=i>>24&255,e[t+5]=i>>16&255,e[t+6]=i>>8&255,e[t+7]=255&i}function si(e,t,r,i){return function(e,t,r,i,n){var s,a=0;for(s=0;s<n;s++)a|=e[t+s]^r[i+s];return(1&a-1>>>8)-1}(e,t,r,i,32)}function ai(e,t){var r;for(r=0;r<16;r++)e[r]=0|t[r]}function oi(e){var t,r,i=1;for(t=0;t<16;t++)r=e[t]+i+65535,i=Math.floor(r/65536),e[t]=r-65536*i;e[0]+=i-1+37*(i-1)}function ci(e,t,r){for(var i,n=~(r-1),s=0;s<16;s++)i=n&(e[s]^t[s]),e[s]^=i,t[s]^=i}function ui(e,t){var r,i,n,s=Wr(),a=Wr();for(r=0;r<16;r++)a[r]=t[r];for(oi(a),oi(a),oi(a),i=0;i<2;i++){for(s[0]=a[0]-65517,r=1;r<15;r++)s[r]=a[r]-65535-(s[r-1]>>16&1),s[r-1]&=65535;s[15]=a[15]-32767-(s[14]>>16&1),n=s[15]>>16&1,s[14]&=65535,ci(a,s,1-n)}for(r=0;r<16;r++)e[2*r]=255&a[r],e[2*r+1]=a[r]>>8}function hi(e,t){var r=new Uint8Array(32),i=new Uint8Array(32);return ui(r,e),ui(i,t),si(r,0,i,0)}function yi(e){var t=new Uint8Array(32);return ui(t,e),1&t[0]}function li(e,t){var r;for(r=0;r<16;r++)e[r]=t[2*r]+(t[2*r+1]<<8);e[15]&=32767}function pi(e,t,r){for(var i=0;i<16;i++)e[i]=t[i]+r[i]}function gi(e,t,r){for(var i=0;i<16;i++)e[i]=t[i]-r[i]}function di(e,t,r){var i,n,s=0,a=0,o=0,c=0,u=0,h=0,y=0,l=0,p=0,g=0,d=0,f=0,m=0,w=0,b=0,k=0,v=0,A=0,K=0,E=0,S=0,P=0,U=0,D=0,x=0,I=0,C=0,B=0,T=0,M=0,L=0,F=r[0],R=r[1],N=r[2],z=r[3],j=r[4],O=r[5],H=r[6],_=r[7],G=r[8],q=r[9],V=r[10],W=r[11],$=r[12],Q=r[13],X=r[14],Y=r[15];s+=(i=t[0])*F,a+=i*R,o+=i*N,c+=i*z,u+=i*j,h+=i*O,y+=i*H,l+=i*_,p+=i*G,g+=i*q,d+=i*V,f+=i*W,m+=i*$,w+=i*Q,b+=i*X,k+=i*Y,a+=(i=t[1])*F,o+=i*R,c+=i*N,u+=i*z,h+=i*j,y+=i*O,l+=i*H,p+=i*_,g+=i*G,d+=i*q,f+=i*V,m+=i*W,w+=i*$,b+=i*Q,k+=i*X,v+=i*Y,o+=(i=t[2])*F,c+=i*R,u+=i*N,h+=i*z,y+=i*j,l+=i*O,p+=i*H,g+=i*_,d+=i*G,f+=i*q,m+=i*V,w+=i*W,b+=i*$,k+=i*Q,v+=i*X,A+=i*Y,c+=(i=t[3])*F,u+=i*R,h+=i*N,y+=i*z,l+=i*j,p+=i*O,g+=i*H,d+=i*_,f+=i*G,m+=i*q,w+=i*V,b+=i*W,k+=i*$,v+=i*Q,A+=i*X,K+=i*Y,u+=(i=t[4])*F,h+=i*R,y+=i*N,l+=i*z,p+=i*j,g+=i*O,d+=i*H,f+=i*_,m+=i*G,w+=i*q,b+=i*V,k+=i*W,v+=i*$,A+=i*Q,K+=i*X,E+=i*Y,h+=(i=t[5])*F,y+=i*R,l+=i*N,p+=i*z,g+=i*j,d+=i*O,f+=i*H,m+=i*_,w+=i*G,b+=i*q,k+=i*V,v+=i*W,A+=i*$,K+=i*Q,E+=i*X,S+=i*Y,y+=(i=t[6])*F,l+=i*R,p+=i*N,g+=i*z,d+=i*j,f+=i*O,m+=i*H,w+=i*_,b+=i*G,k+=i*q,v+=i*V,A+=i*W,K+=i*$,E+=i*Q,S+=i*X,P+=i*Y,l+=(i=t[7])*F,p+=i*R,g+=i*N,d+=i*z,f+=i*j,m+=i*O,w+=i*H,b+=i*_,k+=i*G,v+=i*q,A+=i*V,K+=i*W,E+=i*$,S+=i*Q,P+=i*X,U+=i*Y,p+=(i=t[8])*F,g+=i*R,d+=i*N,f+=i*z,m+=i*j,w+=i*O,b+=i*H,k+=i*_,v+=i*G,A+=i*q,K+=i*V,E+=i*W,S+=i*$,P+=i*Q,U+=i*X,D+=i*Y,g+=(i=t[9])*F,d+=i*R,f+=i*N,m+=i*z,w+=i*j,b+=i*O,k+=i*H,v+=i*_,A+=i*G,K+=i*q,E+=i*V,S+=i*W,P+=i*$,U+=i*Q,D+=i*X,x+=i*Y,d+=(i=t[10])*F,f+=i*R,m+=i*N,w+=i*z,b+=i*j,k+=i*O,v+=i*H,A+=i*_,K+=i*G,E+=i*q,S+=i*V,P+=i*W,U+=i*$,D+=i*Q,x+=i*X,I+=i*Y,f+=(i=t[11])*F,m+=i*R,w+=i*N,b+=i*z,k+=i*j,v+=i*O,A+=i*H,K+=i*_,E+=i*G,S+=i*q,P+=i*V,U+=i*W,D+=i*$,x+=i*Q,I+=i*X,C+=i*Y,m+=(i=t[12])*F,w+=i*R,b+=i*N,k+=i*z,v+=i*j,A+=i*O,K+=i*H,E+=i*_,S+=i*G,P+=i*q,U+=i*V,D+=i*W,x+=i*$,I+=i*Q,C+=i*X,B+=i*Y,w+=(i=t[13])*F,b+=i*R,k+=i*N,v+=i*z,A+=i*j,K+=i*O,E+=i*H,S+=i*_,P+=i*G,U+=i*q,D+=i*V,x+=i*W,I+=i*$,C+=i*Q,B+=i*X,T+=i*Y,b+=(i=t[14])*F,k+=i*R,v+=i*N,A+=i*z,K+=i*j,E+=i*O,S+=i*H,P+=i*_,U+=i*G,D+=i*q,x+=i*V,I+=i*W,C+=i*$,B+=i*Q,T+=i*X,M+=i*Y,k+=(i=t[15])*F,a+=38*(A+=i*N),o+=38*(K+=i*z),c+=38*(E+=i*j),u+=38*(S+=i*O),h+=38*(P+=i*H),y+=38*(U+=i*_),l+=38*(D+=i*G),p+=38*(x+=i*q),g+=38*(I+=i*V),d+=38*(C+=i*W),f+=38*(B+=i*$),m+=38*(T+=i*Q),w+=38*(M+=i*X),b+=38*(L+=i*Y),s=(i=(s+=38*(v+=i*R))+(n=1)+65535)-65536*(n=Math.floor(i/65536)),a=(i=a+n+65535)-65536*(n=Math.floor(i/65536)),o=(i=o+n+65535)-65536*(n=Math.floor(i/65536)),c=(i=c+n+65535)-65536*(n=Math.floor(i/65536)),u=(i=u+n+65535)-65536*(n=Math.floor(i/65536)),h=(i=h+n+65535)-65536*(n=Math.floor(i/65536)),y=(i=y+n+65535)-65536*(n=Math.floor(i/65536)),l=(i=l+n+65535)-65536*(n=Math.floor(i/65536)),p=(i=p+n+65535)-65536*(n=Math.floor(i/65536)),g=(i=g+n+65535)-65536*(n=Math.floor(i/65536)),d=(i=d+n+65535)-65536*(n=Math.floor(i/65536)),f=(i=f+n+65535)-65536*(n=Math.floor(i/65536)),m=(i=m+n+65535)-65536*(n=Math.floor(i/65536)),w=(i=w+n+65535)-65536*(n=Math.floor(i/65536)),b=(i=b+n+65535)-65536*(n=Math.floor(i/65536)),k=(i=k+n+65535)-65536*(n=Math.floor(i/65536)),s=(i=(s+=n-1+37*(n-1))+(n=1)+65535)-65536*(n=Math.floor(i/65536)),a=(i=a+n+65535)-65536*(n=Math.floor(i/65536)),o=(i=o+n+65535)-65536*(n=Math.floor(i/65536)),c=(i=c+n+65535)-65536*(n=Math.floor(i/65536)),u=(i=u+n+65535)-65536*(n=Math.floor(i/65536)),h=(i=h+n+65535)-65536*(n=Math.floor(i/65536)),y=(i=y+n+65535)-65536*(n=Math.floor(i/65536)),l=(i=l+n+65535)-65536*(n=Math.floor(i/65536)),p=(i=p+n+65535)-65536*(n=Math.floor(i/65536)),g=(i=g+n+65535)-65536*(n=Math.floor(i/65536)),d=(i=d+n+65535)-65536*(n=Math.floor(i/65536)),f=(i=f+n+65535)-65536*(n=Math.floor(i/65536)),m=(i=m+n+65535)-65536*(n=Math.floor(i/65536)),w=(i=w+n+65535)-65536*(n=Math.floor(i/65536)),b=(i=b+n+65535)-65536*(n=Math.floor(i/65536)),k=(i=k+n+65535)-65536*(n=Math.floor(i/65536)),s+=n-1+37*(n-1),e[0]=s,e[1]=a,e[2]=o,e[3]=c,e[4]=u,e[5]=h,e[6]=y,e[7]=l,e[8]=p,e[9]=g,e[10]=d,e[11]=f,e[12]=m,e[13]=w,e[14]=b,e[15]=k}function fi(e,t){di(e,t,t)}function mi(e,t){var r,i=Wr();for(r=0;r<16;r++)i[r]=t[r];for(r=253;r>=0;r--)fi(i,i),2!==r&&4!==r&&di(i,i,t);for(r=0;r<16;r++)e[r]=i[r]}function wi(e,t,r){var i,n,s=new Uint8Array(32),a=new Float64Array(80),o=Wr(),c=Wr(),u=Wr(),h=Wr(),y=Wr(),l=Wr();for(n=0;n<31;n++)s[n]=t[n];for(s[31]=127&t[31]|64,s[0]&=248,li(a,r),n=0;n<16;n++)c[n]=a[n],h[n]=o[n]=u[n]=0;for(o[0]=h[0]=1,n=254;n>=0;--n)ci(o,c,i=s[n>>>3]>>>(7&n)&1),ci(u,h,i),pi(y,o,u),gi(o,o,u),pi(u,c,h),gi(c,c,h),fi(h,y),fi(l,o),di(o,u,o),di(u,c,y),pi(y,o,u),gi(o,o,u),fi(c,o),gi(u,h,l),di(o,u,Zr),pi(o,o,h),di(u,u,o),di(o,h,l),di(h,c,a),fi(c,y),ci(o,c,i),ci(u,h,i);for(n=0;n<16;n++)a[n+16]=o[n],a[n+32]=u[n],a[n+48]=c[n],a[n+64]=h[n];var p=a.subarray(32),g=a.subarray(16);return mi(p,p),di(g,g,p),ui(e,g),0}function bi(e,t){return wi(e,t,Qr)}var ki=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function vi(e,t,r,i){for(var n,s,a,o,c,u,h,y,l,p,g,d,f,m,w,b,k,v,A,K,E,S,P,U,D,x,I=new Int32Array(16),C=new Int32Array(16),B=e[0],T=e[1],M=e[2],L=e[3],F=e[4],R=e[5],N=e[6],z=e[7],j=t[0],O=t[1],H=t[2],_=t[3],G=t[4],q=t[5],V=t[6],W=t[7],$=0;i>=128;){for(A=0;A<16;A++)K=8*A+$,I[A]=r[K+0]<<24|r[K+1]<<16|r[K+2]<<8|r[K+3],C[A]=r[K+4]<<24|r[K+5]<<16|r[K+6]<<8|r[K+7];for(A=0;A<80;A++)if(n=B,s=T,a=M,o=L,c=F,u=R,h=N,z,l=j,p=O,g=H,d=_,f=G,m=q,w=V,W,P=65535&(S=W),U=S>>>16,D=65535&(E=z),x=E>>>16,P+=65535&(S=(G>>>14|F<<18)^(G>>>18|F<<14)^(F>>>9|G<<23)),U+=S>>>16,D+=65535&(E=(F>>>14|G<<18)^(F>>>18|G<<14)^(G>>>9|F<<23)),x+=E>>>16,P+=65535&(S=G&q^~G&V),U+=S>>>16,D+=65535&(E=F&R^~F&N),x+=E>>>16,E=ki[2*A],P+=65535&(S=ki[2*A+1]),U+=S>>>16,D+=65535&E,x+=E>>>16,E=I[A%16],U+=(S=C[A%16])>>>16,D+=65535&E,x+=E>>>16,D+=(U+=(P+=65535&S)>>>16)>>>16,P=65535&(S=v=65535&P|U<<16),U=S>>>16,D=65535&(E=k=65535&D|(x+=D>>>16)<<16),x=E>>>16,P+=65535&(S=(j>>>28|B<<4)^(B>>>2|j<<30)^(B>>>7|j<<25)),U+=S>>>16,D+=65535&(E=(B>>>28|j<<4)^(j>>>2|B<<30)^(j>>>7|B<<25)),x+=E>>>16,U+=(S=j&O^j&H^O&H)>>>16,D+=65535&(E=B&T^B&M^T&M),x+=E>>>16,y=65535&(D+=(U+=(P+=65535&S)>>>16)>>>16)|(x+=D>>>16)<<16,b=65535&P|U<<16,P=65535&(S=d),U=S>>>16,D=65535&(E=o),x=E>>>16,U+=(S=v)>>>16,D+=65535&(E=k),x+=E>>>16,T=n,M=s,L=a,F=o=65535&(D+=(U+=(P+=65535&S)>>>16)>>>16)|(x+=D>>>16)<<16,R=c,N=u,z=h,B=y,O=l,H=p,_=g,G=d=65535&P|U<<16,q=f,V=m,W=w,j=b,A%16==15)for(K=0;K<16;K++)E=I[K],P=65535&(S=C[K]),U=S>>>16,D=65535&E,x=E>>>16,E=I[(K+9)%16],P+=65535&(S=C[(K+9)%16]),U+=S>>>16,D+=65535&E,x+=E>>>16,k=I[(K+1)%16],P+=65535&(S=((v=C[(K+1)%16])>>>1|k<<31)^(v>>>8|k<<24)^(v>>>7|k<<25)),U+=S>>>16,D+=65535&(E=(k>>>1|v<<31)^(k>>>8|v<<24)^k>>>7),x+=E>>>16,k=I[(K+14)%16],U+=(S=((v=C[(K+14)%16])>>>19|k<<13)^(k>>>29|v<<3)^(v>>>6|k<<26))>>>16,D+=65535&(E=(k>>>19|v<<13)^(v>>>29|k<<3)^k>>>6),x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,I[K]=65535&D|x<<16,C[K]=65535&P|U<<16;P=65535&(S=j),U=S>>>16,D=65535&(E=B),x=E>>>16,E=e[0],U+=(S=t[0])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[0]=B=65535&D|x<<16,t[0]=j=65535&P|U<<16,P=65535&(S=O),U=S>>>16,D=65535&(E=T),x=E>>>16,E=e[1],U+=(S=t[1])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[1]=T=65535&D|x<<16,t[1]=O=65535&P|U<<16,P=65535&(S=H),U=S>>>16,D=65535&(E=M),x=E>>>16,E=e[2],U+=(S=t[2])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[2]=M=65535&D|x<<16,t[2]=H=65535&P|U<<16,P=65535&(S=_),U=S>>>16,D=65535&(E=L),x=E>>>16,E=e[3],U+=(S=t[3])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[3]=L=65535&D|x<<16,t[3]=_=65535&P|U<<16,P=65535&(S=G),U=S>>>16,D=65535&(E=F),x=E>>>16,E=e[4],U+=(S=t[4])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[4]=F=65535&D|x<<16,t[4]=G=65535&P|U<<16,P=65535&(S=q),U=S>>>16,D=65535&(E=R),x=E>>>16,E=e[5],U+=(S=t[5])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[5]=R=65535&D|x<<16,t[5]=q=65535&P|U<<16,P=65535&(S=V),U=S>>>16,D=65535&(E=N),x=E>>>16,E=e[6],U+=(S=t[6])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[6]=N=65535&D|x<<16,t[6]=V=65535&P|U<<16,P=65535&(S=W),U=S>>>16,D=65535&(E=z),x=E>>>16,E=e[7],U+=(S=t[7])>>>16,D+=65535&E,x+=E>>>16,x+=(D+=(U+=(P+=65535&S)>>>16)>>>16)>>>16,e[7]=z=65535&D|x<<16,t[7]=W=65535&P|U<<16,$+=128,i-=128}return i}function Ai(e,t,r){var i,n=new Int32Array(8),s=new Int32Array(8),a=new Uint8Array(256),o=r;for(n[0]=1779033703,n[1]=3144134277,n[2]=1013904242,n[3]=2773480762,n[4]=1359893119,n[5]=2600822924,n[6]=528734635,n[7]=1541459225,s[0]=4089235720,s[1]=2227873595,s[2]=4271175723,s[3]=1595750129,s[4]=2917565137,s[5]=725511199,s[6]=4215389547,s[7]=327033209,vi(n,s,t,r),r%=128,i=0;i<r;i++)a[i]=t[o-r+i];for(a[r]=128,a[(r=256-128*(r<112?1:0))-9]=0,ni(a,r-8,o/536870912|0,o<<3),vi(n,s,a,r),i=0;i<8;i++)ni(e,8*i,n[i],s[i]);return 0}function Ki(e,t){var r=Wr(),i=Wr(),n=Wr(),s=Wr(),a=Wr(),o=Wr(),c=Wr(),u=Wr(),h=Wr();gi(r,e[1],e[0]),gi(h,t[1],t[0]),di(r,r,h),pi(i,e[0],e[1]),pi(h,t[0],t[1]),di(i,i,h),di(n,e[3],t[3]),di(n,n,ei),di(s,e[2],t[2]),pi(s,s,s),gi(a,i,r),gi(o,s,n),pi(c,s,n),pi(u,i,r),di(e[0],a,o),di(e[1],u,c),di(e[2],c,o),di(e[3],a,u)}function Ei(e,t,r){var i;for(i=0;i<4;i++)ci(e[i],t[i],r)}function Si(e,t){var r=Wr(),i=Wr(),n=Wr();mi(n,t[2]),di(r,t[0],n),di(i,t[1],n),ui(e,i),e[31]^=yi(r)<<7}function Pi(e,t,r){var i,n;for(ai(e[0],Xr),ai(e[1],Yr),ai(e[2],Yr),ai(e[3],Xr),n=255;n>=0;--n)Ei(e,t,i=r[n/8|0]>>(7&n)&1),Ki(t,e),Ki(e,e),Ei(e,t,i)}function Ui(e,t){var r=[Wr(),Wr(),Wr(),Wr()];ai(r[0],ti),ai(r[1],ri),ai(r[2],Yr),di(r[3],ti,ri),Pi(e,r,t)}function Di(e,t,r){var i,n=new Uint8Array(64),s=[Wr(),Wr(),Wr(),Wr()];for(r||$r(t,32),Ai(n,t,32),n[0]&=248,n[31]&=127,n[31]|=64,Ui(s,n),Si(e,s),i=0;i<32;i++)t[i+32]=e[i];return 0}var xi=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function Ii(e,t){var r,i,n,s;for(i=63;i>=32;--i){for(r=0,n=i-32,s=i-12;n<s;++n)t[n]+=r-16*t[i]*xi[n-(i-32)],r=Math.floor((t[n]+128)/256),t[n]-=256*r;t[n]+=r,t[i]=0}for(r=0,n=0;n<32;n++)t[n]+=r-(t[31]>>4)*xi[n],r=t[n]>>8,t[n]&=255;for(n=0;n<32;n++)t[n]-=r*xi[n];for(i=0;i<32;i++)t[i+1]+=t[i]>>8,e[i]=255&t[i]}function Ci(e){var t,r=new Float64Array(64);for(t=0;t<64;t++)r[t]=e[t];for(t=0;t<64;t++)e[t]=0;Ii(e,r)}function Bi(e,t){var r=Wr(),i=Wr(),n=Wr(),s=Wr(),a=Wr(),o=Wr(),c=Wr();return ai(e[2],Yr),li(e[1],t),fi(n,e[1]),di(s,n,Jr),gi(n,n,e[2]),pi(s,e[2],s),fi(a,s),fi(o,a),di(c,o,a),di(r,c,n),di(r,r,s),function(e,t){var r,i=Wr();for(r=0;r<16;r++)i[r]=t[r];for(r=250;r>=0;r--)fi(i,i),1!==r&&di(i,i,t);for(r=0;r<16;r++)e[r]=i[r]}(r,r),di(r,r,n),di(r,r,s),di(r,r,s),di(e[0],r,s),fi(i,e[0]),di(i,i,s),hi(i,n)&&di(e[0],e[0],ii),fi(i,e[0]),di(i,i,s),hi(i,n)?-1:(yi(e[0])===t[31]>>7&&gi(e[0],Xr,e[0]),di(e[3],e[0],e[1]),0)}var Ti=64;function Mi(){for(var e=0;e<arguments.length;e++)if(!(arguments[e]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}Vr.scalarMult=function(e,t){if(Mi(e,t),32!==e.length)throw Error("bad n size");if(32!==t.length)throw Error("bad p size");var r=new Uint8Array(32);return wi(r,e,t),r},Vr.box={},Vr.box.keyPair=function(){var e=new Uint8Array(32),t=new Uint8Array(32);return function(e,t){$r(t,32),bi(e,t)}(e,t),{publicKey:e,secretKey:t}},Vr.box.keyPair.fromSecretKey=function(e){if(Mi(e),32!==e.length)throw Error("bad secret key size");var t=new Uint8Array(32);return bi(t,e),{publicKey:t,secretKey:new Uint8Array(e)}},Vr.sign=function(e,t){if(Mi(e,t),64!==t.length)throw Error("bad secret key size");var r=new Uint8Array(Ti+e.length);return function(e,t,r,i){var n,s,a=new Uint8Array(64),o=new Uint8Array(64),c=new Uint8Array(64),u=new Float64Array(64),h=[Wr(),Wr(),Wr(),Wr()];Ai(a,i,32),a[0]&=248,a[31]&=127,a[31]|=64;var y=r+64;for(n=0;n<r;n++)e[64+n]=t[n];for(n=0;n<32;n++)e[32+n]=a[32+n];for(Ai(c,e.subarray(32),r+32),Ci(c),Ui(h,c),Si(e,h),n=32;n<64;n++)e[n]=i[n];for(Ai(o,e,r+64),Ci(o),n=0;n<64;n++)u[n]=0;for(n=0;n<32;n++)u[n]=c[n];for(n=0;n<32;n++)for(s=0;s<32;s++)u[n+s]+=o[n]*a[s];Ii(e.subarray(32),u)}(r,e,e.length,t),r},Vr.sign.detached=function(e,t){for(var r=Vr.sign(e,t),i=new Uint8Array(Ti),n=0;n<i.length;n++)i[n]=r[n];return i},Vr.sign.detached.verify=function(e,t,r){if(Mi(e,t,r),t.length!==Ti)throw Error("bad signature size");if(32!==r.length)throw Error("bad public key size");var i,n=new Uint8Array(Ti+e.length),s=new Uint8Array(Ti+e.length);for(i=0;i<Ti;i++)n[i]=t[i];for(i=0;i<e.length;i++)n[i+Ti]=e[i];return function(e,t,r,i){var n,s=new Uint8Array(32),a=new Uint8Array(64),o=[Wr(),Wr(),Wr(),Wr()],c=[Wr(),Wr(),Wr(),Wr()];if(r<64)return-1;if(Bi(c,i))return-1;for(n=0;n<r;n++)e[n]=t[n];for(n=0;n<32;n++)e[n+32]=i[n];if(Ai(a,e,r),Ci(a),Pi(o,c,a),Ui(c,t.subarray(32)),Ki(o,c),Si(s,o),r-=64,si(t,0,s,0)){for(n=0;n<r;n++)e[n]=0;return-1}for(n=0;n<r;n++)e[n]=t[n+64];return r}(s,n,n.length,r)>=0},Vr.sign.keyPair=function(){var e=new Uint8Array(32),t=new Uint8Array(64);return Di(e,t),{publicKey:e,secretKey:t}},Vr.sign.keyPair.fromSecretKey=function(e){if(Mi(e),64!==e.length)throw Error("bad secret key size");for(var t=new Uint8Array(32),r=0;r<t.length;r++)t[r]=e[32+r];return{publicKey:t,secretKey:new Uint8Array(e)}},Vr.sign.keyPair.fromSeed=function(e){if(Mi(e),32!==e.length)throw Error("bad seed size");for(var t=new Uint8Array(32),r=new Uint8Array(64),i=0;i<32;i++)r[i]=e[i];return Di(t,r,!0),{publicKey:t,secretKey:r}},Vr.setPRNG=function(e){$r=e},function(){if(qr&&qr.getRandomValues){Vr.setPRNG((function(e,t){var r,i=new Uint8Array(t);for(r=0;r<t;r+=65536)qr.getRandomValues(i.subarray(r,r+Math.min(t-r,65536)));for(r=0;r<t;r++)e[r]=i[r];!function(e){for(var t=0;t<e.length;t++)e[t]=0}(i)}))}}();const Li={"2a8648ce3d030107":T.curve.nistP256,"2b81040022":T.curve.nistP384,"2b81040023":T.curve.nistP521,"2b8104000a":T.curve.secp256k1,"2b06010401da470f01":T.curve.ed25519Legacy,"2b060104019755010501":T.curve.curve25519Legacy,"2b2403030208010107":T.curve.brainpoolP256r1,"2b240303020801010b":T.curve.brainpoolP384r1,"2b240303020801010d":T.curve.brainpoolP512r1};class Fi{constructor(e){if(e instanceof Fi)this.oid=e.oid;else if(F.isArray(e)||F.isUint8Array(e)){if(6===(e=new Uint8Array(e))[0]){if(e[1]!==e.length-2)throw Error("Length mismatch in DER encoded oid");e=e.subarray(2)}this.oid=e}else this.oid=""}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.oid=e.subarray(1,1+t),1+this.oid.length}throw Error("Invalid oid")}write(){return F.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return F.uint8ArrayToHex(this.oid)}getName(){const e=Li[this.toHex()];if(!e)throw Error("Unknown curve object identifier.");return e}}function Ri(e){let t,r=0;const i=e[0];return i<192?([r]=e,t=1):i<255?(r=(e[0]-192<<8)+e[1]+192,t=2):255===i&&(r=F.readNumber(e.subarray(1,5)),t=5),{len:r,offset:t}}function Ni(e){return e<192?new Uint8Array([e]):e>191&&e<8384?new Uint8Array([192+(e-192>>8),e-192&255]):F.concatUint8Array([new Uint8Array([255]),F.writeNumber(e,4)])}function zi(e){if(e<0||e>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+e])}function ji(e){return new Uint8Array([192|e])}function Oi(e,t){return F.concatUint8Array([ji(e),Ni(t)])}function Hi(e){return[T.packet.literalData,T.packet.compressedData,T.packet.symmetricallyEncryptedData,T.packet.symEncryptedIntegrityProtectedData,T.packet.aeadEncryptedData].includes(e)}async function _i(e,t){const r=I(e);let i,n;try{const a=await r.peekBytes(2);if(!a||a.length<2||!(128&a[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const o=await r.readByte();let c,u,h=-1,y=-1;y=0,64&o&&(y=1),y?h=63&o:(h=(63&o)>>2,u=3&o);const l=Hi(h);let p,g=null;if(l){if("array"===F.isStream(e)){const e=new s;i=C(e),g=e}else{const e=new TransformStream;i=C(e.writable),g=e.readable}n=t({tag:h,packet:g})}else g=[];do{if(y){const e=await r.readByte();if(p=!1,e<192)c=e;else if(e>=192&&e<224)c=(e-192<<8)+await r.readByte()+192;else if(e>223&&e<255){if(c=1<<(31&e),p=!0,!l)throw new TypeError("This packet type does not support partial lengths.")}else c=await r.readByte()<<24|await r.readByte()<<16|await r.readByte()<<8|await r.readByte()}else switch(u){case 0:c=await r.readByte();break;case 1:c=await r.readByte()<<8|await r.readByte();break;case 2:c=await r.readByte()<<24|await r.readByte()<<16|await r.readByte()<<8|await r.readByte();break;default:c=1/0}if(c>0){let e=0;for(;;){i&&await i.ready;const{done:t,value:n}=await r.read();if(t){if(c===1/0)break;throw Error("Unexpected end of packet")}const s=c===1/0?n:n.subarray(0,c-e);if(i?await i.write(s):g.push(s),e+=n.length,e>=c){r.unshift(n.subarray(c-e+n.length));break}}}}while(p);const d=await r.peekBytes(l?1/0:2);return i?(await i.ready,await i.close()):(g=F.concatUint8Array(g),await t({tag:h,packet:g})),!d||!d.length}catch(e){if(i)return await i.abort(e),!0;throw e}finally{i&&await n,r.releaseLock()}}class Gi extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,Gi),this.name="UnsupportedError"}}class qi extends Gi{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,Gi),this.name="UnknownPacketError"}}class Vi{constructor(e,t){this.tag=e,this.rawContent=t}write(){return this.rawContent}}async function Wi(e){switch(e){case T.publicKey.ed25519:try{const e=F.getWebCrypto(),t=await e.generateKey("Ed25519",!0,["sign","verify"]),r=await e.exportKey("jwk",t.privateKey),i=await e.exportKey("jwk",t.publicKey);return{A:new Uint8Array(H(i.x)),seed:H(r.d)}}catch(t){if("NotSupportedError"!==t.name&&"OperationError"!==t.name)throw t;const r=Er(Xi(e)),{publicKey:i}=Vr.sign.keyPair.fromSeed(r);return{A:i,seed:r}}case T.publicKey.ed448:{const e=await F.getNobleCurve(T.publicKey.ed448),t=e.utils.randomPrivateKey();return{A:e.getPublicKey(t),seed:t}}default:throw Error("Unsupported EdDSA algorithm")}}async function $i(e,t,r,i,n,s){if(be.getHashByteLength(t)<be.getHashByteLength(Yi(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case T.publicKey.ed25519:try{const t=F.getWebCrypto(),r=Ji(e,i,n),a=await t.importKey("jwk",r,"Ed25519",!1,["sign"]);return{RS:new Uint8Array(await t.sign("Ed25519",a,s))}}catch(e){if("NotSupportedError"!==e.name)throw e;const t=F.concatUint8Array([n,i]);return{RS:Vr.sign.detached(s,t)}}case T.publicKey.ed448:return{RS:(await F.getNobleCurve(T.publicKey.ed448)).sign(s,n)};default:throw Error("Unsupported EdDSA algorithm")}}async function Qi(e,t,{RS:r},i,n,s){if(be.getHashByteLength(t)<be.getHashByteLength(Yi(e)))throw Error("Hash algorithm too weak for EdDSA.");switch(e){case T.publicKey.ed25519:try{const t=F.getWebCrypto(),i=Zi(e,n),a=await t.importKey("jwk",i,"Ed25519",!1,["verify"]);return await t.verify("Ed25519",a,r,s)}catch(e){if("NotSupportedError"!==e.name)throw e;return Vr.sign.detached.verify(s,r,n)}case T.publicKey.ed448:return(await F.getNobleCurve(T.publicKey.ed448)).verify(r,s,n);default:throw Error("Unsupported EdDSA algorithm")}}function Xi(e){switch(e){case T.publicKey.ed25519:return 32;case T.publicKey.ed448:return 57;default:throw Error("Unsupported EdDSA algorithm")}}function Yi(e){switch(e){case T.publicKey.ed25519:return T.hash.sha256;case T.publicKey.ed448:return T.hash.sha512;default:throw Error("Unknown EdDSA algo")}}const Zi=(e,t)=>{if(e===T.publicKey.ed25519){return{kty:"OKP",crv:"Ed25519",x:_(t),ext:!0}}throw Error("Unsupported EdDSA algorithm")},Ji=(e,t,r)=>{if(e===T.publicKey.ed25519){const i=Zi(e,t);return i.d=_(r),i}throw Error("Unsupported EdDSA algorithm")};var en=/*#__PURE__*/Object.freeze({__proto__:null,generate:Wi,getPayloadSize:Xi,getPreferredHashAlgo:Yi,sign:$i,validateParams:async function(e,t,r){switch(e){case T.publicKey.ed25519:{const{publicKey:e}=Vr.sign.keyPair.fromSeed(r);return F.equalsUint8Array(t,e)}case T.publicKey.ed448:{const e=(await F.getNobleCurve(T.publicKey.ed448)).getPublicKey(r);return F.equalsUint8Array(t,e)}default:return!1}},verify:Qi});const tn=F.getWebCrypto();async function rn(e,t,r){const{keySize:i}=re(e);if(!F.isAES(e)||t.length!==i)throw Error("Unexpected algorithm or key size");try{const e=await tn.importKey("raw",t,{name:"AES-KW"},!1,["wrapKey"]),i=await tn.importKey("raw",r,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),n=await tn.wrapKey("raw",i,e,{name:"AES-KW"});return new Uint8Array(n)}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;F.printDebugError("Browser did not support operation: "+e.message)}return kt(t).encrypt(r)}async function nn(e,t,r){const{keySize:i}=re(e);if(!F.isAES(e)||t.length!==i)throw Error("Unexpected algorithm or key size");let n;try{n=await tn.importKey("raw",t,{name:"AES-KW"},!1,["unwrapKey"])}catch(e){if("NotSupportedError"!==e.name&&(24!==t.length||"OperationError"!==e.name))throw e;return F.printDebugError("Browser did not support operation: "+e.message),kt(t).decrypt(r)}try{const e=await tn.unwrapKey("raw",r,n,{name:"AES-KW"},{name:"HMAC",hash:"SHA-256"},!0,["sign"]);return new Uint8Array(await tn.exportKey("raw",e))}catch(e){if("OperationError"===e.name)throw Error("Key Data Integrity failed");throw e}}var sn=/*#__PURE__*/Object.freeze({__proto__:null,unwrap:nn,wrap:rn});const an=F.getWebCrypto();async function on(e,t,r,i,n){const s=T.read(T.webHash,e);if(!s)throw Error("Hash algo not supported with HKDF");const a=await an.importKey("raw",t,"HKDF",!1,["deriveBits"]),o=await an.deriveBits({name:"HKDF",hash:s,salt:r,info:i},a,8*n);return new Uint8Array(o)}const cn={x25519:F.encodeUTF8("OpenPGP X25519"),x448:F.encodeUTF8("OpenPGP X448")};async function un(e){switch(e){case T.publicKey.x25519:{const e=Er(32),{publicKey:t}=Vr.box.keyPair.fromSecretKey(e);return{A:t,k:e}}case T.publicKey.x448:{const e=await F.getNobleCurve(T.publicKey.x448),t=e.utils.randomPrivateKey();return{A:e.getPublicKey(t),k:t}}default:throw Error("Unsupported ECDH algorithm")}}function hn(e){switch(e){case T.publicKey.x25519:return 32;case T.publicKey.x448:return 56;default:throw Error("Unsupported ECDH algorithm")}}async function yn(e,t){switch(e){case T.publicKey.x25519:{const r=Er(hn(e)),i=Vr.scalarMult(r,t);pn(i);const{publicKey:n}=Vr.box.keyPair.fromSecretKey(r);return{ephemeralPublicKey:n,sharedSecret:i}}case T.publicKey.x448:{const e=await F.getNobleCurve(T.publicKey.x448),r=e.utils.randomPrivateKey(),i=e.getSharedSecret(r,t);pn(i);return{ephemeralPublicKey:e.getPublicKey(r),sharedSecret:i}}default:throw Error("Unsupported ECDH algorithm")}}async function ln(e,t,r,i){switch(e){case T.publicKey.x25519:{const e=Vr.scalarMult(i,t);return pn(e),e}case T.publicKey.x448:{const e=(await F.getNobleCurve(T.publicKey.x448)).getSharedSecret(i,t);return pn(e),e}default:throw Error("Unsupported ECDH algorithm")}}function pn(e){let t=0;for(let r=0;r<e.length;r++)t|=e[r];if(0===t)throw Error("Unexpected low order point")}var gn=/*#__PURE__*/Object.freeze({__proto__:null,decrypt:async function(e,t,r,i,n){const s=await ln(e,t,i,n),a=F.concatUint8Array([t,i,s]);switch(e){case T.publicKey.x25519:{const e=T.symmetric.aes128,{keySize:t}=re(e);return nn(e,await on(T.hash.sha256,a,new Uint8Array,cn.x25519,t),r)}case T.publicKey.x448:{const e=T.symmetric.aes256,{keySize:t}=re(T.symmetric.aes256);return nn(e,await on(T.hash.sha512,a,new Uint8Array,cn.x448,t),r)}default:throw Error("Unsupported ECDH algorithm")}},encrypt:async function(e,t,r){const{ephemeralPublicKey:i,sharedSecret:n}=await yn(e,r),s=F.concatUint8Array([i,r,n]);switch(e){case T.publicKey.x25519:{const e=T.symmetric.aes128,{keySize:r}=re(e),n=await on(T.hash.sha256,s,new Uint8Array,cn.x25519,r);return{ephemeralPublicKey:i,wrappedKey:await rn(e,n,t)}}case T.publicKey.x448:{const e=T.symmetric.aes256,{keySize:r}=re(T.symmetric.aes256),n=await on(T.hash.sha512,s,new Uint8Array,cn.x448,r);return{ephemeralPublicKey:i,wrappedKey:await rn(e,n,t)}}default:throw Error("Unsupported ECDH algorithm")}},generate:un,generateEphemeralEncryptionMaterial:yn,getPayloadSize:hn,recomputeSharedSecret:ln,validateParams:async function(e,t,r){switch(e){case T.publicKey.x25519:{const{publicKey:e}=Vr.box.keyPair.fromSecretKey(r);return F.equalsUint8Array(t,e)}case T.publicKey.x448:{const e=(await F.getNobleCurve(T.publicKey.x448)).getPublicKey(r);return F.equalsUint8Array(t,e)}default:return!1}}});const dn=F.getWebCrypto(),fn=F.getNodeCrypto(),mn={[T.curve.nistP256]:"P-256",[T.curve.nistP384]:"P-384",[T.curve.nistP521]:"P-521"},wn=fn?fn.getCurves():[],bn=fn?{[T.curve.secp256k1]:wn.includes("secp256k1")?"secp256k1":void 0,[T.curve.nistP256]:wn.includes("prime256v1")?"prime256v1":void 0,[T.curve.nistP384]:wn.includes("secp384r1")?"secp384r1":void 0,[T.curve.nistP521]:wn.includes("secp521r1")?"secp521r1":void 0,[T.curve.ed25519Legacy]:wn.includes("ED25519")?"ED25519":void 0,[T.curve.curve25519Legacy]:wn.includes("X25519")?"X25519":void 0,[T.curve.brainpoolP256r1]:wn.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,[T.curve.brainpoolP384r1]:wn.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,[T.curve.brainpoolP512r1]:wn.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},kn={[T.curve.nistP256]:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:T.publicKey.ecdsa,hash:T.hash.sha256,cipher:T.symmetric.aes128,node:bn[T.curve.nistP256],web:mn[T.curve.nistP256],payloadSize:32,sharedSize:256,wireFormatLeadingByte:4},[T.curve.nistP384]:{oid:[6,5,43,129,4,0,34],keyType:T.publicKey.ecdsa,hash:T.hash.sha384,cipher:T.symmetric.aes192,node:bn[T.curve.nistP384],web:mn[T.curve.nistP384],payloadSize:48,sharedSize:384,wireFormatLeadingByte:4},[T.curve.nistP521]:{oid:[6,5,43,129,4,0,35],keyType:T.publicKey.ecdsa,hash:T.hash.sha512,cipher:T.symmetric.aes256,node:bn[T.curve.nistP521],web:mn[T.curve.nistP521],payloadSize:66,sharedSize:528,wireFormatLeadingByte:4},[T.curve.secp256k1]:{oid:[6,5,43,129,4,0,10],keyType:T.publicKey.ecdsa,hash:T.hash.sha256,cipher:T.symmetric.aes128,node:bn[T.curve.secp256k1],payloadSize:32,wireFormatLeadingByte:4},[T.curve.ed25519Legacy]:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:T.publicKey.eddsaLegacy,hash:T.hash.sha512,node:!1,payloadSize:32,wireFormatLeadingByte:64},[T.curve.curve25519Legacy]:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:T.publicKey.ecdh,hash:T.hash.sha256,cipher:T.symmetric.aes128,node:!1,payloadSize:32,wireFormatLeadingByte:64},[T.curve.brainpoolP256r1]:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:T.publicKey.ecdsa,hash:T.hash.sha256,cipher:T.symmetric.aes128,node:bn[T.curve.brainpoolP256r1],payloadSize:32,wireFormatLeadingByte:4},[T.curve.brainpoolP384r1]:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:T.publicKey.ecdsa,hash:T.hash.sha384,cipher:T.symmetric.aes192,node:bn[T.curve.brainpoolP384r1],payloadSize:48,wireFormatLeadingByte:4},[T.curve.brainpoolP512r1]:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:T.publicKey.ecdsa,hash:T.hash.sha512,cipher:T.symmetric.aes256,node:bn[T.curve.brainpoolP512r1],payloadSize:64,wireFormatLeadingByte:4}};class vn{constructor(e){try{this.name=e instanceof Fi?e.getName():T.write(T.curve,e)}catch(e){throw new Gi("Unknown curve")}const t=kn[this.name];this.keyType=t.keyType,this.oid=t.oid,this.hash=t.hash,this.cipher=t.cipher,this.node=t.node,this.web=t.web,this.payloadSize=t.payloadSize,this.sharedSize=t.sharedSize,this.wireFormatLeadingByte=t.wireFormatLeadingByte,this.web&&F.getWebCrypto()?this.type="web":this.node&&F.getNodeCrypto()?this.type="node":this.name===T.curve.curve25519Legacy?this.type="curve25519Legacy":this.name===T.curve.ed25519Legacy&&(this.type="ed25519Legacy")}async genKeyPair(){switch(this.type){case"web":try{return await async function(e,t){const r=await dn.generateKey({name:"ECDSA",namedCurve:mn[e]},!0,["sign","verify"]),i=await dn.exportKey("jwk",r.privateKey),n=await dn.exportKey("jwk",r.publicKey);return{publicKey:Sn(n,t),privateKey:H(i.d)}}(this.name,this.wireFormatLeadingByte)}catch(e){return F.printDebugError("Browser did not support generating ec key "+e.message),En(this.name)}case"node":return async function(e){const t=fn.createECDH(bn[e]);return await t.generateKeys(),{publicKey:new Uint8Array(t.getPublicKey()),privateKey:new Uint8Array(t.getPrivateKey())}}(this.name);case"curve25519Legacy":{const{k:e,A:t}=await un(T.publicKey.x25519),r=e.slice().reverse();r[0]=127&r[0]|64,r[31]&=248;return{publicKey:F.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),t]),privateKey:r}}case"ed25519Legacy":{const{seed:e,A:t}=await Wi(T.publicKey.ed25519);return{publicKey:F.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),t]),privateKey:e}}default:return En(this.name)}}}async function An(e,t,r,i){const n={[T.curve.nistP256]:!0,[T.curve.nistP384]:!0,[T.curve.nistP521]:!0,[T.curve.secp256k1]:!0,[T.curve.curve25519Legacy]:e===T.publicKey.ecdh,[T.curve.brainpoolP256r1]:!0,[T.curve.brainpoolP384r1]:!0,[T.curve.brainpoolP512r1]:!0},s=t.getName();if(!n[s])return!1;if(s===T.curve.curve25519Legacy){i=i.slice().reverse();const{publicKey:e}=Vr.box.keyPair.fromSecretKey(i);r=new Uint8Array(r);const t=new Uint8Array([64,...e]);return!!F.equalsUint8Array(t,r)}const a=(await F.getNobleCurve(T.publicKey.ecdsa,s)).getPublicKey(i,!1);return!!F.equalsUint8Array(a,r)}function Kn(e,t){const{payloadSize:r,wireFormatLeadingByte:i,name:n}=e,s=n===T.curve.curve25519Legacy||n===T.curve.ed25519Legacy?r:2*r;if(t[0]!==i||t.length!==s+1)throw Error("Invalid point encoding")}async function En(e){const t=await F.getNobleCurve(T.publicKey.ecdsa,e),r=t.utils.randomPrivateKey();return{publicKey:t.getPublicKey(r,!1),privateKey:r}}function Sn(e,t){const r=H(e.x),i=H(e.y),n=new Uint8Array(r.length+i.length+1);return n[0]=t,n.set(r,1),n.set(i,r.length+1),n}function Pn(e,t,r){const i=e,n=r.slice(1,i+1),s=r.slice(i+1,2*i+1);return{kty:"EC",crv:t,x:_(n),y:_(s),ext:!0}}function Un(e,t,r,i){const n=Pn(e,t,r);return n.d=_(i),n}const Dn=F.getWebCrypto(),xn=F.getNodeCrypto();async function In(e,t,r,i,n,s){const a=new vn(e);if(Kn(a,i),r&&!F.isStream(r)){const e={publicKey:i,privateKey:n};switch(a.type){case"web":try{return await async function(e,t,r,i){const n=e.payloadSize,s=Un(e.payloadSize,mn[e.name],i.publicKey,i.privateKey),a=await Dn.importKey("jwk",s,{name:"ECDSA",namedCurve:mn[e.name],hash:{name:T.read(T.webHash,e.hash)}},!1,["sign"]),o=new Uint8Array(await Dn.sign({name:"ECDSA",namedCurve:mn[e.name],hash:{name:T.read(T.webHash,t)}},a,r));return{r:o.slice(0,n),s:o.slice(n,n<<1)}}(a,t,r,e)}catch(e){if("nistP521"!==a.name&&("DataError"===e.name||"OperationError"===e.name))throw e;F.printDebugError("Browser did not support signing: "+e.message)}break;case"node":return async function(e,t,r,i){const n=F.nodeRequire("eckey-utils"),s=F.getNodeBuffer(),{privateKey:a}=n.generateDer({curveName:bn[e.name],privateKey:s.from(i)}),o=xn.createSign(T.read(T.hash,t));o.write(r),o.end();const c=new Uint8Array(o.sign({key:a,format:"der",type:"sec1",dsaEncoding:"ieee-p1363"})),u=e.payloadSize;return{r:c.subarray(0,u),s:c.subarray(u,u<<1)}}(a,t,r,n)}}const o=(await F.getNobleCurve(T.publicKey.ecdsa,a.name)).sign(s,n,{lowS:!1});return{r:Ar(o.r,"be",a.payloadSize),s:Ar(o.s,"be",a.payloadSize)}}async function Cn(e,t,r,i,n,s){const a=new vn(e);Kn(a,n);const o=async()=>0===s[0]&&Bn(a,r,s.subarray(1),n);if(i&&!F.isStream(i))switch(a.type){case"web":try{const e=await async function(e,t,{r,s:i},n,s){const a=Pn(e.payloadSize,mn[e.name],s),o=await Dn.importKey("jwk",a,{name:"ECDSA",namedCurve:mn[e.name],hash:{name:T.read(T.webHash,e.hash)}},!1,["verify"]),c=F.concatUint8Array([r,i]).buffer;return Dn.verify({name:"ECDSA",namedCurve:mn[e.name],hash:{name:T.read(T.webHash,t)}},o,c,n)}(a,t,r,i,n);return e||o()}catch(e){if("nistP521"!==a.name&&("DataError"===e.name||"OperationError"===e.name))throw e;F.printDebugError("Browser did not support verifying: "+e.message)}break;case"node":{const e=await async function(e,t,{r,s:i},n,s){const a=F.nodeRequire("eckey-utils"),o=F.getNodeBuffer(),{publicKey:c}=a.generateDer({curveName:bn[e.name],publicKey:o.from(s)}),u=xn.createVerify(T.read(T.hash,t));u.write(n),u.end();const h=F.concatUint8Array([r,i]);try{return u.verify({key:c,format:"der",type:"spki",dsaEncoding:"ieee-p1363"},h)}catch(e){return!1}}(a,t,r,i,n);return e||o()}}return await Bn(a,r,s,n)||o()}async function Bn(e,t,r,i){return(await F.getNobleCurve(T.publicKey.ecdsa,e.name)).verify(F.concatUint8Array([t.r,t.s]),r,i,{lowS:!1})}var Tn=/*#__PURE__*/Object.freeze({__proto__:null,sign:In,validateParams:async function(e,t,r){const i=new vn(e);if(i.keyType!==T.publicKey.ecdsa)return!1;switch(i.type){case"web":case"node":{const i=Er(8),n=T.hash.sha256,s=await be.digest(n,i);try{const a=await In(e,n,i,t,r,s);return await Cn(e,n,a,i,t,s)}catch(e){return!1}}default:return An(T.publicKey.ecdsa,e,t,r)}},verify:Cn});var Mn=/*#__PURE__*/Object.freeze({__proto__:null,sign:async function(e,t,r,i,n,s){if(Kn(new vn(e),i),be.getHashByteLength(t)<be.getHashByteLength(T.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const{RS:a}=await $i(T.publicKey.ed25519,t,0,i.subarray(1),n,s);return{r:a.subarray(0,32),s:a.subarray(32)}},validateParams:async function(e,t,r){if(e.getName()!==T.curve.ed25519Legacy)return!1;const{publicKey:i}=Vr.sign.keyPair.fromSeed(r),n=new Uint8Array([64,...i]);return F.equalsUint8Array(t,n)},verify:async function(e,t,{r,s:i},n,s,a){if(Kn(new vn(e),s),be.getHashByteLength(t)<be.getHashByteLength(T.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const o=F.concatUint8Array([r,i]);return Qi(T.publicKey.ed25519,t,{RS:o},0,s.subarray(1),a)}});function Ln(e){const t=8-e.length%8,r=new Uint8Array(e.length+t).fill(t);return r.set(e),r}function Fn(e){const t=e.length;if(t>0){const r=e[t-1];if(r>=1){const i=e.subarray(t-r),n=new Uint8Array(r).fill(r);if(F.equalsUint8Array(i,n))return e.subarray(0,t-r)}}throw Error("Invalid padding")}var Rn=/*#__PURE__*/Object.freeze({__proto__:null,decode:Fn,encode:Ln});const Nn=F.getWebCrypto(),zn=F.getNodeCrypto();function jn(e,t,r,i){return F.concatUint8Array([t.write(),new Uint8Array([e]),r.write(),F.stringToUint8Array("Anonymous Sender    "),i])}async function On(e,t,r,i,n=!1,s=!1){let a;if(n){for(a=0;a<t.length&&0===t[a];a++);t=t.subarray(a)}if(s){for(a=t.length-1;a>=0&&0===t[a];a--);t=t.subarray(0,a+1)}return(await be.digest(e,F.concatUint8Array([new Uint8Array([0,0,0,1]),t,i]))).subarray(0,r)}async function Hn(e,t){switch(e.type){case"curve25519Legacy":{const{sharedSecret:r,ephemeralPublicKey:i}=await yn(T.publicKey.x25519,t.subarray(1));return{publicKey:F.concatUint8Array([new Uint8Array([e.wireFormatLeadingByte]),i]),sharedKey:r}}case"web":if(e.web&&F.getWebCrypto())try{return await async function(e,t){const r=Pn(e.payloadSize,e.web,t);let i=Nn.generateKey({name:"ECDH",namedCurve:e.web},!0,["deriveKey","deriveBits"]),n=Nn.importKey("jwk",r,{name:"ECDH",namedCurve:e.web},!1,[]);[i,n]=await Promise.all([i,n]);let s=Nn.deriveBits({name:"ECDH",namedCurve:e.web,public:n},i.privateKey,e.sharedSize),a=Nn.exportKey("jwk",i.publicKey);[s,a]=await Promise.all([s,a]);const o=new Uint8Array(s),c=new Uint8Array(Sn(a,e.wireFormatLeadingByte));return{publicKey:c,sharedKey:o}}(e,t)}catch(r){return F.printDebugError(r),qn(e,t)}break;case"node":return async function(e,t){const r=zn.createECDH(e.node);r.generateKeys();const i=new Uint8Array(r.computeSecret(t)),n=new Uint8Array(r.getPublicKey());return{publicKey:n,sharedKey:i}}(e,t);default:return qn(e,t)}}async function _n(e,t,r,i){if(i.length!==e.payloadSize){const t=new Uint8Array(e.payloadSize);t.set(i,e.payloadSize-i.length),i=t}switch(e.type){case"curve25519Legacy":{const e=i.slice().reverse();return{secretKey:e,sharedKey:await ln(T.publicKey.x25519,t.subarray(1),r.subarray(1),e)}}case"web":if(e.web&&F.getWebCrypto())try{return await async function(e,t,r,i){const n=Un(e.payloadSize,e.web,r,i);let s=Nn.importKey("jwk",n,{name:"ECDH",namedCurve:e.web},!0,["deriveKey","deriveBits"]);const a=Pn(e.payloadSize,e.web,t);let o=Nn.importKey("jwk",a,{name:"ECDH",namedCurve:e.web},!0,[]);[s,o]=await Promise.all([s,o]);let c=Nn.deriveBits({name:"ECDH",namedCurve:e.web,public:o},s,e.sharedSize),u=Nn.exportKey("jwk",s);[c,u]=await Promise.all([c,u]);const h=new Uint8Array(c);return{secretKey:H(u.d),sharedKey:h}}(e,t,r,i)}catch(r){return F.printDebugError(r),Gn(e,t,i)}break;case"node":return async function(e,t,r){const i=zn.createECDH(e.node);i.setPrivateKey(r);const n=new Uint8Array(i.computeSecret(t));return{secretKey:new Uint8Array(i.getPrivateKey()),sharedKey:n}}(e,t,i);default:return Gn(e,t,i)}}async function Gn(e,t,r){return{secretKey:r,sharedKey:(await F.getNobleCurve(T.publicKey.ecdh,e.name)).getSharedSecret(r,t).subarray(1)}}async function qn(e,t){const r=await F.getNobleCurve(T.publicKey.ecdh,e.name),{publicKey:i,privateKey:n}=await e.genKeyPair();return{publicKey:i,sharedKey:r.getSharedSecret(n,t).subarray(1)}}var Vn=/*#__PURE__*/Object.freeze({__proto__:null,decrypt:async function(e,t,r,i,n,s,a){const o=new vn(e);Kn(o,n),Kn(o,r);const{sharedKey:c}=await _n(o,r,n,s),u=jn(T.publicKey.ecdh,e,t,a),{keySize:h}=re(t.cipher);let y;for(let e=0;e<3;e++)try{const r=await On(t.hash,c,h,u,1===e,2===e);return Fn(await nn(t.cipher,r,i))}catch(e){y=e}throw y},encrypt:async function(e,t,r,i,n){const s=Ln(r),a=new vn(e);Kn(a,i);const{publicKey:o,sharedKey:c}=await Hn(a,i),u=jn(T.publicKey.ecdh,e,t,n),{keySize:h}=re(t.cipher),y=await On(t.hash,c,h,u);return{publicKey:o,wrappedKey:await rn(t.cipher,y,s)}},validateParams:async function(e,t,r){return An(T.publicKey.ecdh,e,t,r)}}),Wn=/*#__PURE__*/Object.freeze({__proto__:null,CurveWithOID:vn,ecdh:Vn,ecdhX:gn,ecdsa:Tn,eddsa:en,eddsaLegacy:Mn,generate:async function(e){const t=new vn(e),{oid:r,hash:i,cipher:n}=t,s=await t.genKeyPair();return{oid:r,Q:s.publicKey,secret:F.leftPad(s.privateKey,t.payloadSize),hash:i,cipher:n}},getPreferredHashAlgo:function(e){return kn[e.getName()].hash}});const $n=BigInt(0),Qn=BigInt(1);var Xn=/*#__PURE__*/Object.freeze({__proto__:null,sign:async function(e,t,r,i,n,s){const a=BigInt(0);let o,c,u,h;i=pr(i),n=pr(n),r=pr(r),s=pr(s),r=gr(r,i),s=gr(s,n);const y=gr(pr(t.subarray(0,vr(n))),n);for(;;){if(o=Sr(Qn,n),c=gr(dr(r,o,i),n),c===a)continue;const e=gr(s*c,n);if(h=gr(y+e,n),u=gr(mr(o,n)*h,n),u!==a)break}return{r:Ar(c,"be",vr(i)),s:Ar(u,"be",vr(i))}},validateParams:async function(e,t,r,i,n){if(e=pr(e),t=pr(t),r=pr(r),i=pr(i),r<=Qn||r>=e)return!1;if(gr(e-Qn,t)!==$n)return!1;if(dr(r,t,e)!==Qn)return!1;const s=BigInt(kr(t));if(s<BigInt(150)||!xr(t,null,32))return!1;n=pr(n);const a=BigInt(2);return i===dr(r,t*Sr(a<<s-Qn,a<<s)+n,e)},verify:async function(e,t,r,i,n,s,a,o){if(t=pr(t),r=pr(r),s=pr(s),a=pr(a),n=pr(n),o=pr(o),t<=$n||t>=a||r<=$n||r>=a)return F.printDebug("invalid DSA Signature"),!1;const c=gr(pr(i.subarray(0,vr(a))),a),u=mr(r,a);if(u===$n)return F.printDebug("invalid DSA Signature"),!1;n=gr(n,s),o=gr(o,s);const h=gr(c*u,a),y=gr(t*u,a);return gr(gr(dr(n,h,s)*dr(o,y,s),s),a)===t}}),Yn={rsa:Hr,elgamal:Gr,elliptic:Wn,dsa:Xn};var Zn=/*#__PURE__*/Object.freeze({__proto__:null,parseSignatureParams:function(e,t){let r=0;switch(e){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:case T.publicKey.rsaSign:{const e=F.readMPI(t.subarray(r));return r+=e.length+2,{read:r,signatureParams:{s:e}}}case T.publicKey.dsa:case T.publicKey.ecdsa:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=F.readMPI(t.subarray(r));return r+=i.length+2,{read:r,signatureParams:{r:e,s:i}}}case T.publicKey.eddsaLegacy:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=F.readMPI(t.subarray(r));return r+=i.length+2,{read:r,signatureParams:{r:e,s:i}}}case T.publicKey.ed25519:case T.publicKey.ed448:{const i=2*Yn.elliptic.eddsa.getPayloadSize(e),n=F.readExactSubarray(t,r,r+i);return r+=n.length,{read:r,signatureParams:{RS:n}}}default:throw new Gi("Unknown signature algorithm.")}},sign:async function(e,t,r,i,n,s){if(!r||!i)throw Error("Missing key parameters");switch(e){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:case T.publicKey.rsaSign:{const{n:e,e:a}=r,{d:o,p:c,q:u,u:h}=i;return{s:await Yn.rsa.sign(t,n,e,a,o,c,u,h,s)}}case T.publicKey.dsa:{const{g:e,p:n,q:a}=r,{x:o}=i;return Yn.dsa.sign(t,s,e,n,a,o)}case T.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case T.publicKey.ecdsa:{const{oid:e,Q:a}=r,{d:o}=i;return Yn.elliptic.ecdsa.sign(e,t,n,a,o,s)}case T.publicKey.eddsaLegacy:{const{oid:e,Q:a}=r,{seed:o}=i;return Yn.elliptic.eddsaLegacy.sign(e,t,n,a,o,s)}case T.publicKey.ed25519:case T.publicKey.ed448:{const{A:a}=r,{seed:o}=i;return Yn.elliptic.eddsa.sign(e,t,n,a,o,s)}default:throw Error("Unknown signature algorithm.")}},verify:async function(e,t,r,i,n,s){switch(e){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:case T.publicKey.rsaSign:{const{n:e,e:a}=i,o=F.leftPad(r.s,e.length);return Yn.rsa.verify(t,n,o,e,a,s)}case T.publicKey.dsa:{const{g:e,p:n,q:a,y:o}=i,{r:c,s:u}=r;return Yn.dsa.verify(t,c,u,s,e,n,a,o)}case T.publicKey.ecdsa:{const{oid:e,Q:a}=i,o=new Yn.elliptic.CurveWithOID(e).payloadSize,c=F.leftPad(r.r,o),u=F.leftPad(r.s,o);return Yn.elliptic.ecdsa.verify(e,t,{r:c,s:u},n,a,s)}case T.publicKey.eddsaLegacy:{const{oid:e,Q:a}=i,o=new Yn.elliptic.CurveWithOID(e).payloadSize,c=F.leftPad(r.r,o),u=F.leftPad(r.s,o);return Yn.elliptic.eddsaLegacy.verify(e,t,{r:c,s:u},n,a,s)}case T.publicKey.ed25519:case T.publicKey.ed448:{const{A:a}=i;return Yn.elliptic.eddsa.verify(e,t,r,n,a,s)}default:throw Error("Unknown signature algorithm.")}}});class Jn{constructor(e){e&&(this.data=e)}read(e){if(e.length>=1){const t=e[0];if(e.length>=1+t)return this.data=e.subarray(1,1+t),1+this.data.length}throw Error("Invalid symmetric key")}write(){return F.concatUint8Array([new Uint8Array([this.data.length]),this.data])}}class es{constructor(e){if(e){const{hash:t,cipher:r}=e;this.hash=t,this.cipher=r}else this.hash=null,this.cipher=null}read(e){if(e.length<4||3!==e[0]||1!==e[1])throw new Gi("Cannot read KDFParams");return this.hash=e[2],this.cipher=e[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}class ts{static fromObject({wrappedKey:e,algorithm:t}){const r=new ts;return r.wrappedKey=e,r.algorithm=t,r}read(e){let t=0,r=e[t++];this.algorithm=r%2?e[t++]:null,r-=r%2,this.wrappedKey=F.readExactSubarray(e,t,t+r),t+=r}write(){return F.concatUint8Array([this.algorithm?new Uint8Array([this.wrappedKey.length+1,this.algorithm]):new Uint8Array([this.wrappedKey.length]),this.wrappedKey])}}function rs(e){try{e.getName()}catch(e){throw new Gi("Unknown curve OID")}}function is(e,t){switch(e){case T.publicKey.ecdsa:case T.publicKey.ecdh:case T.publicKey.eddsaLegacy:return new Yn.elliptic.CurveWithOID(t).payloadSize;case T.publicKey.ed25519:case T.publicKey.ed448:return Yn.elliptic.eddsa.getPayloadSize(e);case T.publicKey.x25519:case T.publicKey.x448:return Yn.elliptic.ecdhX.getPayloadSize(e);default:throw Error("Unknown elliptic algo")}}var ns=/*#__PURE__*/Object.freeze({__proto__:null,generateParams:function(e,t,r){switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:return Yn.rsa.generate(t,65537).then((({n:e,e:t,d:r,p:i,q:n,u:s})=>({privateParams:{d:r,p:i,q:n,u:s},publicParams:{n:e,e:t}})));case T.publicKey.ecdsa:return Yn.elliptic.generate(r).then((({oid:e,Q:t,secret:r})=>({privateParams:{d:r},publicParams:{oid:new Fi(e),Q:t}})));case T.publicKey.eddsaLegacy:return Yn.elliptic.generate(r).then((({oid:e,Q:t,secret:r})=>({privateParams:{seed:r},publicParams:{oid:new Fi(e),Q:t}})));case T.publicKey.ecdh:return Yn.elliptic.generate(r).then((({oid:e,Q:t,secret:r,hash:i,cipher:n})=>({privateParams:{d:r},publicParams:{oid:new Fi(e),Q:t,kdfParams:new es({hash:i,cipher:n})}})));case T.publicKey.ed25519:case T.publicKey.ed448:return Yn.elliptic.eddsa.generate(e).then((({A:e,seed:t})=>({privateParams:{seed:t},publicParams:{A:e}})));case T.publicKey.x25519:case T.publicKey.x448:return Yn.elliptic.ecdhX.generate(e).then((({A:e,k:t})=>({privateParams:{k:t},publicParams:{A:e}})));case T.publicKey.dsa:case T.publicKey.elgamal:throw Error("Unsupported algorithm for key generation.");default:throw Error("Unknown public key algorithm.")}},generateSessionKey:function(e){const{keySize:t}=re(e);return Er(t)},getAEADMode:function(e){const t=T.read(T.aead,e);return hr[t]},getCipherParams:re,getCurvePayloadSize:is,getPreferredCurveHashAlgo:function(e,t){switch(e){case T.publicKey.ecdsa:case T.publicKey.eddsaLegacy:return Yn.elliptic.getPreferredHashAlgo(t);case T.publicKey.ed25519:case T.publicKey.ed448:return Yn.elliptic.eddsa.getPreferredHashAlgo(e);default:throw Error("Unknown elliptic signing algo")}},getPrefixRandom:async function(e){const{blockSize:t}=re(e),r=await Er(t),i=new Uint8Array([r[r.length-2],r[r.length-1]]);return F.concat([r,i])},parseEncSessionKeyParams:function(e,t){let r=0;switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:return{c:F.readMPI(t.subarray(r))};case T.publicKey.elgamal:{const e=F.readMPI(t.subarray(r));r+=e.length+2;return{c1:e,c2:F.readMPI(t.subarray(r))}}case T.publicKey.ecdh:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=new Jn;return i.read(t.subarray(r)),{V:e,C:i}}case T.publicKey.x25519:case T.publicKey.x448:{const i=is(e),n=F.readExactSubarray(t,r,r+i);r+=n.length;const s=new ts;return s.read(t.subarray(r)),{ephemeralPublicKey:n,C:s}}default:throw new Gi("Unknown public key encryption algorithm.")}},parsePrivateKeyParams:function(e,t,r){let i=0;switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:{const e=F.readMPI(t.subarray(i));i+=e.length+2;const r=F.readMPI(t.subarray(i));i+=r.length+2;const n=F.readMPI(t.subarray(i));i+=n.length+2;const s=F.readMPI(t.subarray(i));return i+=s.length+2,{read:i,privateParams:{d:e,p:r,q:n,u:s}}}case T.publicKey.dsa:case T.publicKey.elgamal:{const e=F.readMPI(t.subarray(i));return i+=e.length+2,{read:i,privateParams:{x:e}}}case T.publicKey.ecdsa:case T.publicKey.ecdh:{const n=is(e,r.oid);let s=F.readMPI(t.subarray(i));return i+=s.length+2,s=F.leftPad(s,n),{read:i,privateParams:{d:s}}}case T.publicKey.eddsaLegacy:{const n=is(e,r.oid);if(r.oid.getName()!==T.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let s=F.readMPI(t.subarray(i));return i+=s.length+2,s=F.leftPad(s,n),{read:i,privateParams:{seed:s}}}case T.publicKey.ed25519:case T.publicKey.ed448:{const r=is(e),n=F.readExactSubarray(t,i,i+r);return i+=n.length,{read:i,privateParams:{seed:n}}}case T.publicKey.x25519:case T.publicKey.x448:{const r=is(e),n=F.readExactSubarray(t,i,i+r);return i+=n.length,{read:i,privateParams:{k:n}}}default:throw new Gi("Unknown public key encryption algorithm.")}},parsePublicKeyParams:function(e,t){let r=0;switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=F.readMPI(t.subarray(r));return r+=i.length+2,{read:r,publicParams:{n:e,e:i}}}case T.publicKey.dsa:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=F.readMPI(t.subarray(r));r+=i.length+2;const n=F.readMPI(t.subarray(r));r+=n.length+2;const s=F.readMPI(t.subarray(r));return r+=s.length+2,{read:r,publicParams:{p:e,q:i,g:n,y:s}}}case T.publicKey.elgamal:{const e=F.readMPI(t.subarray(r));r+=e.length+2;const i=F.readMPI(t.subarray(r));r+=i.length+2;const n=F.readMPI(t.subarray(r));return r+=n.length+2,{read:r,publicParams:{p:e,g:i,y:n}}}case T.publicKey.ecdsa:{const e=new Fi;r+=e.read(t),rs(e);const i=F.readMPI(t.subarray(r));return r+=i.length+2,{read:r,publicParams:{oid:e,Q:i}}}case T.publicKey.eddsaLegacy:{const e=new Fi;if(r+=e.read(t),rs(e),e.getName()!==T.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let i=F.readMPI(t.subarray(r));return r+=i.length+2,i=F.leftPad(i,33),{read:r,publicParams:{oid:e,Q:i}}}case T.publicKey.ecdh:{const e=new Fi;r+=e.read(t),rs(e);const i=F.readMPI(t.subarray(r));r+=i.length+2;const n=new es;return r+=n.read(t.subarray(r)),{read:r,publicParams:{oid:e,Q:i,kdfParams:n}}}case T.publicKey.ed25519:case T.publicKey.ed448:case T.publicKey.x25519:case T.publicKey.x448:{const i=F.readExactSubarray(t,r,r+is(e));return r+=i.length,{read:r,publicParams:{A:i}}}default:throw new Gi("Unknown public key encryption algorithm.")}},publicKeyDecrypt:async function(e,t,r,i,n,s){switch(e){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:{const{c:e}=i,{n,e:a}=t,{d:o,p:c,q:u,u:h}=r;return Yn.rsa.decrypt(e,n,a,o,c,u,h,s)}case T.publicKey.elgamal:{const{c1:e,c2:n}=i,a=t.p,o=r.x;return Yn.elgamal.decrypt(e,n,a,o,s)}case T.publicKey.ecdh:{const{oid:e,Q:s,kdfParams:a}=t,{d:o}=r,{V:c,C:u}=i;return Yn.elliptic.ecdh.decrypt(e,a,c,u.data,s,o,n)}case T.publicKey.x25519:case T.publicKey.x448:{const{A:n}=t,{k:s}=r,{ephemeralPublicKey:a,C:o}=i;if(null!==o.algorithm&&!F.isAES(o.algorithm))throw Error("AES session key expected");return Yn.elliptic.ecdhX.decrypt(e,a,o.wrappedKey,n,s)}default:throw Error("Unknown public key encryption algorithm.")}},publicKeyEncrypt:async function(e,t,r,i,n){switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:{const{n:e,e:t}=r;return{c:await Yn.rsa.encrypt(i,e,t)}}case T.publicKey.elgamal:{const{p:e,g:t,y:n}=r;return Yn.elgamal.encrypt(i,e,t,n)}case T.publicKey.ecdh:{const{oid:e,Q:t,kdfParams:s}=r,{publicKey:a,wrappedKey:o}=await Yn.elliptic.ecdh.encrypt(e,s,i,t,n);return{V:a,C:new Jn(o)}}case T.publicKey.x25519:case T.publicKey.x448:{if(t&&!F.isAES(t))throw Error("X25519 and X448 keys can only encrypt AES session keys");const{A:n}=r,{ephemeralPublicKey:s,wrappedKey:a}=await Yn.elliptic.ecdhX.encrypt(e,i,n);return{ephemeralPublicKey:s,C:ts.fromObject({algorithm:t,wrappedKey:a})}}default:return[]}},serializeParams:function(e,t){const r=new Set([T.publicKey.ed25519,T.publicKey.x25519,T.publicKey.ed448,T.publicKey.x448]),i=Object.keys(t).map((i=>{const n=t[i];return F.isUint8Array(n)?r.has(e)?n:F.uint8ArrayToMPI(n):n.write()}));return F.concatUint8Array(i)},validateParams:async function(e,t,r){if(!t||!r)throw Error("Missing key parameters");switch(e){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:{const{n:e,e:i}=t,{d:n,p:s,q:a,u:o}=r;return Yn.rsa.validateParams(e,i,n,s,a,o)}case T.publicKey.dsa:{const{p:e,q:i,g:n,y:s}=t,{x:a}=r;return Yn.dsa.validateParams(e,i,n,s,a)}case T.publicKey.elgamal:{const{p:e,g:i,y:n}=t,{x:s}=r;return Yn.elgamal.validateParams(e,i,n,s)}case T.publicKey.ecdsa:case T.publicKey.ecdh:{const i=Yn.elliptic[T.read(T.publicKey,e)],{oid:n,Q:s}=t,{d:a}=r;return i.validateParams(n,s,a)}case T.publicKey.eddsaLegacy:{const{Q:e,oid:i}=t,{seed:n}=r;return Yn.elliptic.eddsaLegacy.validateParams(i,e,n)}case T.publicKey.ed25519:case T.publicKey.ed448:{const{A:i}=t,{seed:n}=r;return Yn.elliptic.eddsa.validateParams(e,i,n)}case T.publicKey.x25519:case T.publicKey.x448:{const{A:i}=t,{k:n}=r;return Yn.elliptic.ecdhX.validateParams(e,i,n)}default:throw Error("Unknown public key algorithm.")}}});const ss={cipher:ie,hash:be,mode:hr,publicKey:Yn,signature:Zn,random:Pr,pkcs1:Lr,pkcs5:Rn,aesKW:sn};Object.assign(ss,ns);class as extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,as),this.name="Argon2OutOfMemoryError"}}let os,cs;class us{constructor(e=M){const{passes:t,parallelism:r,memoryExponent:i}=e.s2kArgon2Params;this.type="argon2",this.salt=null,this.t=t,this.p=r,this.encodedM=i}generateSalt(){this.salt=ss.random.getRandomBytes(16)}read(e){let t=0;return this.salt=e.subarray(t,t+16),t+=16,this.t=e[t++],this.p=e[t++],this.encodedM=e[t++],t}write(){const e=[new Uint8Array([T.write(T.s2k,this.type)]),this.salt,new Uint8Array([this.t,this.p,this.encodedM])];return F.concatUint8Array(e)}async produceKey(e,t){const r=2<<this.encodedM-1;try{os=os||(await import("./argon2id.min.mjs")).default,cs=cs||os();const i=await cs,n=i({version:19,type:2,password:F.encodeUTF8(e),salt:this.salt,tagLength:t,memorySize:r,parallelism:this.p,passes:this.t});return r>1048576&&(cs=os(),cs.catch((()=>{}))),n}catch(e){throw e.message&&(e.message.includes("Unable to grow instance memory")||e.message.includes("failed to grow memory")||e.message.includes("WebAssembly.Memory.grow")||e.message.includes("Out of memory"))?new as("Could not allocate required memory for Argon2"):e}}}class hs{constructor(e,t=M){this.algorithm=T.hash.sha256,this.type=T.read(T.s2k,e),this.c=t.s2kIterationCountByte,this.salt=null}generateSalt(){switch(this.type){case"salted":case"iterated":this.salt=ss.random.getRandomBytes(8)}}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(e){let t=0;switch(this.algorithm=e[t++],this.type){case"simple":break;case"salted":this.salt=e.subarray(t,t+8),t+=8;break;case"iterated":this.salt=e.subarray(t,t+8),t+=8,this.c=e[t++];break;case"gnu":if("GNU"!==F.uint8ArrayToString(e.subarray(t,t+3)))throw new Gi("Unknown s2k type.");t+=3;if(1001!==1e3+e[t++])throw new Gi("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new Gi("Unknown s2k type.")}return t}write(){if("gnu-dummy"===this.type)return new Uint8Array([101,0,...F.stringToUint8Array("GNU"),1]);const e=[new Uint8Array([T.write(T.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":e.push(this.salt);break;case"iterated":e.push(this.salt),e.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return F.concatUint8Array(e)}async produceKey(e,t){e=F.encodeUTF8(e);const r=[];let i=0,n=0;for(;i<t;){let t;switch(this.type){case"simple":t=F.concatUint8Array([new Uint8Array(n),e]);break;case"salted":t=F.concatUint8Array([new Uint8Array(n),this.salt,e]);break;case"iterated":{const r=F.concatUint8Array([this.salt,e]);let i=r.length;const s=Math.max(this.getCount(),i);t=new Uint8Array(n+s),t.set(r,n);for(let e=n+i;e<s;e+=i,i*=2)t.copyWithin(e,n,e);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const s=await ss.hash.digest(this.algorithm,t);r.push(s),i+=s.length,n++}return F.concatUint8Array(r).subarray(0,t)}}const ys=new Set([T.s2k.argon2,T.s2k.iterated]);function ls(e,t=M){switch(e){case T.s2k.argon2:return new us(t);case T.s2k.iterated:case T.s2k.gnu:case T.s2k.salted:case T.s2k.simple:return new hs(e,t);default:throw new Gi("Unsupported S2K type")}}function ps(e){const{s2kType:t}=e;if(!ys.has(t))throw Error("The provided `config.s2kType` value is not allowed");return ls(t,e)}var gs=Uint8Array,ds=Uint16Array,fs=Uint32Array,ms=new gs([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),ws=new gs([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),bs=new gs([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),ks=function(e,t){for(var r=new ds(31),i=0;i<31;++i)r[i]=t+=1<<e[i-1];var n=new fs(r[30]);for(i=1;i<30;++i)for(var s=r[i];s<r[i+1];++s)n[s]=s-r[i]<<5|i;return[r,n]},vs=ks(ms,2),As=vs[0],Ks=vs[1];As[28]=258,Ks[258]=28;for(var Es=ks(ws,0),Ss=Es[0],Ps=Es[1],Us=new ds(32768),Ds=0;Ds<32768;++Ds){var xs=(43690&Ds)>>>1|(21845&Ds)<<1;xs=(61680&(xs=(52428&xs)>>>2|(13107&xs)<<2))>>>4|(3855&xs)<<4,Us[Ds]=((65280&xs)>>>8|(255&xs)<<8)>>>1}var Is=function(e,t,r){for(var i=e.length,n=0,s=new ds(t);n<i;++n)e[n]&&++s[e[n]-1];var a,o=new ds(t);for(n=0;n<t;++n)o[n]=o[n-1]+s[n-1]<<1;if(r){a=new ds(1<<t);var c=15-t;for(n=0;n<i;++n)if(e[n])for(var u=n<<4|e[n],h=t-e[n],y=o[e[n]-1]++<<h,l=y|(1<<h)-1;y<=l;++y)a[Us[y]>>>c]=u}else for(a=new ds(i),n=0;n<i;++n)e[n]&&(a[n]=Us[o[e[n]-1]++]>>>15-e[n]);return a},Cs=new gs(288);for(Ds=0;Ds<144;++Ds)Cs[Ds]=8;for(Ds=144;Ds<256;++Ds)Cs[Ds]=9;for(Ds=256;Ds<280;++Ds)Cs[Ds]=7;for(Ds=280;Ds<288;++Ds)Cs[Ds]=8;var Bs=new gs(32);for(Ds=0;Ds<32;++Ds)Bs[Ds]=5;var Ts=/*#__PURE__*/Is(Cs,9,0),Ms=/*#__PURE__*/Is(Cs,9,1),Ls=/*#__PURE__*/Is(Bs,5,0),Fs=/*#__PURE__*/Is(Bs,5,1),Rs=function(e){for(var t=e[0],r=1;r<e.length;++r)e[r]>t&&(t=e[r]);return t},Ns=function(e,t,r){var i=t/8|0;return(e[i]|e[i+1]<<8)>>(7&t)&r},zs=function(e,t){var r=t/8|0;return(e[r]|e[r+1]<<8|e[r+2]<<16)>>(7&t)},js=function(e){return(e+7)/8|0},Os=function(e,t,r){(null==t||t<0)&&(t=0),(null==r||r>e.length)&&(r=e.length);var i=new(2==e.BYTES_PER_ELEMENT?ds:4==e.BYTES_PER_ELEMENT?fs:gs)(r-t);return i.set(e.subarray(t,r)),i},Hs=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],_s=function(e,t,r){var i=Error(t||Hs[e]);if(i.code=e,Error.captureStackTrace&&Error.captureStackTrace(i,_s),!r)throw i;return i},Gs=function(e,t,r){r<<=7&t;var i=t/8|0;e[i]|=r,e[i+1]|=r>>>8},qs=function(e,t,r){r<<=7&t;var i=t/8|0;e[i]|=r,e[i+1]|=r>>>8,e[i+2]|=r>>>16},Vs=function(e,t){for(var r=[],i=0;i<e.length;++i)e[i]&&r.push({s:i,f:e[i]});var n=r.length,s=r.slice();if(!n)return[Js,0];if(1==n){var a=new gs(r[0].s+1);return a[r[0].s]=1,[a,1]}r.sort((function(e,t){return e.f-t.f})),r.push({s:-1,f:25001});var o=r[0],c=r[1],u=0,h=1,y=2;for(r[0]={s:-1,f:o.f+c.f,l:o,r:c};h!=n-1;)o=r[r[u].f<r[y].f?u++:y++],c=r[u!=h&&r[u].f<r[y].f?u++:y++],r[h++]={s:-1,f:o.f+c.f,l:o,r:c};var l=s[0].s;for(i=1;i<n;++i)s[i].s>l&&(l=s[i].s);var p=new ds(l+1),g=Ws(r[h-1],p,0);if(g>t){i=0;var d=0,f=g-t,m=1<<f;for(s.sort((function(e,t){return p[t.s]-p[e.s]||e.f-t.f}));i<n;++i){var w=s[i].s;if(!(p[w]>t))break;d+=m-(1<<g-p[w]),p[w]=t}for(d>>>=f;d>0;){var b=s[i].s;p[b]<t?d-=1<<t-p[b]++-1:++i}for(;i>=0&&d;--i){var k=s[i].s;p[k]==t&&(--p[k],++d)}g=t}return[new gs(p),g]},Ws=function(e,t,r){return-1==e.s?Math.max(Ws(e.l,t,r+1),Ws(e.r,t,r+1)):t[e.s]=r},$s=function(e){for(var t=e.length;t&&!e[--t];);for(var r=new ds(++t),i=0,n=e[0],s=1,a=function(e){r[i++]=e},o=1;o<=t;++o)if(e[o]==n&&o!=t)++s;else{if(!n&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(n),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(n);s=1,n=e[o]}return[r.subarray(0,i),t]},Qs=function(e,t){for(var r=0,i=0;i<t.length;++i)r+=e[i]*t[i];return r},Xs=function(e,t,r){var i=r.length,n=js(t+2);e[n]=255&i,e[n+1]=i>>>8,e[n+2]=255^e[n],e[n+3]=255^e[n+1];for(var s=0;s<i;++s)e[n+s+4]=r[s];return 8*(n+4+i)},Ys=function(e,t,r,i,n,s,a,o,c,u,h){Gs(t,h++,r),++n[256];for(var y=Vs(n,15),l=y[0],p=y[1],g=Vs(s,15),d=g[0],f=g[1],m=$s(l),w=m[0],b=m[1],k=$s(d),v=k[0],A=k[1],K=new ds(19),E=0;E<w.length;++E)K[31&w[E]]++;for(E=0;E<v.length;++E)K[31&v[E]]++;for(var S=Vs(K,7),P=S[0],U=S[1],D=19;D>4&&!P[bs[D-1]];--D);var x,I,C,B,T=u+5<<3,M=Qs(n,Cs)+Qs(s,Bs)+a,L=Qs(n,l)+Qs(s,d)+a+14+3*D+Qs(K,P)+(2*K[16]+3*K[17]+7*K[18]);if(T<=M&&T<=L)return Xs(t,h,e.subarray(c,c+u));if(Gs(t,h,1+(L<M)),h+=2,L<M){x=Is(l,p,0),I=l,C=Is(d,f,0),B=d;var F=Is(P,U,0);Gs(t,h,b-257),Gs(t,h+5,A-1),Gs(t,h+10,D-4),h+=14;for(E=0;E<D;++E)Gs(t,h+3*E,P[bs[E]]);h+=3*D;for(var R=[w,v],N=0;N<2;++N){var z=R[N];for(E=0;E<z.length;++E){var j=31&z[E];Gs(t,h,F[j]),h+=P[j],j>15&&(Gs(t,h,z[E]>>>5&127),h+=z[E]>>>12)}}}else x=Ts,I=Cs,C=Ls,B=Bs;for(E=0;E<o;++E)if(i[E]>255){j=i[E]>>>18&31;qs(t,h,x[j+257]),h+=I[j+257],j>7&&(Gs(t,h,i[E]>>>23&31),h+=ms[j]);var O=31&i[E];qs(t,h,C[O]),h+=B[O],O>3&&(qs(t,h,i[E]>>>5&8191),h+=ws[O])}else qs(t,h,x[i[E]]),h+=I[i[E]];return qs(t,h,x[256]),h+I[256]},Zs=/*#__PURE__*/new fs([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),Js=/*#__PURE__*/new gs(0),ea=function(e,t,r,i,n){return function(e,t,r,i,n,s){var a=e.length,o=new gs(i+a+5*(1+Math.ceil(a/7e3))+n),c=o.subarray(i,o.length-n),u=0;if(!t||a<8)for(var h=0;h<=a;h+=65535){var y=h+65535;y>=a&&(c[u>>3]=s),u=Xs(c,u+1,e.subarray(h,y))}else{for(var l=Zs[t-1],p=l>>>13,g=8191&l,d=(1<<r)-1,f=new ds(32768),m=new ds(d+1),w=Math.ceil(r/3),b=2*w,k=function(t){return(e[t]^e[t+1]<<w^e[t+2]<<b)&d},v=new fs(25e3),A=new ds(288),K=new ds(32),E=0,S=0,P=(h=0,0),U=0,D=0;h<a;++h){var x=k(h),I=32767&h,C=m[x];if(f[I]=C,m[x]=I,U<=h){var B=a-h;if((E>7e3||P>24576)&&B>423){u=Ys(e,c,0,v,A,K,S,P,D,h-D,u),P=E=S=0,D=h;for(var T=0;T<286;++T)A[T]=0;for(T=0;T<30;++T)K[T]=0}var M=2,L=0,F=g,R=I-C&32767;if(B>2&&x==k(h-R))for(var N=Math.min(p,B)-1,z=Math.min(32767,h),j=Math.min(258,B);R<=z&&--F&&I!=C;){if(e[h+M]==e[h+M-R]){for(var O=0;O<j&&e[h+O]==e[h+O-R];++O);if(O>M){if(M=O,L=R,O>N)break;var H=Math.min(R,O-2),_=0;for(T=0;T<H;++T){var G=h-R+T+32768&32767,q=G-f[G]+32768&32767;q>_&&(_=q,C=G)}}}R+=(I=C)-(C=f[I])+32768&32767}if(L){v[P++]=268435456|Ks[M]<<18|Ps[L];var V=31&Ks[M],W=31&Ps[L];S+=ms[V]+ws[W],++A[257+V],++K[W],U=h+M,++E}else v[P++]=e[h],++A[e[h]]}}u=Ys(e,c,s,v,A,K,S,P,D,h-D,u),!s&&7&u&&(u=Xs(c,u+1,Js))}return Os(o,0,i+js(u)+n)}(e,null==t.level?6:t.level,null==t.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(e.length)))):12+t.mem,r,i,!n)},ta=/*#__PURE__*/function(){function e(e,t){t||"function"!=typeof e||(t=e,e={}),this.ondata=t,this.o=e||{}}return e.prototype.p=function(e,t){this.ondata(ea(e,this.o,0,0,!t),t)},e.prototype.push=function(e,t){this.ondata||_s(5),this.d&&_s(4),this.d=t,this.p(e,t||!1)},e}(),ra=/*#__PURE__*/function(){function e(e){this.s={},this.p=new gs(0),this.ondata=e}return e.prototype.e=function(e){this.ondata||_s(5),this.d&&_s(4);var t=this.p.length,r=new gs(t+e.length);r.set(this.p),r.set(e,t),this.p=r},e.prototype.c=function(e){this.d=this.s.i=e||!1;var t=this.s.b,r=function(e,t,r){var i=e.length;if(!i||r&&r.f&&!r.l)return t||new gs(0);var n=!t||r,s=!r||r.i;r||(r={}),t||(t=new gs(3*i));var a=function(e){var r=t.length;if(e>r){var i=new gs(Math.max(2*r,e));i.set(t),t=i}},o=r.f||0,c=r.p||0,u=r.b||0,h=r.l,y=r.d,l=r.m,p=r.n,g=8*i;do{if(!h){o=Ns(e,c,1);var d=Ns(e,c+1,3);if(c+=3,!d){var f=e[(U=js(c)+4)-4]|e[U-3]<<8,m=U+f;if(m>i){s&&_s(0);break}n&&a(u+f),t.set(e.subarray(U,m),u),r.b=u+=f,r.p=c=8*m,r.f=o;continue}if(1==d)h=Ms,y=Fs,l=9,p=5;else if(2==d){var w=Ns(e,c,31)+257,b=Ns(e,c+10,15)+4,k=w+Ns(e,c+5,31)+1;c+=14;for(var v=new gs(k),A=new gs(19),K=0;K<b;++K)A[bs[K]]=Ns(e,c+3*K,7);c+=3*b;var E=Rs(A),S=(1<<E)-1,P=Is(A,E,1);for(K=0;K<k;){var U,D=P[Ns(e,c,S)];if(c+=15&D,(U=D>>>4)<16)v[K++]=U;else{var x=0,I=0;for(16==U?(I=3+Ns(e,c,3),c+=2,x=v[K-1]):17==U?(I=3+Ns(e,c,7),c+=3):18==U&&(I=11+Ns(e,c,127),c+=7);I--;)v[K++]=x}}var C=v.subarray(0,w),B=v.subarray(w);l=Rs(C),p=Rs(B),h=Is(C,l,1),y=Is(B,p,1)}else _s(1);if(c>g){s&&_s(0);break}}n&&a(u+131072);for(var T=(1<<l)-1,M=(1<<p)-1,L=c;;L=c){var F=(x=h[zs(e,c)&T])>>>4;if((c+=15&x)>g){s&&_s(0);break}if(x||_s(2),F<256)t[u++]=F;else{if(256==F){L=c,h=null;break}var R=F-254;if(F>264){var N=ms[K=F-257];R=Ns(e,c,(1<<N)-1)+As[K],c+=N}var z=y[zs(e,c)&M],j=z>>>4;if(z||_s(3),c+=15&z,B=Ss[j],j>3&&(N=ws[j],B+=zs(e,c)&(1<<N)-1,c+=N),c>g){s&&_s(0);break}n&&a(u+131072);for(var O=u+R;u<O;u+=4)t[u]=t[u-B],t[u+1]=t[u+1-B],t[u+2]=t[u+2-B],t[u+3]=t[u+3-B];u=O}}r.l=h,r.p=L,r.b=u,r.f=o,h&&(o=1,r.m=l,r.d=y,r.n=p)}while(!o);return u==t.length?t:Os(t,0,u)}(this.p,this.o,this.s);this.ondata(Os(r,t,this.s.b),this.d),this.o=Os(r,this.s.b-32768),this.s.b=this.o.length,this.p=Os(this.p,this.s.p/8|0),this.s.p&=7},e.prototype.push=function(e,t){this.e(e),this.c(t)},e}(),ia=/*#__PURE__*/function(){function e(e,t){var r,i;this.c=(r=1,i=0,{p:function(e){for(var t=r,n=i,s=0|e.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)n+=t+=e[a];t=(65535&t)+15*(t>>16),n=(65535&n)+15*(n>>16)}r=t,i=n},d:function(){return(255&(r%=65521))<<24|r>>>8<<16|(255&(i%=65521))<<8|i>>>8}}),this.v=1,ta.call(this,e,t)}return e.prototype.push=function(e,t){ta.prototype.push.call(this,e,t)},e.prototype.p=function(e,t){this.c.p(e);var r=ea(e,this.o,this.v&&2,t&&4,!t);this.v&&(function(e,t){var r=t.level,i=0==r?0:r<6?1:9==r?3:2;e[0]=120,e[1]=i<<6|(i?32-2*i:1)}(r,this.o),this.v=0),t&&function(e,t,r){for(;r;++t)e[t]=r,r>>>=8}(r,r.length-4,this.c.d()),this.ondata(r,t)},e}(),na=/*#__PURE__*/function(){function e(e){this.v=1,ra.call(this,e)}return e.prototype.push=function(e,t){if(ra.prototype.e.call(this,e),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0}t&&(this.p.length<4&&_s(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),ra.prototype.c.call(this,t)},e}(),sa="undefined"!=typeof TextDecoder&&/*#__PURE__*/new TextDecoder;try{sa.decode(Js,{stream:!0}),1}catch(e){}class aa{static get tag(){return T.packet.literalData}constructor(e=new Date){this.format=T.literal.utf8,this.date=F.normalizeDate(e),this.text=null,this.data=null,this.filename=""}setText(e,t=T.literal.utf8){this.format=t,this.text=e,this.data=null}getText(e=!1){return(null===this.text||F.isStream(this.text))&&(this.text=F.decodeUTF8(F.nativeEOL(this.getBytes(e)))),this.text}setBytes(e,t){this.format=t,this.data=e,this.text=null}getBytes(e=!1){return null===this.data&&(this.data=F.canonicalizeEOL(F.encodeUTF8(this.text))),e?E(this.data):this.data}setFilename(e){this.filename=e}getFilename(){return this.filename}async read(e){await A(e,(async e=>{const t=await e.readByte(),r=await e.readByte();this.filename=F.decodeUTF8(await e.readBytes(r)),this.date=F.readDate(await e.readBytes(4));let i=e.remainder();a(i)&&(i=await U(i)),this.setBytes(i,t)}))}writeHeader(){const e=F.encodeUTF8(this.filename),t=new Uint8Array([e.length]),r=new Uint8Array([this.format]),i=F.writeDate(this.date);return F.concatUint8Array([r,t,e,i])}write(){const e=this.writeHeader(),t=this.getBytes();return F.concat([e,t])}}class oa{constructor(){this.bytes=""}read(e){return this.bytes=F.uint8ArrayToString(e.subarray(0,8)),this.bytes.length}write(){return F.stringToUint8Array(this.bytes)}toHex(){return F.uint8ArrayToHex(F.stringToUint8Array(this.bytes))}equals(e,t=!1){return t&&(e.isWildcard()||this.isWildcard())||this.bytes===e.bytes}isNull(){return""===this.bytes}isWildcard(){return/^0+$/.test(this.toHex())}static mapToHex(e){return e.toHex()}static fromID(e){const t=new oa;return t.read(F.hexToUint8Array(e)),t}static wildcard(){const e=new oa;return e.read(new Uint8Array(8)),e}}const ca=Symbol("verified"),ua="salt@notations.openpgpjs.org",ha=new Set([T.signatureSubpacket.issuerKeyID,T.signatureSubpacket.issuerFingerprint,T.signatureSubpacket.embeddedSignature]);class ya{static get tag(){return T.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.unknownSubpackets=[],this.signedHashValue=null,this.salt=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new oa,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.preferredCipherSuites=null,this.revoked=null,this[ca]=null}read(e,t=M){let r=0;if(this.version=e[r++],5===this.version&&!t.enableParsingV5Entities)throw new Gi("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4!==this.version&&5!==this.version&&6!==this.version)throw new Gi(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=e[r++],this.publicKeyAlgorithm=e[r++],this.hashAlgorithm=e[r++],r+=this.readSubPackets(e.subarray(r,e.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");if(this.signatureData=e.subarray(0,r),r+=this.readSubPackets(e.subarray(r,e.length),!1),this.signedHashValue=e.subarray(r,r+2),r+=2,6===this.version){const t=e[r++];this.salt=e.subarray(r,r+t),r+=t}const i=e.subarray(r,e.length),{read:n,signatureParams:s}=ss.signature.parseSignatureParams(this.publicKeyAlgorithm,i);if(n<i.length)throw Error("Error reading MPIs");this.params=s}writeParams(){return this.params instanceof Promise?x((async()=>ss.serializeParams(this.publicKeyAlgorithm,await this.params))):ss.serializeParams(this.publicKeyAlgorithm,this.params)}write(){const e=[];return e.push(this.signatureData),e.push(this.writeUnhashedSubPackets()),e.push(this.signedHashValue),6===this.version&&(e.push(new Uint8Array([this.salt.length])),e.push(this.salt)),e.push(this.writeParams()),F.concat(e)}async sign(e,t,r=new Date,i=!1,n){this.version=e.version,this.created=F.normalizeDate(r),this.issuerKeyVersion=e.version,this.issuerFingerprint=e.getFingerprintBytes(),this.issuerKeyID=e.getKeyID();const s=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];if(6===this.version){const e=pa(this.hashAlgorithm);if(null===this.salt)this.salt=ss.random.getRandomBytes(e);else if(e!==this.salt.length)throw Error("Provided salt does not have the required length")}else if(n.nonDeterministicSignaturesViaNotation){if(0!==this.rawNotations.filter((({name:e})=>e===ua)).length)throw Error("Unexpected existing salt notation");{const e=ss.random.getRandomBytes(pa(this.hashAlgorithm));this.rawNotations.push({name:ua,value:e,humanReadable:!1,critical:!1})}}s.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=F.concat(s);const a=this.toHash(this.signatureType,t,i),o=await this.hash(this.signatureType,t,a,i);this.signedHashValue=P(K(o),0,2);const c=async()=>ss.signature.sign(this.publicKeyAlgorithm,this.hashAlgorithm,e.publicParams,e.privateParams,a,await U(o));F.isStream(o)?this.params=c():(this.params=await c(),this[ca]=!0)}writeHashedSubPackets(){const e=T.signatureSubpacket,t=[];let r;if(null===this.created)throw Error("Missing signature creation time");t.push(la(e.signatureCreationTime,!0,F.writeDate(this.created))),null!==this.signatureExpirationTime&&t.push(la(e.signatureExpirationTime,!0,F.writeNumber(this.signatureExpirationTime,4))),null!==this.exportable&&t.push(la(e.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),null!==this.trustLevel&&(r=new Uint8Array([this.trustLevel,this.trustAmount]),t.push(la(e.trustSignature,!0,r))),null!==this.regularExpression&&t.push(la(e.regularExpression,!0,this.regularExpression)),null!==this.revocable&&t.push(la(e.revocable,!0,new Uint8Array([this.revocable?1:0]))),null!==this.keyExpirationTime&&t.push(la(e.keyExpirationTime,!0,F.writeNumber(this.keyExpirationTime,4))),null!==this.preferredSymmetricAlgorithms&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.preferredSymmetricAlgorithms)),t.push(la(e.preferredSymmetricAlgorithms,!1,r))),null!==this.revocationKeyClass&&(r=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),r=F.concat([r,this.revocationKeyFingerprint]),t.push(la(e.revocationKey,!1,r))),!this.issuerKeyID.isNull()&&this.issuerKeyVersion<5&&t.push(la(e.issuerKeyID,!0,this.issuerKeyID.write())),this.rawNotations.forEach((({name:i,value:n,humanReadable:s,critical:a})=>{r=[new Uint8Array([s?128:0,0,0,0])];const o=F.encodeUTF8(i);r.push(F.writeNumber(o.length,2)),r.push(F.writeNumber(n.length,2)),r.push(o),r.push(n),r=F.concat(r),t.push(la(e.notationData,a,r))})),null!==this.preferredHashAlgorithms&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.preferredHashAlgorithms)),t.push(la(e.preferredHashAlgorithms,!1,r))),null!==this.preferredCompressionAlgorithms&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.preferredCompressionAlgorithms)),t.push(la(e.preferredCompressionAlgorithms,!1,r))),null!==this.keyServerPreferences&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.keyServerPreferences)),t.push(la(e.keyServerPreferences,!1,r))),null!==this.preferredKeyServer&&t.push(la(e.preferredKeyServer,!1,F.encodeUTF8(this.preferredKeyServer))),null!==this.isPrimaryUserID&&t.push(la(e.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),null!==this.policyURI&&t.push(la(e.policyURI,!1,F.encodeUTF8(this.policyURI))),null!==this.keyFlags&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.keyFlags)),t.push(la(e.keyFlags,!0,r))),null!==this.signersUserID&&t.push(la(e.signersUserID,!1,F.encodeUTF8(this.signersUserID))),null!==this.reasonForRevocationFlag&&(r=F.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),t.push(la(e.reasonForRevocation,!0,r))),null!==this.features&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.features)),t.push(la(e.features,!1,r))),null!==this.signatureTargetPublicKeyAlgorithm&&(r=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],r.push(F.stringToUint8Array(this.signatureTargetHash)),r=F.concat(r),t.push(la(e.signatureTarget,!0,r))),null!==this.embeddedSignature&&t.push(la(e.embeddedSignature,!0,this.embeddedSignature.write())),null!==this.issuerFingerprint&&(r=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],r=F.concat(r),t.push(la(e.issuerFingerprint,this.version>=5,r))),null!==this.preferredAEADAlgorithms&&(r=F.stringToUint8Array(F.uint8ArrayToString(this.preferredAEADAlgorithms)),t.push(la(e.preferredAEADAlgorithms,!1,r))),null!==this.preferredCipherSuites&&(r=new Uint8Array([].concat(...this.preferredCipherSuites)),t.push(la(e.preferredCipherSuites,!1,r)));const i=F.concat(t),n=F.writeNumber(i.length,6===this.version?4:2);return F.concat([n,i])}writeUnhashedSubPackets(){const e=this.unhashedSubpackets.map((({type:e,critical:t,body:r})=>la(e,t,r))),t=F.concat(e),r=F.writeNumber(t.length,6===this.version?4:2);return F.concat([r,t])}readSubPacket(e,t=!0){let r=0;const i=!!(128&e[r]),n=127&e[r];if(r++,t||(this.unhashedSubpackets.push({type:n,critical:i,body:e.subarray(r,e.length)}),ha.has(n)))switch(n){case T.signatureSubpacket.signatureCreationTime:this.created=F.readDate(e.subarray(r,e.length));break;case T.signatureSubpacket.signatureExpirationTime:{const t=F.readNumber(e.subarray(r,e.length));this.signatureNeverExpires=0===t,this.signatureExpirationTime=t;break}case T.signatureSubpacket.exportableCertification:this.exportable=1===e[r++];break;case T.signatureSubpacket.trustSignature:this.trustLevel=e[r++],this.trustAmount=e[r++];break;case T.signatureSubpacket.regularExpression:this.regularExpression=e[r];break;case T.signatureSubpacket.revocable:this.revocable=1===e[r++];break;case T.signatureSubpacket.keyExpirationTime:{const t=F.readNumber(e.subarray(r,e.length));this.keyExpirationTime=t,this.keyNeverExpires=0===t;break}case T.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.revocationKey:this.revocationKeyClass=e[r++],this.revocationKeyAlgorithm=e[r++],this.revocationKeyFingerprint=e.subarray(r,r+20);break;case T.signatureSubpacket.issuerKeyID:if(4===this.version)this.issuerKeyID.read(e.subarray(r,e.length));else if(t)throw Error("Unexpected Issuer Key ID subpacket");break;case T.signatureSubpacket.notationData:{const t=!!(128&e[r]);r+=4;const n=F.readNumber(e.subarray(r,r+2));r+=2;const s=F.readNumber(e.subarray(r,r+2));r+=2;const a=F.decodeUTF8(e.subarray(r,r+n)),o=e.subarray(r+n,r+n+s);this.rawNotations.push({name:a,humanReadable:t,value:o,critical:i}),t&&(this.notations[a]=F.decodeUTF8(o));break}case T.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=F.decodeUTF8(e.subarray(r,e.length));break;case T.signatureSubpacket.primaryUserID:this.isPrimaryUserID=0!==e[r++];break;case T.signatureSubpacket.policyURI:this.policyURI=F.decodeUTF8(e.subarray(r,e.length));break;case T.signatureSubpacket.keyFlags:this.keyFlags=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.signersUserID:this.signersUserID=F.decodeUTF8(e.subarray(r,e.length));break;case T.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=e[r++],this.reasonForRevocationString=F.decodeUTF8(e.subarray(r,e.length));break;case T.signatureSubpacket.features:this.features=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=e[r++],this.signatureTargetHashAlgorithm=e[r++];const t=ss.getHashByteLength(this.signatureTargetHashAlgorithm);this.signatureTargetHash=F.uint8ArrayToString(e.subarray(r,r+t));break}case T.signatureSubpacket.embeddedSignature:this.embeddedSignature=new ya,this.embeddedSignature.read(e.subarray(r,e.length));break;case T.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=e[r++],this.issuerFingerprint=e.subarray(r,e.length),this.issuerKeyVersion>=5?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case T.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...e.subarray(r,e.length)];break;case T.signatureSubpacket.preferredCipherSuites:this.preferredCipherSuites=[];for(let t=r;t<e.length;t+=2)this.preferredCipherSuites.push([e[t],e[t+1]]);break;default:this.unknownSubpackets.push({type:n,critical:i,body:e.subarray(r,e.length)})}}readSubPackets(e,t=!0,r){const i=6===this.version?4:2,n=F.readNumber(e.subarray(0,i));let s=i;for(;s<2+n;){const i=Ri(e.subarray(s,e.length));s+=i.offset,this.readSubPacket(e.subarray(s,s+i.len),t,r),s+=i.len}return s}toSign(e,t){const r=T.signature;switch(e){case r.binary:return null!==t.text?F.encodeUTF8(t.getText(!0)):t.getBytes(!0);case r.text:{const e=t.getBytes(!0);return F.canonicalizeEOL(e)}case r.standalone:return new Uint8Array(0);case r.certGeneric:case r.certPersona:case r.certCasual:case r.certPositive:case r.certRevocation:{let e,i;if(t.userID)i=180,e=t.userID;else{if(!t.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");i=209,e=t.userAttribute}const n=e.write();return F.concat([this.toSign(r.key,t),new Uint8Array([i]),F.writeNumber(n.length,4),n])}case r.subkeyBinding:case r.subkeyRevocation:case r.keyBinding:return F.concat([this.toSign(r.key,t),this.toSign(r.key,{key:t.bind})]);case r.key:if(void 0===t.key)throw Error("Key packet is required for this signature.");return t.key.writeForHash(this.version);case r.keyRevocation:return this.toSign(r.key,t);case r.timestamp:return new Uint8Array(0);case r.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(e,t){let r=0;return k(K(this.signatureData),(e=>{r+=e.length}),(()=>{const i=[];return 5!==this.version||this.signatureType!==T.signature.binary&&this.signatureType!==T.signature.text||(t?i.push(new Uint8Array(6)):i.push(e.writeHeader())),i.push(new Uint8Array([this.version,255])),5===this.version&&i.push(new Uint8Array(4)),i.push(F.writeNumber(r,4)),F.concat(i)}))}toHash(e,t,r=!1){const i=this.toSign(e,t);return F.concat([this.salt||new Uint8Array,i,this.signatureData,this.calculateTrailer(t,r)])}async hash(e,t,r,i=!1){if(6===this.version&&this.salt.length!==pa(this.hashAlgorithm))throw Error("Signature salt does not have the expected length");return r||(r=this.toHash(e,t,i)),ss.hash.digest(this.hashAlgorithm,r)}async verify(e,t,r,i=new Date,n=!1,s=M){if(!this.issuerKeyID.equals(e.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const a=t===T.signature.binary||t===T.signature.text;if(!(this[ca]&&!a)){let i,s;if(this.hashed?s=await this.hashed:(i=this.toHash(t,r,n),s=await this.hash(t,r,i)),s=await U(s),this.signedHashValue[0]!==s[0]||this.signedHashValue[1]!==s[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[ca]=await ss.signature.verify(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,e.publicParams,i,s),!this[ca])throw Error("Signature verification failed")}const o=F.normalizeDate(i);if(o&&this.created>o)throw Error("Signature creation time is in the future");if(o&&o>=this.getExpirationTime())throw Error("Signature is expired");if(s.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+T.read(T.hash,this.hashAlgorithm).toUpperCase());if(s.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[T.signature.binary,T.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+T.read(T.hash,this.hashAlgorithm).toUpperCase());if(this.unknownSubpackets.forEach((({type:e,critical:t})=>{if(t)throw Error("Unknown critical signature subpacket type "+e)})),this.rawNotations.forEach((({name:e,critical:t})=>{if(t&&s.knownNotations.indexOf(e)<0)throw Error("Unknown critical notation: "+e)})),null!==this.revocationKeyClass)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(e=new Date){const t=F.normalizeDate(e);return null!==t&&!(this.created<=t&&t<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function la(e,t,r){const i=[];return i.push(Ni(r.length+1)),i.push(new Uint8Array([(t?128:0)|e])),i.push(r),F.concat(i)}function pa(e){switch(e){case T.hash.sha256:return 16;case T.hash.sha384:return 24;case T.hash.sha512:return 32;case T.hash.sha224:case T.hash.sha3_256:return 16;case T.hash.sha3_512:return 32;default:throw Error("Unsupported hash function")}}class ga{static get tag(){return T.packet.onePassSignature}static fromSignaturePacket(e,t){const r=new ga;return r.version=6===e.version?6:3,r.signatureType=e.signatureType,r.hashAlgorithm=e.hashAlgorithm,r.publicKeyAlgorithm=e.publicKeyAlgorithm,r.issuerKeyID=e.issuerKeyID,r.salt=e.salt,r.issuerFingerprint=e.issuerFingerprint,r.flags=t?1:0,r}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.salt=null,this.issuerKeyID=null,this.issuerFingerprint=null,this.flags=null}read(e){let t=0;if(this.version=e[t++],3!==this.version&&6!==this.version)throw new Gi(`Version ${this.version} of the one-pass signature packet is unsupported.`);if(this.signatureType=e[t++],this.hashAlgorithm=e[t++],this.publicKeyAlgorithm=e[t++],6===this.version){const r=e[t++];this.salt=e.subarray(t,t+r),t+=r,this.issuerFingerprint=e.subarray(t,t+32),t+=32,this.issuerKeyID=new oa,this.issuerKeyID.read(this.issuerFingerprint)}else this.issuerKeyID=new oa,this.issuerKeyID.read(e.subarray(t,t+8)),t+=8;return this.flags=e[t++],this}write(){const e=[new Uint8Array([this.version,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm])];return 6===this.version?e.push(new Uint8Array([this.salt.length]),this.salt,this.issuerFingerprint):e.push(this.issuerKeyID.write()),e.push(new Uint8Array([this.flags])),F.concatUint8Array(e)}calculateTrailer(...e){return x((async()=>ya.prototype.calculateTrailer.apply(await this.correspondingSig,e)))}async verify(){const e=await this.correspondingSig;if(!e||e.constructor.tag!==T.packet.signature)throw Error("Corresponding signature packet missing");if(e.signatureType!==this.signatureType||e.hashAlgorithm!==this.hashAlgorithm||e.publicKeyAlgorithm!==this.publicKeyAlgorithm||!e.issuerKeyID.equals(this.issuerKeyID)||3===this.version&&6===e.version||6===this.version&&6!==e.version||6===this.version&&!F.equalsUint8Array(e.issuerFingerprint,this.issuerFingerprint)||6===this.version&&!F.equalsUint8Array(e.salt,this.salt))throw Error("Corresponding signature packet does not match one-pass signature packet");return e.hashed=this.hashed,e.verify.apply(e,arguments)}}function da(e,t){if(!t[e]){let t;try{t=T.read(T.packet,e)}catch(t){throw new qi("Unknown packet type with tag: "+e)}throw Error("Packet not allowed in this context: "+t)}return new t[e]}ga.prototype.hash=ya.prototype.hash,ga.prototype.toHash=ya.prototype.toHash,ga.prototype.toSign=ya.prototype.toSign;class fa extends Array{static async fromBinary(e,t,r=M){const i=new fa;return await i.read(e,t,r),i}async read(e,t,r=M){r.additionalAllowedPackets.length&&(t={...t,...F.constructAllowedPackets(r.additionalAllowedPackets)}),this.stream=v(e,(async(e,i)=>{const n=C(i);try{for(;;){await n.ready;if(await _i(e,(async e=>{try{if(e.tag===T.packet.marker||e.tag===T.packet.trust||e.tag===T.packet.padding)return;const i=da(e.tag,t);i.packets=new fa,i.fromStream=F.isStream(e.packet),await i.read(e.packet,r),await n.write(i)}catch(t){if(t instanceof qi){if(!(e.tag<=39))return;await n.abort(t)}const i=!r.ignoreUnsupportedPackets&&t instanceof Gi,s=!(r.ignoreMalformedPackets||t instanceof Gi);if(i||s||Hi(e.tag))await n.abort(t);else{const t=new Vi(e.tag,e.packet);await n.write(t)}F.printDebugError(t)}})))return await n.ready,void await n.close()}}catch(e){await n.abort(e)}}));const i=I(this.stream);for(;;){const{done:e,value:t}=await i.read();if(e?this.stream=null:this.push(t),e||Hi(t.constructor.tag))break}i.releaseLock()}write(){const e=[];for(let t=0;t<this.length;t++){const r=this[t]instanceof Vi?this[t].tag:this[t].constructor.tag,i=this[t].write();if(F.isStream(i)&&Hi(this[t].constructor.tag)){let t=[],n=0;const s=512;e.push(ji(r)),e.push(k(i,(e=>{if(t.push(e),n+=e.length,n>=s){const e=Math.min(Math.log(n)/Math.LN2|0,30),r=2**e,i=F.concat([zi(e)].concat(t));return t=[i.subarray(1+r)],n=t[0].length,i.subarray(0,1+r)}}),(()=>F.concat([Ni(n)].concat(t)))))}else{if(F.isStream(i)){let t=0;e.push(k(K(i),(e=>{t+=e.length}),(()=>Oi(r,t))))}else e.push(Oi(r,i.length));e.push(i)}}return F.concat(e)}filterByTag(...e){const t=new fa,r=e=>t=>e===t;for(let i=0;i<this.length;i++)e.some(r(this[i].constructor.tag))&&t.push(this[i]);return t}findPacket(e){return this.find((t=>t.constructor.tag===e))}indexOfTag(...e){const t=[],r=this,i=e=>t=>e===t;for(let n=0;n<this.length;n++)e.some(i(r[n].constructor.tag))&&t.push(n);return t}}const ma=/*#__PURE__*/F.constructAllowedPackets([aa,ga,ya]);class wa{static get tag(){return T.packet.compressedData}constructor(e=M){this.packets=null,this.algorithm=e.preferredCompressionAlgorithm,this.compressed=null}async read(e,t=M){await A(e,(async e=>{this.algorithm=await e.readByte(),this.compressed=e.remainder(),await this.decompress(t)}))}write(){return null===this.compressed&&this.compress(),F.concat([new Uint8Array([this.algorithm]),this.compressed])}async decompress(e=M){const t=T.read(T.compression,this.algorithm),r=Ka[t];if(!r)throw Error(t+" decompression not supported");this.packets=await fa.fromBinary(await r(this.compressed),ma,e)}compress(){const e=T.read(T.compression,this.algorithm),t=Aa[e];if(!t)throw Error(e+" compression not supported");this.compressed=t(this.packets.write())}}function ba(e,t){return r=>{if(!F.isStream(r)||a(r))return x((()=>U(r).then((e=>new Promise(((r,i)=>{const n=new t;n.ondata=e=>{r(e)};try{n.push(e,!0)}catch(e){i(e)}}))))));if(e)try{const t=e();return r.pipeThrough(t)}catch(e){if("TypeError"!==e.name)throw e}const i=r.getReader(),n=new t;return new ReadableStream({async start(e){for(n.ondata=async(t,r)=>{e.enqueue(t),r&&e.close()};;){const{done:e,value:t}=await i.read();if(e)return void n.push(new Uint8Array,!0);t.length&&n.push(t)}}})}}function ka(){return async function(e){const{decode:t}=await import("./seek-bzip.min.mjs").then((function(e){return e.i}));return x((async()=>t(await U(e))))}}const va=e=>({compressor:"undefined"!=typeof CompressionStream&&(()=>new CompressionStream(e)),decompressor:"undefined"!=typeof DecompressionStream&&(()=>new DecompressionStream(e))}),Aa={zip:/*#__PURE__*/ba(va("deflate-raw").compressor,ta),zlib:/*#__PURE__*/ba(va("deflate").compressor,ia)},Ka={uncompressed:e=>e,zip:/*#__PURE__*/ba(va("deflate-raw").decompressor,ra),zlib:/*#__PURE__*/ba(va("deflate").decompressor,na),bzip2:/*#__PURE__*/ka()},Ea=/*#__PURE__*/F.constructAllowedPackets([aa,wa,ga,ya]);class Sa{static get tag(){return T.packet.symEncryptedIntegrityProtectedData}static fromObject({version:e,aeadAlgorithm:t}){if(1!==e&&2!==e)throw Error("Unsupported SEIPD version");const r=new Sa;return r.version=e,2===e&&(r.aeadAlgorithm=t),r}constructor(){this.version=null,this.cipherAlgorithm=null,this.aeadAlgorithm=null,this.chunkSizeByte=null,this.salt=null,this.encrypted=null,this.packets=null}async read(e){await A(e,(async e=>{if(this.version=await e.readByte(),1!==this.version&&2!==this.version)throw new Gi(`Version ${this.version} of the SEIP packet is unsupported.`);2===this.version&&(this.cipherAlgorithm=await e.readByte(),this.aeadAlgorithm=await e.readByte(),this.chunkSizeByte=await e.readByte(),this.salt=await e.readBytes(32)),this.encrypted=e.remainder()}))}write(){return 2===this.version?F.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.salt,this.encrypted]):F.concat([new Uint8Array([this.version]),this.encrypted])}async encrypt(e,t,r=M){const{blockSize:i,keySize:n}=ss.getCipherParams(e);if(t.length!==n)throw Error("Unexpected session key size");let s=this.packets.write();if(a(s)&&(s=await U(s)),2===this.version)this.cipherAlgorithm=e,this.salt=ss.random.getRandomBytes(32),this.chunkSizeByte=r.aeadChunkSizeByte,this.encrypted=await Pa(this,"encrypt",t,s);else{const n=await ss.getPrefixRandom(e),a=new Uint8Array([211,20]),o=F.concat([n,s,a]),c=await ss.hash.sha1(E(o)),u=F.concat([o,c]);this.encrypted=await ss.mode.cfb.encrypt(e,t,u,new Uint8Array(i),r)}return!0}async decrypt(e,t,r=M){if(t.length!==ss.getCipherParams(e).keySize)throw Error("Unexpected session key size");let i,n=K(this.encrypted);if(a(n)&&(n=await U(n)),2===this.version){if(this.cipherAlgorithm!==e)throw Error("Unexpected session key algorithm");i=await Pa(this,"decrypt",t,n)}else{const{blockSize:s}=ss.getCipherParams(e),a=await ss.mode.cfb.decrypt(e,t,n,new Uint8Array(s)),o=P(E(a),-20),c=P(a,0,-20),u=Promise.all([U(await ss.hash.sha1(E(c))),U(o)]).then((([e,t])=>{if(!F.equalsUint8Array(e,t))throw Error("Modification detected.");return new Uint8Array})),h=P(c,s+2);i=P(h,0,-2),i=f([i,x((()=>u))]),F.isStream(n)&&r.allowUnauthenticatedStream||(i=await U(i))}return this.packets=await fa.fromBinary(i,Ea,r),!0}}async function Pa(e,t,r,i){const n=e instanceof Sa&&2===e.version,s=!n&&e.constructor.tag===T.packet.aeadEncryptedData;if(!n&&!s)throw Error("Unexpected packet type");const a=ss.getAEADMode(e.aeadAlgorithm),o="decrypt"===t?a.tagLength:0,c="encrypt"===t?a.tagLength:0,u=2**(e.chunkSizeByte+6)+o,h=s?8:0,y=new ArrayBuffer(13+h),l=new Uint8Array(y,0,5+h),p=new Uint8Array(y),g=new DataView(y),d=new Uint8Array(y,5,8);l.set([192|e.constructor.tag,e.version,e.cipherAlgorithm,e.aeadAlgorithm,e.chunkSizeByte],0);let f,w,b=0,k=Promise.resolve(),A=0,K=0;if(n){const{keySize:t}=ss.getCipherParams(e.cipherAlgorithm),{ivLength:i}=a,n=new Uint8Array(y,0,5),s=await on(T.hash.sha256,r,e.salt,n,t+i);r=s.subarray(0,t),f=s.subarray(t),f.fill(0,f.length-8),w=new DataView(f.buffer,f.byteOffset,f.byteLength)}else f=e.iv;const E=await a(e.cipherAlgorithm,r);return v(i,(async(r,i)=>{if("array"!==F.isStream(r)){const t=new TransformStream({},{highWaterMark:F.getHardwareConcurrency()*2**(e.chunkSizeByte+6),size:e=>e.length});m(t.readable,i),i=t.writable}const s=I(r),a=C(i);try{for(;;){let e=await s.readBytes(u+o)||new Uint8Array;const r=e.subarray(e.length-o);let i,y,m;if(e=e.subarray(0,e.length-o),n)m=f;else{m=f.slice();for(let e=0;e<8;e++)m[f.length-8+e]^=d[e]}if(!b||e.length?(s.unshift(r),i=E[t](e,m,l),i.catch((()=>{})),K+=e.length-o+c):(g.setInt32(5+h+4,A),i=E[t](r,m,p),i.catch((()=>{})),K+=c,y=!0),A+=e.length-o,k=k.then((()=>i)).then((async e=>{await a.ready,await a.write(e),K-=e.length})).catch((e=>a.abort(e))),(y||K>a.desiredSize)&&await k,y){await a.close();break}n?w.setInt32(f.length-4,++b):g.setInt32(9,++b)}}catch(e){await a.ready.catch((()=>{})),await a.abort(e)}}))}const Ua=/*#__PURE__*/F.constructAllowedPackets([aa,wa,ga,ya]);class Da{static get tag(){return T.packet.aeadEncryptedData}constructor(){this.version=1,this.cipherAlgorithm=null,this.aeadAlgorithm=T.aead.eax,this.chunkSizeByte=null,this.iv=null,this.encrypted=null,this.packets=null}async read(e){await A(e,(async e=>{const t=await e.readByte();if(1!==t)throw new Gi(`Version ${t} of the AEAD-encrypted data packet is not supported.`);this.cipherAlgorithm=await e.readByte(),this.aeadAlgorithm=await e.readByte(),this.chunkSizeByte=await e.readByte();const r=ss.getAEADMode(this.aeadAlgorithm);this.iv=await e.readBytes(r.ivLength),this.encrypted=e.remainder()}))}write(){return F.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.iv,this.encrypted])}async decrypt(e,t,r=M){this.packets=await fa.fromBinary(await Pa(this,"decrypt",t,K(this.encrypted)),Ua,r)}async encrypt(e,t,r=M){this.cipherAlgorithm=e;const{ivLength:i}=ss.getAEADMode(this.aeadAlgorithm);this.iv=ss.random.getRandomBytes(i),this.chunkSizeByte=r.aeadChunkSizeByte;const n=this.packets.write();this.encrypted=await Pa(this,"encrypt",t,n)}}class xa{static get tag(){return T.packet.publicKeyEncryptedSessionKey}constructor(){this.version=null,this.publicKeyID=new oa,this.publicKeyVersion=null,this.publicKeyFingerprint=null,this.publicKeyAlgorithm=null,this.sessionKey=null,this.sessionKeyAlgorithm=null,this.encrypted={}}static fromObject({version:e,encryptionKeyPacket:t,anonymousRecipient:r,sessionKey:i,sessionKeyAlgorithm:n}){const s=new xa;if(3!==e&&6!==e)throw Error("Unsupported PKESK version");return s.version=e,6===e&&(s.publicKeyVersion=r?null:t.version,s.publicKeyFingerprint=r?null:t.getFingerprintBytes()),s.publicKeyID=r?oa.wildcard():t.getKeyID(),s.publicKeyAlgorithm=t.algorithm,s.sessionKey=i,s.sessionKeyAlgorithm=n,s}read(e){let t=0;if(this.version=e[t++],3!==this.version&&6!==this.version)throw new Gi(`Version ${this.version} of the PKESK packet is unsupported.`);if(6===this.version){const r=e[t++];if(r){this.publicKeyVersion=e[t++];const i=r-1;this.publicKeyFingerprint=e.subarray(t,t+i),t+=i,this.publicKeyVersion>=5?this.publicKeyID.read(this.publicKeyFingerprint):this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8))}else this.publicKeyID=oa.wildcard()}else t+=this.publicKeyID.read(e.subarray(t,t+8));if(this.publicKeyAlgorithm=e[t++],this.encrypted=ss.parseEncSessionKeyParams(this.publicKeyAlgorithm,e.subarray(t)),this.publicKeyAlgorithm===T.publicKey.x25519||this.publicKeyAlgorithm===T.publicKey.x448)if(3===this.version)this.sessionKeyAlgorithm=T.write(T.symmetric,this.encrypted.C.algorithm);else if(null!==this.encrypted.C.algorithm)throw Error("Unexpected cleartext symmetric algorithm")}write(){const e=[new Uint8Array([this.version])];return 6===this.version?null!==this.publicKeyFingerprint?(e.push(new Uint8Array([this.publicKeyFingerprint.length+1,this.publicKeyVersion])),e.push(this.publicKeyFingerprint)):e.push(new Uint8Array([0])):e.push(this.publicKeyID.write()),e.push(new Uint8Array([this.publicKeyAlgorithm]),ss.serializeParams(this.publicKeyAlgorithm,this.encrypted)),F.concatUint8Array(e)}async encrypt(e){const t=T.write(T.publicKey,this.publicKeyAlgorithm),r=3===this.version?this.sessionKeyAlgorithm:null,i=5===e.version?e.getFingerprintBytes().subarray(0,20):e.getFingerprintBytes(),n=Ia(this.version,t,r,this.sessionKey);this.encrypted=await ss.publicKeyEncrypt(t,r,e.publicParams,n,i)}async decrypt(e,t){if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Decryption error");const r=t?Ia(this.version,this.publicKeyAlgorithm,t.sessionKeyAlgorithm,t.sessionKey):null,i=5===e.version?e.getFingerprintBytes().subarray(0,20):e.getFingerprintBytes(),n=await ss.publicKeyDecrypt(this.publicKeyAlgorithm,e.publicParams,e.privateParams,this.encrypted,i,r),{sessionKey:s,sessionKeyAlgorithm:a}=function(e,t,r,i){switch(t){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.elgamal:case T.publicKey.ecdh:{const t=r.subarray(0,r.length-2),n=r.subarray(r.length-2),s=F.writeChecksum(t.subarray(t.length%8)),a=s[0]===n[0]&s[1]===n[1],o=6===e?{sessionKeyAlgorithm:null,sessionKey:t}:{sessionKeyAlgorithm:t[0],sessionKey:t.subarray(1)};if(i){const t=a&o.sessionKeyAlgorithm===i.sessionKeyAlgorithm&o.sessionKey.length===i.sessionKey.length;return{sessionKey:F.selectUint8Array(t,o.sessionKey,i.sessionKey),sessionKeyAlgorithm:6===e?null:F.selectUint8(t,o.sessionKeyAlgorithm,i.sessionKeyAlgorithm)}}if(a&&(6===e||T.read(T.symmetric,o.sessionKeyAlgorithm)))return o;throw Error("Decryption error")}case T.publicKey.x25519:case T.publicKey.x448:return{sessionKeyAlgorithm:null,sessionKey:r};default:throw Error("Unsupported public key algorithm")}}(this.version,this.publicKeyAlgorithm,n,t);if(3===this.version){const e=this.publicKeyAlgorithm!==T.publicKey.x25519&&this.publicKeyAlgorithm!==T.publicKey.x448;if(this.sessionKeyAlgorithm=e?a:this.sessionKeyAlgorithm,s.length!==ss.getCipherParams(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}this.sessionKey=s}}function Ia(e,t,r,i){switch(t){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.elgamal:case T.publicKey.ecdh:return F.concatUint8Array([new Uint8Array(6===e?[]:[r]),i,F.writeChecksum(i.subarray(i.length%8))]);case T.publicKey.x25519:case T.publicKey.x448:return i;default:throw Error("Unsupported public key algorithm")}}class Ca{static get tag(){return T.packet.symEncryptedSessionKey}constructor(e=M){this.version=e.aeadProtect?6:4,this.sessionKey=null,this.sessionKeyEncryptionAlgorithm=null,this.sessionKeyAlgorithm=null,this.aeadAlgorithm=T.write(T.aead,e.preferredAEADAlgorithm),this.encrypted=null,this.s2k=null,this.iv=null}read(e){let t=0;if(this.version=e[t++],4!==this.version&&5!==this.version&&6!==this.version)throw new Gi(`Version ${this.version} of the SKESK packet is unsupported.`);6===this.version&&t++;const r=e[t++];this.version>=5&&(this.aeadAlgorithm=e[t++],6===this.version&&t++);const i=e[t++];if(this.s2k=ls(i),t+=this.s2k.read(e.subarray(t,e.length)),this.version>=5){const r=ss.getAEADMode(this.aeadAlgorithm);this.iv=e.subarray(t,t+=r.ivLength)}this.version>=5||t<e.length?(this.encrypted=e.subarray(t,e.length),this.sessionKeyEncryptionAlgorithm=r):this.sessionKeyAlgorithm=r}write(){const e=null===this.encrypted?this.sessionKeyAlgorithm:this.sessionKeyEncryptionAlgorithm;let t;const r=this.s2k.write();if(6===this.version){const i=r.length,n=3+i+this.iv.length;t=F.concatUint8Array([new Uint8Array([this.version,n,e,this.aeadAlgorithm,i]),r,this.iv,this.encrypted])}else 5===this.version?t=F.concatUint8Array([new Uint8Array([this.version,e,this.aeadAlgorithm]),r,this.iv,this.encrypted]):(t=F.concatUint8Array([new Uint8Array([this.version,e]),r]),null!==this.encrypted&&(t=F.concatUint8Array([t,this.encrypted])));return t}async decrypt(e){const t=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm,{blockSize:r,keySize:i}=ss.getCipherParams(t),n=await this.s2k.produceKey(e,i);if(this.version>=5){const e=ss.getAEADMode(this.aeadAlgorithm),r=new Uint8Array([192|Ca.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),s=6===this.version?await on(T.hash.sha256,n,new Uint8Array,r,i):n,a=await e(t,s);this.sessionKey=await a.decrypt(this.encrypted,this.iv,r)}else if(null!==this.encrypted){const e=await ss.mode.cfb.decrypt(t,n,this.encrypted,new Uint8Array(r));if(this.sessionKeyAlgorithm=T.write(T.symmetric,e[0]),this.sessionKey=e.subarray(1,e.length),this.sessionKey.length!==ss.getCipherParams(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}else this.sessionKey=n}async encrypt(e,t=M){const r=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm;this.sessionKeyEncryptionAlgorithm=r,this.s2k=ps(t),this.s2k.generateSalt();const{blockSize:i,keySize:n}=ss.getCipherParams(r),s=await this.s2k.produceKey(e,n);if(null===this.sessionKey&&(this.sessionKey=ss.generateSessionKey(this.sessionKeyAlgorithm)),this.version>=5){const e=ss.getAEADMode(this.aeadAlgorithm);this.iv=ss.random.getRandomBytes(e.ivLength);const t=new Uint8Array([192|Ca.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),i=6===this.version?await on(T.hash.sha256,s,new Uint8Array,t,n):s,a=await e(r,i);this.encrypted=await a.encrypt(this.sessionKey,this.iv,t)}else{const e=F.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]),this.sessionKey]);this.encrypted=await ss.mode.cfb.encrypt(r,s,e,new Uint8Array(i),t)}}}class Ba{static get tag(){return T.packet.publicKey}constructor(e=new Date,t=M){this.version=t.v6Keys?6:4,this.created=F.normalizeDate(e),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null}static fromSecretKeyPacket(e){const t=new Ba,{version:r,created:i,algorithm:n,publicParams:s,keyID:a,fingerprint:o}=e;return t.version=r,t.created=i,t.algorithm=n,t.publicParams=s,t.keyID=a,t.fingerprint=o,t}async read(e,t=M){let r=0;if(this.version=e[r++],5===this.version&&!t.enableParsingV5Entities)throw new Gi("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4===this.version||5===this.version||6===this.version){this.created=F.readDate(e.subarray(r,r+4)),r+=4,this.algorithm=e[r++],this.version>=5&&(r+=4);const{read:t,publicParams:i}=ss.parsePublicKeyParams(this.algorithm,e.subarray(r));if(6===this.version&&i.oid&&(i.oid.getName()===T.curve.curve25519Legacy||i.oid.getName()===T.curve.ed25519Legacy))throw Error("Legacy curve25519 cannot be used with v6 keys");return this.publicParams=i,r+=t,await this.computeFingerprintAndKeyID(),r}throw new Gi(`Version ${this.version} of the key packet is unsupported.`)}write(){const e=[];e.push(new Uint8Array([this.version])),e.push(F.writeDate(this.created)),e.push(new Uint8Array([this.algorithm]));const t=ss.serializeParams(this.algorithm,this.publicParams);return this.version>=5&&e.push(F.writeNumber(t.length,4)),e.push(t),F.concatUint8Array(e)}writeForHash(e){const t=this.writePublicKey(),r=149+e,i=e>=5?4:2;return F.concatUint8Array([new Uint8Array([r]),F.writeNumber(t.length,i),t])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new oa,this.version>=5)this.keyID.read(this.fingerprint.subarray(0,8));else{if(4!==this.version)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20))}}async computeFingerprint(){const e=this.writeForHash(this.version);if(this.version>=5)this.fingerprint=await ss.hash.sha256(e);else{if(4!==this.version)throw Error("Unsupported key version");this.fingerprint=await ss.hash.sha1(e)}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return F.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(e){return this.version===e.version&&F.equalsUint8Array(this.writePublicKey(),e.writePublicKey())}getAlgorithmInfo(){const e={};e.algorithm=T.read(T.publicKey,this.algorithm);const t=this.publicParams.n||this.publicParams.p;return t?e.bits=F.uint8ArrayBitLength(t):this.publicParams.oid&&(e.curve=this.publicParams.oid.getName()),e}}Ba.prototype.readPublicKey=Ba.prototype.read,Ba.prototype.writePublicKey=Ba.prototype.write;const Ta=/*#__PURE__*/F.constructAllowedPackets([aa,wa,ga,ya]);class Ma{static get tag(){return T.packet.symmetricallyEncryptedData}constructor(){this.encrypted=null,this.packets=null}read(e){this.encrypted=e}write(){return this.encrypted}async decrypt(e,t,r=M){if(!r.allowUnauthenticatedMessages)throw Error("Message is not authenticated.");const{blockSize:i}=ss.getCipherParams(e),n=await U(K(this.encrypted)),s=await ss.mode.cfb.decrypt(e,t,n.subarray(i+2),n.subarray(2,i+2));this.packets=await fa.fromBinary(s,Ta,r)}async encrypt(e,t,r=M){const i=this.packets.write(),{blockSize:n}=ss.getCipherParams(e),s=await ss.getPrefixRandom(e),a=await ss.mode.cfb.encrypt(e,t,s,new Uint8Array(n),r),o=await ss.mode.cfb.encrypt(e,t,i,a.subarray(2),r);this.encrypted=F.concat([a,o])}}class La{static get tag(){return T.packet.marker}read(e){return 80===e[0]&&71===e[1]&&80===e[2]}write(){return new Uint8Array([80,71,80])}}class Fa extends Ba{static get tag(){return T.packet.publicSubkey}constructor(e,t){super(e,t)}static fromSecretSubkeyPacket(e){const t=new Fa,{version:r,created:i,algorithm:n,publicParams:s,keyID:a,fingerprint:o}=e;return t.version=r,t.created=i,t.algorithm=n,t.publicParams=s,t.keyID=a,t.fingerprint=o,t}}class Ra{static get tag(){return T.packet.userAttribute}constructor(){this.attributes=[]}read(e){let t=0;for(;t<e.length;){const r=Ri(e.subarray(t,e.length));t+=r.offset,this.attributes.push(F.uint8ArrayToString(e.subarray(t,t+r.len))),t+=r.len}}write(){const e=[];for(let t=0;t<this.attributes.length;t++)e.push(Ni(this.attributes[t].length)),e.push(F.stringToUint8Array(this.attributes[t]));return F.concatUint8Array(e)}equals(e){return!!(e&&e instanceof Ra)&&this.attributes.every((function(t,r){return t===e.attributes[r]}))}}class Na extends Ba{static get tag(){return T.packet.secretKey}constructor(e=new Date,t=M){super(e,t),this.keyMaterial=null,this.isEncrypted=null,this.s2kUsage=0,this.s2k=null,this.symmetric=null,this.aead=null,this.isLegacyAEAD=null,this.privateParams=null,this.usedModernAEAD=null}async read(e,t=M){let r=await this.readPublicKey(e,t);const i=r;this.s2kUsage=e[r++],5===this.version&&r++,6===this.version&&this.s2kUsage&&r++;try{if(255===this.s2kUsage||254===this.s2kUsage||253===this.s2kUsage){this.symmetric=e[r++],253===this.s2kUsage&&(this.aead=e[r++]),6===this.version&&r++;const t=e[r++];if(this.s2k=ls(t),r+=this.s2k.read(e.subarray(r,e.length)),"gnu-dummy"===this.s2k.type)return}else this.s2kUsage&&(this.symmetric=this.s2kUsage);this.s2kUsage&&(this.isLegacyAEAD=253===this.s2kUsage&&(5===this.version||4===this.version&&t.parseAEADEncryptedV4KeysAsLegacy),253!==this.s2kUsage||this.isLegacyAEAD?(this.iv=e.subarray(r,r+ss.getCipherParams(this.symmetric).blockSize),this.usedModernAEAD=!1):(this.iv=e.subarray(r,r+ss.getAEADMode(this.aead).ivLength),this.usedModernAEAD=!0),r+=this.iv.length)}catch(t){if(!this.s2kUsage)throw t;this.unparseableKeyMaterial=e.subarray(i),this.isEncrypted=!0}if(5===this.version&&(r+=4),this.keyMaterial=e.subarray(r),this.isEncrypted=!!this.s2kUsage,!this.isEncrypted){let e;if(6===this.version)e=this.keyMaterial;else if(e=this.keyMaterial.subarray(0,-2),!F.equalsUint8Array(F.writeChecksum(e),this.keyMaterial.subarray(-2)))throw Error("Key checksum mismatch");try{const{read:t,privateParams:r}=ss.parsePrivateKeyParams(this.algorithm,e,this.publicParams);if(t<e.length)throw Error("Error reading MPIs");this.privateParams=r}catch(e){if(e instanceof Gi)throw e;throw Error("Error reading MPIs")}}}write(){const e=this.writePublicKey();if(this.unparseableKeyMaterial)return F.concatUint8Array([e,this.unparseableKeyMaterial]);const t=[e];t.push(new Uint8Array([this.s2kUsage]));const r=[];if(255===this.s2kUsage||254===this.s2kUsage||253===this.s2kUsage){r.push(this.symmetric),253===this.s2kUsage&&r.push(this.aead);const e=this.s2k.write();6===this.version&&r.push(e.length),r.push(...e)}return this.s2kUsage&&"gnu-dummy"!==this.s2k.type&&r.push(...this.iv),(5===this.version||6===this.version&&this.s2kUsage)&&t.push(new Uint8Array([r.length])),t.push(new Uint8Array(r)),this.isDummy()||(this.s2kUsage||(this.keyMaterial=ss.serializeParams(this.algorithm,this.privateParams)),5===this.version&&t.push(F.writeNumber(this.keyMaterial.length,4)),t.push(this.keyMaterial),this.s2kUsage||6===this.version||t.push(F.writeChecksum(this.keyMaterial))),F.concatUint8Array(t)}isDecrypted(){return!1===this.isEncrypted}isMissingSecretKeyMaterial(){return void 0!==this.unparseableKeyMaterial||this.isDummy()}isDummy(){return!(!this.s2k||"gnu-dummy"!==this.s2k.type)}makeDummy(e=M){this.isDummy()||(this.isDecrypted()&&this.clearPrivateParams(),delete this.unparseableKeyMaterial,this.isEncrypted=null,this.keyMaterial=null,this.s2k=ls(T.s2k.gnu,e),this.s2k.algorithm=0,this.s2k.c=0,this.s2k.type="gnu-dummy",this.s2kUsage=254,this.symmetric=T.symmetric.aes256,this.isLegacyAEAD=null,this.usedModernAEAD=null)}async encrypt(e,t=M){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key packet is already encrypted");if(!e)throw Error("A non-empty passphrase is required for key encryption.");this.s2k=ps(t),this.s2k.generateSalt();const r=ss.serializeParams(this.algorithm,this.privateParams);this.symmetric=T.symmetric.aes256;const{blockSize:i}=ss.getCipherParams(this.symmetric);if(t.aeadProtect){this.s2kUsage=253,this.aead=t.preferredAEADAlgorithm;const n=ss.getAEADMode(this.aead);this.isLegacyAEAD=5===this.version,this.usedModernAEAD=!this.isLegacyAEAD;const s=ji(this.constructor.tag),a=await za(this.version,this.s2k,e,this.symmetric,this.aead,s,this.isLegacyAEAD),o=await n(this.symmetric,a);this.iv=this.isLegacyAEAD?ss.random.getRandomBytes(i):ss.random.getRandomBytes(n.ivLength);const c=this.isLegacyAEAD?new Uint8Array:F.concatUint8Array([s,this.writePublicKey()]);this.keyMaterial=await o.encrypt(r,this.iv.subarray(0,n.ivLength),c)}else{this.s2kUsage=254,this.usedModernAEAD=!1;const n=await za(this.version,this.s2k,e,this.symmetric);this.iv=ss.random.getRandomBytes(i),this.keyMaterial=await ss.mode.cfb.encrypt(this.symmetric,n,F.concatUint8Array([r,await ss.hash.sha1(r,t)]),this.iv,t)}}async decrypt(e){if(this.isDummy())return!1;if(this.unparseableKeyMaterial)throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");if(this.isDecrypted())throw Error("Key packet is already decrypted.");let t;const r=ji(this.constructor.tag);if(254!==this.s2kUsage&&253!==this.s2kUsage)throw 255===this.s2kUsage?Error("Encrypted private key is authenticated using an insecure two-byte hash"):Error("Private key is encrypted using an insecure S2K function: unsalted MD5");let i;if(t=await za(this.version,this.s2k,e,this.symmetric,this.aead,r,this.isLegacyAEAD),253===this.s2kUsage){const e=ss.getAEADMode(this.aead),n=await e(this.symmetric,t);try{const t=this.isLegacyAEAD?new Uint8Array:F.concatUint8Array([r,this.writePublicKey()]);i=await n.decrypt(this.keyMaterial,this.iv.subarray(0,e.ivLength),t)}catch(e){if("Authentication tag mismatch"===e.message)throw Error("Incorrect key passphrase: "+e.message);throw e}}else{const e=await ss.mode.cfb.decrypt(this.symmetric,t,this.keyMaterial,this.iv);i=e.subarray(0,-20);const r=await ss.hash.sha1(i);if(!F.equalsUint8Array(r,e.subarray(-20)))throw Error("Incorrect key passphrase")}try{const{privateParams:e}=ss.parsePrivateKeyParams(this.algorithm,i,this.publicParams);this.privateParams=e}catch(e){throw Error("Error reading MPIs")}this.isEncrypted=!1,this.keyMaterial=null,this.s2kUsage=0,this.aead=null,this.symmetric=null,this.isLegacyAEAD=null}async validate(){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key is not decrypted");if(this.usedModernAEAD)return;let e;try{e=await ss.validateParams(this.algorithm,this.publicParams,this.privateParams)}catch(t){e=!1}if(!e)throw Error("Key is invalid")}async generate(e,t){if(6===this.version&&(this.algorithm===T.publicKey.ecdh&&t===T.curve.curve25519Legacy||this.algorithm===T.publicKey.eddsaLegacy))throw Error(`Cannot generate v6 keys of type 'ecc' with curve ${t}. Generate a key of type 'curve25519' instead`);const{privateParams:r,publicParams:i}=await ss.generateParams(this.algorithm,e,t);this.privateParams=r,this.publicParams=i,this.isEncrypted=!1}clearPrivateParams(){this.isMissingSecretKeyMaterial()||(Object.keys(this.privateParams).forEach((e=>{this.privateParams[e].fill(0),delete this.privateParams[e]})),this.privateParams=null,this.isEncrypted=!0)}}async function za(e,t,r,i,n,s,a){if("argon2"===t.type&&!n)throw Error("Using Argon2 S2K without AEAD is not allowed");if("simple"===t.type&&6===e)throw Error("Using Simple S2K with version 6 keys is not allowed");const{keySize:o}=ss.getCipherParams(i),c=await t.produceKey(r,o);if(!n||5===e||a)return c;const u=F.concatUint8Array([s,new Uint8Array([e,i,n])]);return on(T.hash.sha256,c,new Uint8Array,u,o)}class ja{static get tag(){return T.packet.userID}constructor(){this.userID="",this.name="",this.email="",this.comment=""}static fromObject(e){if(F.isString(e)||e.name&&!F.isString(e.name)||e.email&&!F.isEmailAddress(e.email)||e.comment&&!F.isString(e.comment))throw Error("Invalid user ID format");const t=new ja;Object.assign(t,e);const r=[];return t.name&&r.push(t.name),t.comment&&r.push(`(${t.comment})`),t.email&&r.push(`<${t.email}>`),t.userID=r.join(" "),t}read(e,t=M){const r=F.decodeUTF8(e);if(r.length>t.maxUserIDLength)throw Error("User ID string is too long");const i=/^(?<name>[^()]+\s+)?(?<comment>\([^()]+\)\s+)?(?<email><\S+@\S+>)$/.exec(r);if(null!==i){const{name:e,comment:t,email:r}=i.groups;this.comment=t?.replace(/^\(|\)|\s$/g,"").trim()||"",this.name=e?.trim()||"",this.email=r.substring(1,r.length-1)}else/^[^\s@]+@[^\s@]+$/.test(r)&&(this.email=r);this.userID=r}write(){return F.encodeUTF8(this.userID)}equals(e){return e&&e.userID===this.userID}}class Oa extends Na{static get tag(){return T.packet.secretSubkey}constructor(e=new Date,t=M){super(e,t)}}class Ha{static get tag(){return T.packet.trust}read(){throw new Gi("Trust packets are not supported")}write(){throw new Gi("Trust packets are not supported")}}class _a{static get tag(){return T.packet.padding}constructor(){this.padding=null}read(e){}write(){return this.padding}async createPadding(e){this.padding=await ss.random.getRandomBytes(e)}}const Ga=/*#__PURE__*/F.constructAllowedPackets([ya]);class qa{constructor(e){this.packets=e||new fa}write(){return this.packets.write()}armor(e=M){const t=this.packets.some((e=>e.constructor.tag===ya.tag&&6!==e.version));return Z(T.armor.signature,this.write(),void 0,void 0,void 0,t,e)}getSigningKeyIDs(){return this.packets.map((e=>e.issuerKeyID))}}async function Va({armoredSignature:e,binarySignature:t,config:r,...i}){r={...M,...r};let n=e||t;if(!n)throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");if(e&&!F.isString(e))throw Error("readSignature: options.armoredSignature must be a string");if(t&&!F.isUint8Array(t))throw Error("readSignature: options.binarySignature must be a Uint8Array");const s=Object.keys(i);if(s.length>0)throw Error("Unknown option: "+s.join(", "));if(e){const{type:e,data:t}=await Y(n);if(e!==T.armor.signature)throw Error("Armored text not of type signature");n=t}const a=await fa.fromBinary(n,Ga,r);return new qa(a)}async function Wa(e,t){const r=new Oa(e.date,t);return r.packets=null,r.algorithm=T.write(T.publicKey,e.algorithm),await r.generate(e.rsaBits,e.curve),await r.computeFingerprintAndKeyID(),r}async function $a(e,t){const r=new Na(e.date,t);return r.packets=null,r.algorithm=T.write(T.publicKey,e.algorithm),await r.generate(e.rsaBits,e.curve,e.config),await r.computeFingerprintAndKeyID(),r}async function Qa(e,t,r,i,n=new Date,s){let a,o;for(let c=e.length-1;c>=0;c--)try{(!a||e[c].created>=a.created)&&(await e[c].verify(t,r,i,n,void 0,s),a=e[c])}catch(e){o=e}if(!a)throw F.wrapError(`Could not find valid ${T.read(T.signature,r)} signature in key ${t.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,((e,t,r)=>t+" "+r.toLowerCase())),o);return a}function Xa(e,t,r=new Date){const i=F.normalizeDate(r);if(null!==i){const r=to(e,t);return!(e.created<=i&&i<r)}return!1}async function Ya(e,t,r,i){const n={};n.key=t,n.bind=e;const s={signatureType:T.signature.subkeyBinding};r.sign?(s.keyFlags=[T.keyFlags.signData],s.embeddedSignature=await Za(n,[],e,{signatureType:T.signature.keyBinding},r.date,void 0,void 0,void 0,i)):s.keyFlags=[T.keyFlags.encryptCommunication|T.keyFlags.encryptStorage],r.keyExpirationTime>0&&(s.keyExpirationTime=r.keyExpirationTime,s.keyNeverExpires=!1);return await Za(n,[],t,s,r.date,void 0,void 0,void 0,i)}async function Za(e,t,r,i,n,s,a=[],o=!1,c){if(r.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!r.isDecrypted())throw Error("Signing key is not decrypted.");const u=new ya;return Object.assign(u,i),u.publicKeyAlgorithm=r.algorithm,u.hashAlgorithm=await async function(e,t,r=new Date,i=[],n){const s=T.hash.sha256,a=n.preferredHashAlgorithm,o=await Promise.all(e.map((async(e,t)=>(await e.getPrimarySelfSignature(r,i[t],n)).preferredHashAlgorithms))),c=new Map;for(const e of o)for(const t of e)try{const e=T.write(T.hash,t);c.set(e,c.has(e)?c.get(e)+1:1)}catch{}const u=t=>0===e.length||c.get(t)===e.length||t===s,h=()=>{if(0===c.size)return s;const e=Array.from(c.keys()).filter((e=>u(e))).sort(((e,t)=>ss.hash.getHashByteLength(e)-ss.hash.getHashByteLength(t)))[0];return ss.hash.getHashByteLength(e)>=ss.hash.getHashByteLength(s)?e:s};if(new Set([T.publicKey.ecdsa,T.publicKey.eddsaLegacy,T.publicKey.ed25519,T.publicKey.ed448]).has(t.algorithm)){const e=ss.getPreferredCurveHashAlgo(t.algorithm,t.publicParams.oid),r=u(a),i=ss.hash.getHashByteLength(a)>=ss.hash.getHashByteLength(e);if(r&&i)return a;{const t=h();return ss.hash.getHashByteLength(t)>=ss.hash.getHashByteLength(e)?t:e}}return u(a)?a:h()}(t,r,n,s,c),u.rawNotations=[...a],await u.sign(r,e,n,o,c),u}async function Ja(e,t,r,i=new Date,n){(e=e[r])&&(t[r].length?await Promise.all(e.map((async function(e){e.isExpired(i)||n&&!await n(e)||t[r].some((function(t){return F.equalsUint8Array(t.writeParams(),e.writeParams())}))||t[r].push(e)}))):t[r]=e)}async function eo(e,t,r,i,n,s,a=new Date,o){s=s||e;const c=[];return await Promise.all(i.map((async function(e){try{if(!n||e.issuerKeyID.equals(n.issuerKeyID)){const i=![T.reasonForRevocation.keyRetired,T.reasonForRevocation.keySuperseded,T.reasonForRevocation.userIDInvalid].includes(e.reasonForRevocationFlag);await e.verify(s,t,r,i?null:a,!1,o),c.push(e.issuerKeyID)}}catch(e){}}))),n?(n.revoked=!!c.some((e=>e.equals(n.issuerKeyID)))||(n.revoked||!1),n.revoked):c.length>0}function to(e,t){let r;return!1===t.keyNeverExpires&&(r=e.created.getTime()+1e3*t.keyExpirationTime),r?new Date(r):1/0}function ro(e,t={}){switch(e.type=e.type||t.type,e.curve=e.curve||t.curve,e.rsaBits=e.rsaBits||t.rsaBits,e.keyExpirationTime=void 0!==e.keyExpirationTime?e.keyExpirationTime:t.keyExpirationTime,e.passphrase=F.isString(e.passphrase)?e.passphrase:t.passphrase,e.date=e.date||t.date,e.sign=e.sign||!1,e.type){case"ecc":try{e.curve=T.write(T.curve,e.curve)}catch(e){throw Error("Unknown curve")}e.curve!==T.curve.ed25519Legacy&&e.curve!==T.curve.curve25519Legacy&&"ed25519"!==e.curve&&"curve25519"!==e.curve||(e.curve=e.sign?T.curve.ed25519Legacy:T.curve.curve25519Legacy),e.sign?e.algorithm=e.curve===T.curve.ed25519Legacy?T.publicKey.eddsaLegacy:T.publicKey.ecdsa:e.algorithm=T.publicKey.ecdh;break;case"curve25519":e.algorithm=e.sign?T.publicKey.ed25519:T.publicKey.x25519;break;case"curve448":e.algorithm=e.sign?T.publicKey.ed448:T.publicKey.x448;break;case"rsa":e.algorithm=T.publicKey.rsaEncryptSign;break;default:throw Error("Unsupported key type "+e.type)}return e}function io(e,t,r){switch(e.algorithm){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:case T.publicKey.dsa:case T.publicKey.ecdsa:case T.publicKey.eddsaLegacy:case T.publicKey.ed25519:case T.publicKey.ed448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&T.keyFlags.signData);default:return!1}}function no(e,t,r){switch(e.algorithm){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:case T.publicKey.elgamal:case T.publicKey.ecdh:case T.publicKey.x25519:case T.publicKey.x448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&T.keyFlags.encryptCommunication)||!!(t.keyFlags[0]&T.keyFlags.encryptStorage);default:return!1}}function so(e,t,r){if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");switch(e.algorithm){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaEncrypt:case T.publicKey.elgamal:case T.publicKey.ecdh:case T.publicKey.x25519:case T.publicKey.x448:return!(!(!t.keyFlags||!!(t.keyFlags[0]&T.keyFlags.signData))||!r.allowInsecureDecryptionWithSigningKeys)||(!t.keyFlags||!!(t.keyFlags[0]&T.keyFlags.encryptCommunication)||!!(t.keyFlags[0]&T.keyFlags.encryptStorage));default:return!1}}function ao(e,t){const r=T.write(T.publicKey,e.algorithm),i=e.getAlgorithmInfo();if(t.rejectPublicKeyAlgorithms.has(r))throw Error(i.algorithm+" keys are considered too weak.");switch(r){case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:case T.publicKey.rsaEncrypt:if(i.bits<t.minRSABits)throw Error(`RSA keys shorter than ${t.minRSABits} bits are considered too weak.`);break;case T.publicKey.ecdsa:case T.publicKey.eddsaLegacy:case T.publicKey.ecdh:if(t.rejectCurves.has(i.curve))throw Error(`Support for ${i.algorithm} keys using curve ${i.curve} is disabled.`)}}class oo{constructor(e,t){this.userID=e.constructor.tag===T.packet.userID?e:null,this.userAttribute=e.constructor.tag===T.packet.userAttribute?e:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=t}toPacketList(){const e=new fa;return e.push(this.userID||this.userAttribute),e.push(...this.revocationSignatures),e.push(...this.selfCertifications),e.push(...this.otherCertifications),e}clone(){const e=new oo(this.userID||this.userAttribute,this.mainKey);return e.selfCertifications=[...this.selfCertifications],e.otherCertifications=[...this.otherCertifications],e.revocationSignatures=[...this.revocationSignatures],e}async certify(e,t,r){const i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i},s=new oo(n.userID||n.userAttribute,this.mainKey);return s.otherCertifications=await Promise.all(e.map((async function(e){if(!e.isPrivate())throw Error("Need private key for signing");if(e.hasSameFingerprintAs(i))throw Error("The user's own key can only be used for self-certifications");const s=await e.getSigningKey(void 0,t,void 0,r);return Za(n,[e],s.keyPacket,{signatureType:T.signature.certGeneric,keyFlags:[T.keyFlags.certifyKeys|T.keyFlags.signData]},t,void 0,void 0,void 0,r)}))),await s.update(this,t,r),s}async isRevoked(e,t,r=new Date,i=M){const n=this.mainKey.keyPacket;return eo(n,T.signature.certRevocation,{key:n,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,e,t,r,i)}async verifyCertificate(e,t,r=new Date,i){const n=this,s=this.mainKey.keyPacket,a={userID:this.userID,userAttribute:this.userAttribute,key:s},{issuerKeyID:o}=e,c=t.filter((e=>e.getKeys(o).length>0));return 0===c.length?null:(await Promise.all(c.map((async t=>{const s=await t.getSigningKey(o,e.created,void 0,i);if(e.revoked||await n.isRevoked(e,s.keyPacket,r,i))throw Error("User certificate is revoked");try{await e.verify(s.keyPacket,T.signature.certGeneric,a,r,void 0,i)}catch(e){throw F.wrapError("User certificate is invalid",e)}}))),!0)}async verifyAllCertifications(e,t=new Date,r){const i=this,n=this.selfCertifications.concat(this.otherCertifications);return Promise.all(n.map((async n=>({keyID:n.issuerKeyID,valid:await i.verifyCertificate(n,e,t,r).catch((()=>!1))}))))}async verify(e=new Date,t){if(!this.selfCertifications.length)throw Error("No self-certifications found");const r=this,i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i};let s;for(let a=this.selfCertifications.length-1;a>=0;a--)try{const s=this.selfCertifications[a];if(s.revoked||await r.isRevoked(s,void 0,e,t))throw Error("Self-certification is revoked");try{await s.verify(i,T.signature.certGeneric,n,e,void 0,t)}catch(e){throw F.wrapError("Self-certification is invalid",e)}return!0}catch(e){s=e}throw s}async update(e,t,r){const i=this.mainKey.keyPacket,n={userID:this.userID,userAttribute:this.userAttribute,key:i};await Ja(e,this,"selfCertifications",t,(async function(e){try{return await e.verify(i,T.signature.certGeneric,n,t,!1,r),!0}catch(e){return!1}})),await Ja(e,this,"otherCertifications",t),await Ja(e,this,"revocationSignatures",t,(function(e){return eo(i,T.signature.certRevocation,n,[e],void 0,void 0,t,r)}))}async revoke(e,{flag:t=T.reasonForRevocation.noReason,string:r=""}={},i=new Date,n=M){const s={userID:this.userID,userAttribute:this.userAttribute,key:e},a=new oo(s.userID||s.userAttribute,this.mainKey);return a.revocationSignatures.push(await Za(s,[],e,{signatureType:T.signature.certRevocation,reasonForRevocationFlag:T.write(T.reasonForRevocation,t),reasonForRevocationString:r},i,void 0,void 0,!1,n)),await a.update(this),a}}class co{constructor(e,t){this.keyPacket=e,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=t}toPacketList(){const e=new fa;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.bindingSignatures),e}clone(){const e=new co(this.keyPacket,this.mainKey);return e.bindingSignatures=[...this.bindingSignatures],e.revocationSignatures=[...this.revocationSignatures],e}async isRevoked(e,t,r=new Date,i=M){const n=this.mainKey.keyPacket;return eo(n,T.signature.subkeyRevocation,{key:n,bind:this.keyPacket},this.revocationSignatures,e,t,r,i)}async verify(e=new Date,t=M){const r=this.mainKey.keyPacket,i={key:r,bind:this.keyPacket},n=await Qa(this.bindingSignatures,r,T.signature.subkeyBinding,i,e,t);if(n.revoked||await this.isRevoked(n,null,e,t))throw Error("Subkey is revoked");if(Xa(this.keyPacket,n,e))throw Error("Subkey is expired");return n}async getExpirationTime(e=new Date,t=M){const r=this.mainKey.keyPacket,i={key:r,bind:this.keyPacket};let n;try{n=await Qa(this.bindingSignatures,r,T.signature.subkeyBinding,i,e,t)}catch(e){return null}const s=to(this.keyPacket,n),a=n.getExpirationTime();return s<a?s:a}async update(e,t=new Date,r=M){const i=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(e))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===T.packet.publicSubkey&&e.keyPacket.constructor.tag===T.packet.secretSubkey&&(this.keyPacket=e.keyPacket);const n=this,s={key:i,bind:n.keyPacket};await Ja(e,this,"bindingSignatures",t,(async function(e){for(let t=0;t<n.bindingSignatures.length;t++)if(n.bindingSignatures[t].issuerKeyID.equals(e.issuerKeyID))return e.created>n.bindingSignatures[t].created&&(n.bindingSignatures[t]=e),!1;try{return await e.verify(i,T.signature.subkeyBinding,s,t,void 0,r),!0}catch(e){return!1}})),await Ja(e,this,"revocationSignatures",t,(function(e){return eo(i,T.signature.subkeyRevocation,s,[e],void 0,void 0,t,r)}))}async revoke(e,{flag:t=T.reasonForRevocation.noReason,string:r=""}={},i=new Date,n=M){const s={key:e,bind:this.keyPacket},a=new co(this.keyPacket,this.mainKey);return a.revocationSignatures.push(await Za(s,[],e,{signatureType:T.signature.subkeyRevocation,reasonForRevocationFlag:T.write(T.reasonForRevocation,t),reasonForRevocationString:r},i,void 0,void 0,!1,n)),await a.update(this),a}hasSameFingerprintAs(e){return this.keyPacket.hasSameFingerprintAs(e.keyPacket||e)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach((e=>{co.prototype[e]=function(){return this.keyPacket[e]()}}));const uo=/*#__PURE__*/F.constructAllowedPackets([ya]),ho=new Set([T.packet.publicKey,T.packet.privateKey]),yo=new Set([T.packet.publicKey,T.packet.privateKey,T.packet.publicSubkey,T.packet.privateSubkey]);class lo{packetListToStructure(e,t=new Set){let r,i,n,s;for(const a of e){if(a instanceof Vi){yo.has(a.tag)&&!s&&(s=ho.has(a.tag)?ho:yo);continue}const e=a.constructor.tag;if(s){if(!s.has(e))continue;s=null}if(t.has(e))throw Error("Unexpected packet type: "+e);switch(e){case T.packet.publicKey:case T.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=a,i=this.getKeyID(),!i)throw Error("Missing Key ID");break;case T.packet.userID:case T.packet.userAttribute:r=new oo(a,this),this.users.push(r);break;case T.packet.publicSubkey:case T.packet.secretSubkey:r=null,n=new co(a,this),this.subkeys.push(n);break;case T.packet.signature:switch(a.signatureType){case T.signature.certGeneric:case T.signature.certPersona:case T.signature.certCasual:case T.signature.certPositive:if(!r){F.printDebug("Dropping certification signatures without preceding user packet");continue}a.issuerKeyID.equals(i)?r.selfCertifications.push(a):r.otherCertifications.push(a);break;case T.signature.certRevocation:r?r.revocationSignatures.push(a):this.directSignatures.push(a);break;case T.signature.key:this.directSignatures.push(a);break;case T.signature.subkeyBinding:if(!n){F.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}n.bindingSignatures.push(a);break;case T.signature.keyRevocation:this.revocationSignatures.push(a);break;case T.signature.subkeyRevocation:if(!n){F.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}n.revocationSignatures.push(a)}}}}toPacketList(){const e=new fa;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.directSignatures),this.users.map((t=>e.push(...t.toPacketList()))),this.subkeys.map((t=>e.push(...t.toPacketList()))),e}clone(e=!1){const t=new this.constructor(this.toPacketList());return e&&t.getKeys().forEach((e=>{if(e.keyPacket=Object.create(Object.getPrototypeOf(e.keyPacket),Object.getOwnPropertyDescriptors(e.keyPacket)),!e.keyPacket.isDecrypted())return;const t={};Object.keys(e.keyPacket.privateParams).forEach((r=>{t[r]=new Uint8Array(e.keyPacket.privateParams[r])})),e.keyPacket.privateParams=t})),t}getSubkeys(e=null){return this.subkeys.filter((t=>!e||t.getKeyID().equals(e,!0)))}getKeys(e=null){const t=[];return e&&!this.getKeyID().equals(e,!0)||t.push(this),t.concat(this.getSubkeys(e))}getKeyIDs(){return this.getKeys().map((e=>e.getKeyID()))}getUserIDs(){return this.users.map((e=>e.userID?e.userID.userID:null)).filter((e=>null!==e))}write(){return this.toPacketList().write()}async getSigningKey(e=null,t=new Date,r={},i=M){await this.verifyPrimaryKey(t,r,i);const n=this.keyPacket;try{ao(n,i)}catch(e){throw F.wrapError("Could not verify primary key",e)}const s=this.subkeys.slice().sort(((e,t)=>t.keyPacket.created-e.keyPacket.created));let a;for(const r of s)if(!e||r.getKeyID().equals(e))try{await r.verify(t,i);const e={key:n,bind:r.keyPacket},s=await Qa(r.bindingSignatures,n,T.signature.subkeyBinding,e,t,i);if(!io(r.keyPacket,s,i))continue;if(!s.embeddedSignature)throw Error("Missing embedded signature");return await Qa([s.embeddedSignature],r.keyPacket,T.signature.keyBinding,e,t,i),ao(r.keyPacket,i),r}catch(e){a=e}try{const s=await this.getPrimarySelfSignature(t,r,i);if((!e||n.getKeyID().equals(e))&&io(n,s,i))return ao(n,i),this}catch(e){a=e}throw F.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),a)}async getEncryptionKey(e,t=new Date,r={},i=M){await this.verifyPrimaryKey(t,r,i);const n=this.keyPacket;try{ao(n,i)}catch(e){throw F.wrapError("Could not verify primary key",e)}const s=this.subkeys.slice().sort(((e,t)=>t.keyPacket.created-e.keyPacket.created));let a;for(const r of s)if(!e||r.getKeyID().equals(e))try{await r.verify(t,i);const e={key:n,bind:r.keyPacket},s=await Qa(r.bindingSignatures,n,T.signature.subkeyBinding,e,t,i);if(no(r.keyPacket,s,i))return ao(r.keyPacket,i),r}catch(e){a=e}try{const s=await this.getPrimarySelfSignature(t,r,i);if((!e||n.getKeyID().equals(e))&&no(n,s,i))return ao(n,i),this}catch(e){a=e}throw F.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),a)}async isRevoked(e,t,r=new Date,i=M){return eo(this.keyPacket,T.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,e,t,r,i)}async verifyPrimaryKey(e=new Date,t={},r=M){const i=this.keyPacket;if(await this.isRevoked(null,null,e,r))throw Error("Primary key is revoked");if(Xa(i,await this.getPrimarySelfSignature(e,t,r),e))throw Error("Primary key is expired");if(6!==i.version){const t=await Qa(this.directSignatures,i,T.signature.key,{key:i},e,r).catch((()=>{}));if(t&&Xa(i,t,e))throw Error("Primary key is expired")}}async getExpirationTime(e,t=M){let r;try{const i=await this.getPrimarySelfSignature(null,e,t),n=to(this.keyPacket,i),s=i.getExpirationTime(),a=6!==this.keyPacket.version&&await Qa(this.directSignatures,this.keyPacket,T.signature.key,{key:this.keyPacket},null,t).catch((()=>{}));if(a){const e=to(this.keyPacket,a);r=Math.min(n,s,e)}else r=n<s?n:s}catch(e){r=null}return F.normalizeDate(r)}async getPrimarySelfSignature(e=new Date,t={},r=M){const i=this.keyPacket;if(6===i.version)return Qa(this.directSignatures,i,T.signature.key,{key:i},e,r);const{selfCertification:n}=await this.getPrimaryUser(e,t,r);return n}async getPrimaryUser(e=new Date,t={},r=M){const i=this.keyPacket,n=[];let s;for(let a=0;a<this.users.length;a++)try{const s=this.users[a];if(!s.userID)continue;if(void 0!==t.name&&s.userID.name!==t.name||void 0!==t.email&&s.userID.email!==t.email||void 0!==t.comment&&s.userID.comment!==t.comment)throw Error("Could not find user that matches that user ID");const o={userID:s.userID,key:i},c=await Qa(s.selfCertifications,i,T.signature.certGeneric,o,e,r);n.push({index:a,user:s,selfCertification:c})}catch(e){s=e}if(!n.length)throw s||Error("Could not find primary user");await Promise.all(n.map((async function(t){return t.selfCertification.revoked||t.user.isRevoked(t.selfCertification,null,e,r)})));const a=n.sort((function(e,t){const r=e.selfCertification,i=t.selfCertification;return i.revoked-r.revoked||r.isPrimaryUserID-i.isPrimaryUserID||r.created-i.created})).pop(),{user:o,selfCertification:c}=a;if(c.revoked||await o.isRevoked(c,null,e,r))throw Error("Primary user is revoked");return a}async update(e,t=new Date,r=M){if(!this.hasSameFingerprintAs(e))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&e.isPrivate()){if(!(this.subkeys.length===e.subkeys.length&&this.subkeys.every((t=>e.subkeys.some((e=>t.hasSameFingerprintAs(e)))))))throw Error("Cannot update public key with private key if subkeys mismatch");return e.update(this,r)}const i=this.clone();return await Ja(e,i,"revocationSignatures",t,(n=>eo(i.keyPacket,T.signature.keyRevocation,i,[n],null,e.keyPacket,t,r))),await Ja(e,i,"directSignatures",t),await Promise.all(e.users.map((async e=>{const n=i.users.filter((t=>e.userID&&e.userID.equals(t.userID)||e.userAttribute&&e.userAttribute.equals(t.userAttribute)));if(n.length>0)await Promise.all(n.map((i=>i.update(e,t,r))));else{const t=e.clone();t.mainKey=i,i.users.push(t)}}))),await Promise.all(e.subkeys.map((async e=>{const n=i.subkeys.filter((t=>t.hasSameFingerprintAs(e)));if(n.length>0)await Promise.all(n.map((i=>i.update(e,t,r))));else{const t=e.clone();t.mainKey=i,i.subkeys.push(t)}}))),i}async getRevocationCertificate(e=new Date,t=M){const r={key:this.keyPacket},i=await Qa(this.revocationSignatures,this.keyPacket,T.signature.keyRevocation,r,e,t),n=new fa;n.push(i);const s=6!==this.keyPacket.version;return Z(T.armor.publicKey,n.write(),null,null,"This is a revocation certificate",s,t)}async applyRevocationCertificate(e,t=new Date,r=M){const i=await Y(e),n=(await fa.fromBinary(i.data,uo,r)).findPacket(T.packet.signature);if(!n||n.signatureType!==T.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!n.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await n.verify(this.keyPacket,T.signature.keyRevocation,{key:this.keyPacket},t,void 0,r)}catch(e){throw F.wrapError("Could not verify revocation signature",e)}const s=this.clone();return s.revocationSignatures.push(n),s}async signPrimaryUser(e,t,r,i=M){const{index:n,user:s}=await this.getPrimaryUser(t,r,i),a=await s.certify(e,t,i),o=this.clone();return o.users[n]=a,o}async signAllUsers(e,t=new Date,r=M){const i=this.clone();return i.users=await Promise.all(this.users.map((function(i){return i.certify(e,t,r)}))),i}async verifyPrimaryUser(e,t=new Date,r,i=M){const n=this.keyPacket,{user:s}=await this.getPrimaryUser(t,r,i);return e?await s.verifyAllCertifications(e,t,i):[{keyID:n.getKeyID(),valid:await s.verify(t,i).catch((()=>!1))}]}async verifyAllUsers(e,t=new Date,r=M){const i=this.keyPacket,n=[];return await Promise.all(this.users.map((async s=>{const a=e?await s.verifyAllCertifications(e,t,r):[{keyID:i.getKeyID(),valid:await s.verify(t,r).catch((()=>!1))}];n.push(...a.map((e=>({userID:s.userID?s.userID.userID:null,userAttribute:s.userAttribute,keyID:e.keyID,valid:e.valid}))))}))),n}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach((e=>{lo.prototype[e]=co.prototype[e]}));class po extends lo{constructor(e){if(super(),this.keyPacket=null,this.revocationSignatures=[],this.directSignatures=[],this.users=[],this.subkeys=[],e&&(this.packetListToStructure(e,new Set([T.packet.secretKey,T.packet.secretSubkey])),!this.keyPacket))throw Error("Invalid key: missing public-key packet")}isPrivate(){return!1}toPublic(){return this}armor(e=M){const t=6!==this.keyPacket.version;return Z(T.armor.publicKey,this.toPacketList().write(),void 0,void 0,void 0,t,e)}}class go extends po{constructor(e){if(super(),this.packetListToStructure(e,new Set([T.packet.publicKey,T.packet.publicSubkey])),!this.keyPacket)throw Error("Invalid key: missing private-key packet")}isPrivate(){return!0}toPublic(){const e=new fa,t=this.toPacketList();for(const r of t)switch(r.constructor.tag){case T.packet.secretKey:{const t=Ba.fromSecretKeyPacket(r);e.push(t);break}case T.packet.secretSubkey:{const t=Fa.fromSecretSubkeyPacket(r);e.push(t);break}default:e.push(r)}return new po(e)}armor(e=M){const t=6!==this.keyPacket.version;return Z(T.armor.privateKey,this.toPacketList().write(),void 0,void 0,void 0,t,e)}async getDecryptionKeys(e,t=new Date,r={},i=M){const n=this.keyPacket,s=[];let a=null;for(let r=0;r<this.subkeys.length;r++)if(!e||this.subkeys[r].getKeyID().equals(e,!0)){if(this.subkeys[r].keyPacket.isDummy()){a=a||Error("Gnu-dummy key packets cannot be used for decryption");continue}try{const e={key:n,bind:this.subkeys[r].keyPacket},a=await Qa(this.subkeys[r].bindingSignatures,n,T.signature.subkeyBinding,e,t,i);so(this.subkeys[r].keyPacket,a,i)&&s.push(this.subkeys[r])}catch(e){a=e}}const o=await this.getPrimarySelfSignature(t,r,i);if(e&&!n.getKeyID().equals(e,!0)||!so(n,o,i)||(n.isDummy()?a=a||Error("Gnu-dummy key packets cannot be used for decryption"):s.push(this)),0===s.length)throw a||Error("No decryption key packets found");return s}isDecrypted(){return this.getKeys().some((({keyPacket:e})=>e.isDecrypted()))}async validate(e=M){if(!this.isPrivate())throw Error("Cannot validate a public key");let t;if(this.keyPacket.isDummy()){const r=await this.getSigningKey(null,null,void 0,{...e,rejectPublicKeyAlgorithms:new Set,minRSABits:0});r&&!r.keyPacket.isDummy()&&(t=r.keyPacket)}else t=this.keyPacket;if(t)return t.validate();{const e=this.getKeys();if(e.map((e=>e.keyPacket.isDummy())).every(Boolean))throw Error("Cannot validate an all-gnu-dummy key");return Promise.all(e.map((async e=>e.keyPacket.validate())))}}clearPrivateParams(){this.getKeys().forEach((({keyPacket:e})=>{e.isDecrypted()&&e.clearPrivateParams()}))}async revoke({flag:e=T.reasonForRevocation.noReason,string:t=""}={},r=new Date,i=M){if(!this.isPrivate())throw Error("Need private key for revoking");const n={key:this.keyPacket},s=this.clone();return s.revocationSignatures.push(await Za(n,[],this.keyPacket,{signatureType:T.signature.keyRevocation,reasonForRevocationFlag:T.write(T.reasonForRevocation,e),reasonForRevocationString:t},r,void 0,void 0,void 0,i)),s}async addSubkey(e={}){const t={...M,...e.config};if(e.passphrase)throw Error("Subkey could not be encrypted here, please encrypt whole key");if(e.rsaBits<t.minRSABits)throw Error(`rsaBits should be at least ${t.minRSABits}, got: ${e.rsaBits}`);const r=this.keyPacket;if(r.isDummy())throw Error("Cannot add subkey to gnu-dummy primary key");if(!r.isDecrypted())throw Error("Key is not decrypted");const i=r.getAlgorithmInfo();i.type=function(e){switch(T.write(T.publicKey,e)){case T.publicKey.rsaEncrypt:case T.publicKey.rsaEncryptSign:case T.publicKey.rsaSign:case T.publicKey.dsa:return"rsa";case T.publicKey.ecdsa:case T.publicKey.eddsaLegacy:return"ecc";case T.publicKey.ed25519:return"curve25519";case T.publicKey.ed448:return"curve448";default:throw Error("Unsupported algorithm")}}(i.algorithm),i.rsaBits=i.bits||4096,i.curve=i.curve||"curve25519Legacy",e=ro(e,i);const n=await Wa(e,{...t,v6Keys:6===this.keyPacket.version});ao(n,t);const s=await Ya(n,r,e,t),a=this.toPacketList();return a.push(n,s),new go(a)}}const fo=/*#__PURE__*/F.constructAllowedPackets([Ba,Fa,Na,Oa,ja,Ra,ya]);function mo(e){for(const t of e)switch(t.constructor.tag){case T.packet.secretKey:return new go(e);case T.packet.publicKey:return new po(e)}throw Error("No key packet found")}async function wo(e,t,r,i){r.passphrase&&await e.encrypt(r.passphrase,i),await Promise.all(t.map((async function(e,t){const n=r.subkeys[t].passphrase;n&&await e.encrypt(n,i)})));const n=new fa;function s(e,t){return[t,...e.filter((e=>e!==t))]}function a(){const e={};e.keyFlags=[T.keyFlags.certifyKeys|T.keyFlags.signData];const t=s([T.symmetric.aes256,T.symmetric.aes128],i.preferredSymmetricAlgorithm);if(e.preferredSymmetricAlgorithms=t,i.aeadProtect){const r=s([T.aead.gcm,T.aead.eax,T.aead.ocb],i.preferredAEADAlgorithm);e.preferredCipherSuites=r.flatMap((e=>t.map((t=>[t,e]))))}return e.preferredHashAlgorithms=s([T.hash.sha256,T.hash.sha512,T.hash.sha3_256,T.hash.sha3_512],i.preferredHashAlgorithm),e.preferredCompressionAlgorithms=s([T.compression.uncompressed,T.compression.zlib,T.compression.zip],i.preferredCompressionAlgorithm),e.features=[0],e.features[0]|=T.features.modificationDetection,i.aeadProtect&&(e.features[0]|=T.features.seipdv2),r.keyExpirationTime>0&&(e.keyExpirationTime=r.keyExpirationTime,e.keyNeverExpires=!1),e}if(n.push(e),6===e.version){const t={key:e},s=a();s.signatureType=T.signature.key;const o=await Za(t,[],e,s,r.date,void 0,void 0,void 0,i);n.push(o)}await Promise.all(r.userIDs.map((async function(t,n){const s=ja.fromObject(t),o={userID:s,key:e},c=6!==e.version?a():{};c.signatureType=T.signature.certPositive,0===n&&(c.isPrimaryUserID=!0);return{userIDPacket:s,signaturePacket:await Za(o,[],e,c,r.date,void 0,void 0,void 0,i)}}))).then((e=>{e.forEach((({userIDPacket:e,signaturePacket:t})=>{n.push(e),n.push(t)}))})),await Promise.all(t.map((async function(t,n){const s=r.subkeys[n];return{secretSubkeyPacket:t,subkeySignaturePacket:await Ya(t,e,s,i)}}))).then((e=>{e.forEach((({secretSubkeyPacket:e,subkeySignaturePacket:t})=>{n.push(e),n.push(t)}))}));const o={key:e};return n.push(await Za(o,[],e,{signatureType:T.signature.keyRevocation,reasonForRevocationFlag:T.reasonForRevocation.noReason,reasonForRevocationString:""},r.date,void 0,void 0,void 0,i)),r.passphrase&&e.clearPrivateParams(),await Promise.all(t.map((async function(e,t){r.subkeys[t].passphrase&&e.clearPrivateParams()}))),new go(n)}async function bo({armoredKey:e,binaryKey:t,config:r,...i}){if(r={...M,...r},!e&&!t)throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");if(e&&!F.isString(e))throw Error("readKey: options.armoredKey must be a string");if(t&&!F.isUint8Array(t))throw Error("readKey: options.binaryKey must be a Uint8Array");const n=Object.keys(i);if(n.length>0)throw Error("Unknown option: "+n.join(", "));let s;if(e){const{type:t,data:r}=await Y(e);if(t!==T.armor.publicKey&&t!==T.armor.privateKey)throw Error("Armored text not of type key");s=r}else s=t;const a=await fa.fromBinary(s,fo,r),o=a.indexOfTag(T.packet.publicKey,T.packet.secretKey);if(0===o.length)throw Error("No key packet found");return mo(a.slice(o[0],o[1]))}async function ko({armoredKey:e,binaryKey:t,config:r,...i}){if(r={...M,...r},!e&&!t)throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");if(e&&!F.isString(e))throw Error("readPrivateKey: options.armoredKey must be a string");if(t&&!F.isUint8Array(t))throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");const n=Object.keys(i);if(n.length>0)throw Error("Unknown option: "+n.join(", "));let s;if(e){const{type:t,data:r}=await Y(e);if(t!==T.armor.privateKey)throw Error("Armored text not of type private key");s=r}else s=t;const a=await fa.fromBinary(s,fo,r),o=a.indexOfTag(T.packet.publicKey,T.packet.secretKey);for(let e=0;e<o.length;e++){if(a[o[e]].constructor.tag===T.packet.publicKey)continue;const t=a.slice(o[e],o[e+1]);return new go(t)}throw Error("No secret key packet found")}async function vo({armoredKeys:e,binaryKeys:t,config:r,...i}){r={...M,...r};let n=e||t;if(!n)throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(e&&!F.isString(e))throw Error("readKeys: options.armoredKeys must be a string");if(t&&!F.isUint8Array(t))throw Error("readKeys: options.binaryKeys must be a Uint8Array");const s=Object.keys(i);if(s.length>0)throw Error("Unknown option: "+s.join(", "));if(e){const{type:t,data:r}=await Y(e);if(t!==T.armor.publicKey&&t!==T.armor.privateKey)throw Error("Armored text not of type key");n=r}const a=[],o=await fa.fromBinary(n,fo,r),c=o.indexOfTag(T.packet.publicKey,T.packet.secretKey);if(0===c.length)throw Error("No key packet found");for(let e=0;e<c.length;e++){const t=mo(o.slice(c[e],c[e+1]));a.push(t)}return a}async function Ao({armoredKeys:e,binaryKeys:t,config:r}){r={...M,...r};let i=e||t;if(!i)throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(e&&!F.isString(e))throw Error("readPrivateKeys: options.armoredKeys must be a string");if(t&&!F.isUint8Array(t))throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");if(e){const{type:t,data:r}=await Y(e);if(t!==T.armor.privateKey)throw Error("Armored text not of type private key");i=r}const n=[],s=await fa.fromBinary(i,fo,r),a=s.indexOfTag(T.packet.publicKey,T.packet.secretKey);for(let e=0;e<a.length;e++){if(s[a[e]].constructor.tag===T.packet.publicKey)continue;const t=s.slice(a[e],a[e+1]),r=new go(t);n.push(r)}if(0===n.length)throw Error("No secret key packet found");return n}const Ko=/*#__PURE__*/F.constructAllowedPackets([aa,wa,Da,Sa,Ma,xa,Ca,ga,ya]),Eo=/*#__PURE__*/F.constructAllowedPackets([Ca]),So=/*#__PURE__*/F.constructAllowedPackets([ya]);class Po{constructor(e){this.packets=e||new fa}getEncryptionKeyIDs(){const e=[];return this.packets.filterByTag(T.packet.publicKeyEncryptedSessionKey).forEach((function(t){e.push(t.publicKeyID)})),e}getSigningKeyIDs(){const e=this.unwrapCompressed(),t=e.packets.filterByTag(T.packet.onePassSignature);if(t.length>0)return t.map((e=>e.issuerKeyID));return e.packets.filterByTag(T.packet.signature).map((e=>e.issuerKeyID))}async decrypt(e,t,r,i=new Date,n=M){const s=this.packets.filterByTag(T.packet.symmetricallyEncryptedData,T.packet.symEncryptedIntegrityProtectedData,T.packet.aeadEncryptedData);if(0===s.length)throw Error("No encrypted data found");const a=s[0],o=a.cipherAlgorithm,c=r||await this.decryptSessionKeys(e,t,o,i,n);let u=null;const h=Promise.all(c.map((async({algorithm:e,data:t})=>{if(!F.isUint8Array(t)||!a.cipherAlgorithm&&!F.isString(e))throw Error("Invalid session key for decryption.");try{const r=a.cipherAlgorithm||T.write(T.symmetric,e);await a.decrypt(r,t,n)}catch(e){F.printDebugError(e),u=e}})));if(D(a.encrypted),a.encrypted=null,await h,!a.packets||!a.packets.length)throw u||Error("Decryption failed.");const y=new Po(a.packets);return a.packets=new fa,y}async decryptSessionKeys(e,t,r,i=new Date,n=M){let s,a=[];if(t){const e=this.packets.filterByTag(T.packet.symEncryptedSessionKey);if(0===e.length)throw Error("No symmetrically encrypted session key packet found.");await Promise.all(t.map((async function(t,r){let i;i=r?await fa.fromBinary(e.write(),Eo,n):e,await Promise.all(i.map((async function(e){try{await e.decrypt(t),a.push(e)}catch(e){F.printDebugError(e),e instanceof as&&(s=e)}})))})))}else{if(!e)throw Error("No key or password specified.");{const t=this.packets.filterByTag(T.packet.publicKeyEncryptedSessionKey);if(0===t.length)throw Error("No public key encrypted session key packet found.");await Promise.all(t.map((async function(t){await Promise.all(e.map((async function(e){let o;try{o=(await e.getDecryptionKeys(t.publicKeyID,null,void 0,n)).map((e=>e.keyPacket))}catch(e){return void(s=e)}let c=[T.symmetric.aes256,T.symmetric.aes128,T.symmetric.tripledes,T.symmetric.cast5];try{const t=await e.getPrimarySelfSignature(i,void 0,n);t.preferredSymmetricAlgorithms&&(c=c.concat(t.preferredSymmetricAlgorithms))}catch(e){}await Promise.all(o.map((async function(e){if(!e.isDecrypted())throw Error("Decryption key is not decrypted.");if(n.constantTimePKCS1Decryption&&(t.publicKeyAlgorithm===T.publicKey.rsaEncrypt||t.publicKeyAlgorithm===T.publicKey.rsaEncryptSign||t.publicKeyAlgorithm===T.publicKey.rsaSign||t.publicKeyAlgorithm===T.publicKey.elgamal)){const i=t.write();await Promise.all((r?[r]:Array.from(n.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)).map((async t=>{const r=new xa;r.read(i);const n={sessionKeyAlgorithm:t,sessionKey:ss.generateSessionKey(t)};try{await r.decrypt(e,n),a.push(r)}catch(e){F.printDebugError(e),s=e}})))}else try{await t.decrypt(e);const i=r||t.sessionKeyAlgorithm;if(i&&!c.includes(T.write(T.symmetric,i)))throw Error("A non-preferred symmetric algorithm was used.");a.push(t)}catch(e){F.printDebugError(e),s=e}})))}))),D(t.encrypted),t.encrypted=null})))}}if(a.length>0){if(a.length>1){const e=new Set;a=a.filter((t=>{const r=t.sessionKeyAlgorithm+F.uint8ArrayToString(t.sessionKey);return!e.has(r)&&(e.add(r),!0)}))}return a.map((e=>({data:e.sessionKey,algorithm:e.sessionKeyAlgorithm&&T.read(T.symmetric,e.sessionKeyAlgorithm)})))}throw s||Error("Session key decryption failed.")}getLiteralData(){const e=this.unwrapCompressed().packets.findPacket(T.packet.literalData);return e&&e.getBytes()||null}getFilename(){const e=this.unwrapCompressed().packets.findPacket(T.packet.literalData);return e&&e.getFilename()||null}getText(){const e=this.unwrapCompressed().packets.findPacket(T.packet.literalData);return e?e.getText():null}static async generateSessionKey(e=[],t=new Date,r=[],i=M){const{symmetricAlgo:n,aeadAlgo:s}=await async function(e=[],t=new Date,r=[],i=M){const n=await Promise.all(e.map(((e,n)=>e.getPrimarySelfSignature(t,r[n],i))));if(e.length?n.every((e=>e.features&&e.features[0]&T.features.seipdv2)):i.aeadProtect){const e={symmetricAlgo:T.symmetric.aes128,aeadAlgo:T.aead.ocb},t=[{symmetricAlgo:i.preferredSymmetricAlgorithm,aeadAlgo:i.preferredAEADAlgorithm},{symmetricAlgo:i.preferredSymmetricAlgorithm,aeadAlgo:T.aead.ocb},{symmetricAlgo:T.symmetric.aes128,aeadAlgo:i.preferredAEADAlgorithm}];for(const e of t)if(n.every((t=>t.preferredCipherSuites&&t.preferredCipherSuites.some((t=>t[0]===e.symmetricAlgo&&t[1]===e.aeadAlgo)))))return e;return e}const s=T.symmetric.aes128,a=i.preferredSymmetricAlgorithm;return{symmetricAlgo:n.every((e=>e.preferredSymmetricAlgorithms&&e.preferredSymmetricAlgorithms.includes(a)))?a:s,aeadAlgo:void 0}}(e,t,r,i),a=T.read(T.symmetric,n),o=s?T.read(T.aead,s):void 0;await Promise.all(e.map((e=>e.getEncryptionKey().catch((()=>null)).then((e=>{if(e&&(e.keyPacket.algorithm===T.publicKey.x25519||e.keyPacket.algorithm===T.publicKey.x448)&&!o&&!F.isAES(n))throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.")})))));return{data:ss.generateSessionKey(n),algorithm:a,aeadAlgorithm:o}}async encrypt(e,t,r,i=!1,n=[],s=new Date,a=[],o=M){if(r){if(!F.isUint8Array(r.data)||!F.isString(r.algorithm))throw Error("Invalid session key for encryption.")}else if(e&&e.length)r=await Po.generateSessionKey(e,s,a,o);else{if(!t||!t.length)throw Error("No keys, passwords, or session key provided.");r=await Po.generateSessionKey(void 0,void 0,void 0,o)}const{data:c,algorithm:u,aeadAlgorithm:h}=r,y=await Po.encryptSessionKey(c,u,h,e,t,i,n,s,a,o),l=Sa.fromObject({version:h?2:1,aeadAlgorithm:h?T.write(T.aead,h):null});l.packets=this.packets;const p=T.write(T.symmetric,u);return await l.encrypt(p,c,o),y.packets.push(l),l.packets=new fa,y}static async encryptSessionKey(e,t,r,i,n,s=!1,a=[],o=new Date,c=[],u=M){const h=new fa,y=T.write(T.symmetric,t),l=r&&T.write(T.aead,r);if(i){const t=await Promise.all(i.map((async function(t,r){const i=await t.getEncryptionKey(a[r],o,c,u),n=xa.fromObject({version:l?6:3,encryptionKeyPacket:i.keyPacket,anonymousRecipient:s,sessionKey:e,sessionKeyAlgorithm:y});return await n.encrypt(i.keyPacket),delete n.sessionKey,n})));h.push(...t)}if(n){const t=async function(e,t){try{return await e.decrypt(t),1}catch(e){return 0}},r=(e,t)=>e+t,i=async function(e,s,a,o){const c=new Ca(u);if(c.sessionKey=e,c.sessionKeyAlgorithm=s,a&&(c.aeadAlgorithm=a),await c.encrypt(o,u),u.passwordCollisionCheck){if(1!==(await Promise.all(n.map((e=>t(c,e))))).reduce(r))return i(e,s,o)}return delete c.sessionKey,c},s=await Promise.all(n.map((t=>i(e,y,l,t))));h.push(...s)}return new Po(h)}async sign(e=[],t=[],r=null,i=[],n=new Date,s=[],a=[],o=[],c=M){const u=new fa,h=this.packets.findPacket(T.packet.literalData);if(!h)throw Error("No literal data packet to sign.");const y=await Uo(h,e,t,r,i,n,s,a,o,!1,c),l=y.map(((e,t)=>ga.fromSignaturePacket(e,0===t))).reverse();return u.push(...l),u.push(h),u.push(...y),new Po(u)}compress(e,t=M){if(e===T.compression.uncompressed)return this;const r=new wa(t);r.algorithm=e,r.packets=this.packets;const i=new fa;return i.push(r),new Po(i)}async signDetached(e=[],t=[],r=null,i=[],n=[],s=new Date,a=[],o=[],c=M){const u=this.packets.findPacket(T.packet.literalData);if(!u)throw Error("No literal data packet to sign.");return new qa(await Uo(u,e,t,r,i,n,s,a,o,!0,c))}async verify(e,t=new Date,r=M){const i=this.unwrapCompressed(),n=i.packets.filterByTag(T.packet.literalData);if(1!==n.length)throw Error("Can only verify message with one literal data packet.");a(i.packets.stream)&&i.packets.push(...await U(i.packets.stream,(e=>e||[])));const s=i.packets.filterByTag(T.packet.onePassSignature).reverse(),o=i.packets.filterByTag(T.packet.signature);return s.length&&!o.length&&F.isStream(i.packets.stream)&&!a(i.packets.stream)?(await Promise.all(s.map((async e=>{e.correspondingSig=new Promise(((t,r)=>{e.correspondingSigResolve=t,e.correspondingSigReject=r})),e.signatureData=x((async()=>(await e.correspondingSig).signatureData)),e.hashed=U(await e.hash(e.signatureType,n[0],void 0,!1)),e.hashed.catch((()=>{}))}))),i.packets.stream=v(i.packets.stream,(async(e,t)=>{const r=I(e),i=C(t);try{for(let e=0;e<s.length;e++){const{value:t}=await r.read();s[e].correspondingSigResolve(t)}await r.readToEnd(),await i.ready,await i.close()}catch(e){s.forEach((t=>{t.correspondingSigReject(e)})),await i.abort(e)}})),Do(s,n,e,t,!1,r)):Do(o,n,e,t,!1,r)}verifyDetached(e,t,r=new Date,i=M){const n=this.unwrapCompressed().packets.filterByTag(T.packet.literalData);if(1!==n.length)throw Error("Can only verify message with one literal data packet.");return Do(e.packets.filterByTag(T.packet.signature),n,t,r,!0,i)}unwrapCompressed(){const e=this.packets.filterByTag(T.packet.compressedData);return e.length?new Po(e[0].packets):this}async appendSignature(e,t=M){await this.packets.read(F.isUint8Array(e)?e:(await Y(e)).data,So,t)}write(){return this.packets.write()}armor(e=M){const t=this.packets[this.packets.length-1],r=t.constructor.tag===Sa.tag?2!==t.version:this.packets.some((e=>e.constructor.tag===ya.tag&&6!==e.version));return Z(T.armor.message,this.write(),null,null,null,r,e)}}async function Uo(e,t,r=[],i=null,n=[],s=new Date,a=[],o=[],c=[],u=!1,h=M){const y=new fa,l=null===e.text?T.signature.binary:T.signature.text;if(await Promise.all(t.map((async(t,i)=>{const y=a[i];if(!t.isPrivate())throw Error("Need private key for signing");const p=await t.getSigningKey(n[i],s,y,h);return Za(e,r.length?r:[t],p.keyPacket,{signatureType:l},s,o,c,u,h)}))).then((e=>{y.push(...e)})),i){const e=i.packets.filterByTag(T.packet.signature);y.push(...e)}return y}async function Do(e,t,r,i=new Date,n=!1,s=M){return Promise.all(e.filter((function(e){return["text","binary"].includes(T.read(T.signature,e.signatureType))})).map((async function(e){return async function(e,t,r,i=new Date,n=!1,s=M){let a,o;for(const t of r){const r=t.getKeys(e.issuerKeyID);if(r.length>0){a=t,o=r[0];break}}const c=e instanceof ga?e.correspondingSig:e,u={keyID:e.issuerKeyID,verified:(async()=>{if(!o)throw Error("Could not find signing key with key ID "+e.issuerKeyID.toHex());await e.verify(o.keyPacket,e.signatureType,t[0],i,n,s);const r=await c;if(o.getCreationTime()>r.created)throw Error("Key is newer than the signature");try{await a.getSigningKey(o.getKeyID(),r.created,void 0,s)}catch(e){if(!s.allowInsecureVerificationWithReformattedKeys||!e.message.match(/Signature creation time is in the future/))throw e;await a.getSigningKey(o.getKeyID(),i,void 0,s)}return!0})(),signature:(async()=>{const e=await c,t=new fa;return e&&t.push(e),new qa(t)})()};return u.signature.catch((()=>{})),u.verified.catch((()=>{})),u}(e,t,r,i,n,s)})))}async function xo({armoredMessage:e,binaryMessage:t,config:r,...i}){r={...M,...r};let n=e||t;if(!n)throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");if(e&&!F.isString(e)&&!F.isStream(e))throw Error("readMessage: options.armoredMessage must be a string or stream");if(t&&!F.isUint8Array(t)&&!F.isStream(t))throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");const s=Object.keys(i);if(s.length>0)throw Error("Unknown option: "+s.join(", "));const a=F.isStream(n);if(e){const{type:e,data:t}=await Y(n);if(e!==T.armor.message)throw Error("Armored text not of type message");n=t}const o=await fa.fromBinary(n,Ko,r),c=new Po(o);return c.fromStream=a,c}async function Io({text:e,binary:t,filename:r,date:i=new Date,format:n=(void 0!==e?"utf8":"binary"),...s}){const a=void 0!==e?e:t;if(void 0===a)throw Error("createMessage: must pass options object containing `text` or `binary`");if(e&&!F.isString(e)&&!F.isStream(e))throw Error("createMessage: options.text must be a string or stream");if(t&&!F.isUint8Array(t)&&!F.isStream(t))throw Error("createMessage: options.binary must be a Uint8Array or stream");const o=Object.keys(s);if(o.length>0)throw Error("Unknown option: "+o.join(", "));const c=F.isStream(a),u=new aa(i);void 0!==e?u.setText(a,T.write(T.literal,n)):u.setBytes(a,T.write(T.literal,n)),void 0!==r&&u.setFilename(r);const h=new fa;h.push(u);const y=new Po(h);return y.fromStream=c,y}const Co=/*#__PURE__*/F.constructAllowedPackets([ya]);class Bo{constructor(e,t){if(this.text=F.removeTrailingSpaces(e).replace(/\r?\n/g,"\r\n"),t&&!(t instanceof qa))throw Error("Invalid signature input");this.signature=t||new qa(new fa)}getSigningKeyIDs(){const e=[];return this.signature.packets.forEach((function(t){e.push(t.issuerKeyID)})),e}async sign(e,t=[],r=null,i=[],n=new Date,s=[],a=[],o=[],c=M){const u=new aa;u.setText(this.text);const h=new qa(await Uo(u,e,t,r,i,n,s,a,o,!0,c));return new Bo(this.text,h)}verify(e,t=new Date,r=M){const i=this.signature.packets.filterByTag(T.packet.signature),n=new aa;return n.setText(this.text),Do(i,[n],e,t,!0,r)}getText(){return this.text.replace(/\r\n/g,"\n")}armor(e=M){const t=this.signature.packets.some((e=>6!==e.version)),r={hash:t?Array.from(new Set(this.signature.packets.map((e=>T.read(T.hash,e.hashAlgorithm).toUpperCase())))).join():null,text:this.text,data:this.signature.packets.write()};return Z(T.armor.signed,r,void 0,void 0,void 0,t,e)}}async function To({cleartextMessage:e,config:t,...r}){if(t={...M,...t},!e)throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");if(!F.isString(e))throw Error("readCleartextMessage: options.cleartextMessage must be a string");const i=Object.keys(r);if(i.length>0)throw Error("Unknown option: "+i.join(", "));const n=await Y(e);if(n.type!==T.armor.signed)throw Error("No cleartext signed message.");const s=await fa.fromBinary(n.data,Co,t);!function(e,t){const r=function(e){const r=e=>t=>e.hashAlgorithm===t;for(let i=0;i<t.length;i++)if(t[i].constructor.tag===T.packet.signature&&!e.some(r(t[i])))return!1;return!0},i=[];if(e.forEach((e=>{const t=e.match(/^Hash: (.+)$/);if(!t)throw Error('Only "Hash" header allowed in cleartext signed message');{const e=t[1].replace(/\s/g,"").split(",").map((e=>{try{return T.write(T.hash,e.toLowerCase())}catch(t){throw Error("Unknown hash algorithm in armor header: "+e.toLowerCase())}}));i.push(...e)}})),i.length&&!r(i))throw Error("Hash algorithm mismatch in armor header and signature")}(n.headers,s);const a=new qa(s);return new Bo(n.text,a)}async function Mo({text:e,...t}){if(!e)throw Error("createCleartextMessage: must pass options object containing `text`");if(!F.isString(e))throw Error("createCleartextMessage: options.text must be a string");const r=Object.keys(t);if(r.length>0)throw Error("Unknown option: "+r.join(", "));return new Bo(e)}async function Lo({userIDs:e=[],passphrase:t,type:r,curve:i,rsaBits:n=4096,keyExpirationTime:s=0,date:a=new Date,subkeys:o=[{}],format:c="armored",config:u,...h}){Yo(u={...M,...u}),r||i?(r=r||"ecc",i=i||"curve25519Legacy"):(r=u.v6Keys?"curve25519":"ecc",i="curve25519Legacy"),e=Zo(e);const y=Object.keys(h);if(y.length>0)throw Error("Unknown option: "+y.join(", "));if(0===e.length&&!u.v6Keys)throw Error("UserIDs are required for V4 keys");if("rsa"===r&&n<u.minRSABits)throw Error(`rsaBits should be at least ${u.minRSABits}, got: ${n}`);const l={userIDs:e,passphrase:t,type:r,rsaBits:n,curve:i,keyExpirationTime:s,date:a,subkeys:o};try{const{key:e,revocationCertificate:t}=await async function(e,t){e.sign=!0,(e=ro(e)).subkeys=e.subkeys.map(((t,r)=>ro(e.subkeys[r],e)));let r=[$a(e,t)];r=r.concat(e.subkeys.map((e=>Wa(e,t))));const i=await Promise.all(r),n=await wo(i[0],i.slice(1),e,t),s=await n.getRevocationCertificate(e.date,t);return n.revocationSignatures=[],{key:n,revocationCertificate:s}}(l,u);return e.getKeys().forEach((({keyPacket:e})=>ao(e,u))),{privateKey:tc(e,c,u),publicKey:tc(e.toPublic(),c,u),revocationCertificate:t}}catch(e){throw F.wrapError("Error generating keypair",e)}}async function Fo({privateKey:e,userIDs:t=[],passphrase:r,keyExpirationTime:i=0,date:n,format:s="armored",config:a,...o}){Yo(a={...M,...a}),t=Zo(t);const c=Object.keys(o);if(c.length>0)throw Error("Unknown option: "+c.join(", "));if(0===t.length&&6!==e.keyPacket.version)throw Error("UserIDs are required for V4 keys");const u={privateKey:e,userIDs:t,passphrase:r,keyExpirationTime:i,date:n};try{const{key:e,revocationCertificate:t}=await async function(e,t){e=o(e);const{privateKey:r}=e;if(!r.isPrivate())throw Error("Cannot reformat a public key");if(r.keyPacket.isDummy())throw Error("Cannot reformat a gnu-dummy primary key");if(!r.getKeys().every((({keyPacket:e})=>e.isDecrypted())))throw Error("Key is not decrypted");const i=r.keyPacket;e.subkeys||(e.subkeys=await Promise.all(r.subkeys.map((async e=>{const r=e.keyPacket,n={key:i,bind:r},s=await Qa(e.bindingSignatures,i,T.signature.subkeyBinding,n,null,t).catch((()=>({})));return{sign:s.keyFlags&&s.keyFlags[0]&T.keyFlags.signData}}))));const n=r.subkeys.map((e=>e.keyPacket));if(e.subkeys.length!==n.length)throw Error("Number of subkey options does not match number of subkeys");e.subkeys=e.subkeys.map((t=>o(t,e)));const s=await wo(i,n,e,t),a=await s.getRevocationCertificate(e.date,t);return s.revocationSignatures=[],{key:s,revocationCertificate:a};function o(e,t={}){return e.keyExpirationTime=e.keyExpirationTime||t.keyExpirationTime,e.passphrase=F.isString(e.passphrase)?e.passphrase:t.passphrase,e.date=e.date||t.date,e}}(u,a);return{privateKey:tc(e,s,a),publicKey:tc(e.toPublic(),s,a),revocationCertificate:t}}catch(e){throw F.wrapError("Error reformatting keypair",e)}}async function Ro({key:e,revocationCertificate:t,reasonForRevocation:r,date:i=new Date,format:n="armored",config:s,...a}){Yo(s={...M,...s});const o=Object.keys(a);if(o.length>0)throw Error("Unknown option: "+o.join(", "));try{const a=t?await e.applyRevocationCertificate(t,i,s):await e.revoke(r,i,s);return a.isPrivate()?{privateKey:tc(a,n,s),publicKey:tc(a.toPublic(),n,s)}:{privateKey:null,publicKey:tc(a,n,s)}}catch(e){throw F.wrapError("Error revoking key",e)}}async function No({privateKey:e,passphrase:t,config:r,...i}){Yo(r={...M,...r});const n=Object.keys(i);if(n.length>0)throw Error("Unknown option: "+n.join(", "));if(!e.isPrivate())throw Error("Cannot decrypt a public key");const s=e.clone(!0),a=F.isArray(t)?t:[t];try{return await Promise.all(s.getKeys().map((e=>F.anyPromise(a.map((t=>e.keyPacket.decrypt(t))))))),await s.validate(r),s}catch(e){throw s.clearPrivateParams(),F.wrapError("Error decrypting private key",e)}}async function zo({privateKey:e,passphrase:t,config:r,...i}){Yo(r={...M,...r});const n=Object.keys(i);if(n.length>0)throw Error("Unknown option: "+n.join(", "));if(!e.isPrivate())throw Error("Cannot encrypt a public key");const s=e.clone(!0),a=s.getKeys(),o=F.isArray(t)?t:Array(a.length).fill(t);if(o.length!==a.length)throw Error("Invalid number of passphrases given for key encryption");try{return await Promise.all(a.map((async(e,t)=>{const{keyPacket:i}=e;await i.encrypt(o[t],r),i.clearPrivateParams()}))),s}catch(e){throw s.clearPrivateParams(),F.wrapError("Error encrypting private key",e)}}async function jo({message:e,encryptionKeys:t,signingKeys:r,passwords:i,sessionKey:n,format:s="armored",signature:a=null,wildcard:o=!1,signingKeyIDs:c=[],encryptionKeyIDs:u=[],date:h=new Date,signingUserIDs:y=[],encryptionUserIDs:l=[],signatureNotations:p=[],config:g,...d}){if(Yo(g={...M,...g}),Wo(e),Qo(s),t=Zo(t),r=Zo(r),i=Zo(i),c=Zo(c),u=Zo(u),y=Zo(y),l=Zo(l),p=Zo(p),d.detached)throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");if(d.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");if(d.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");if(void 0!==d.armor)throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");const f=Object.keys(d);if(f.length>0)throw Error("Unknown option: "+f.join(", "));r||(r=[]);try{if((r.length||a)&&(e=await e.sign(r,t,a,c,h,y,u,p,g)),e=e.compress(await async function(e=[],t=new Date,r=[],i=M){const n=T.compression.uncompressed,s=i.preferredCompressionAlgorithm,a=await Promise.all(e.map((async function(e,n){const a=(await e.getPrimarySelfSignature(t,r[n],i)).preferredCompressionAlgorithms;return!!a&&a.indexOf(s)>=0})));return a.every(Boolean)?s:n}(t,h,l,g),g),e=await e.encrypt(t,i,n,o,u,h,l,g),"object"===s)return e;const d="armored"===s?e.armor(g):e.write();return await Jo(d)}catch(e){throw F.wrapError("Error encrypting message",e)}}async function Oo({message:e,decryptionKeys:t,passwords:r,sessionKeys:i,verificationKeys:n,expectSigned:s=!1,format:a="utf8",signature:o=null,date:c=new Date,config:u,...h}){if(Yo(u={...M,...u}),Wo(e),n=Zo(n),t=Zo(t),r=Zo(r),i=Zo(i),h.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");if(h.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");const y=Object.keys(h);if(y.length>0)throw Error("Unknown option: "+y.join(", "));try{const h=await e.decrypt(t,r,i,c,u);n||(n=[]);const y={};if(y.signatures=o?await h.verifyDetached(o,n,c,u):await h.verify(n,c,u),y.data="binary"===a?h.getLiteralData():h.getText(),y.filename=h.getFilename(),ec(y,e),s){if(0===n.length)throw Error("Verification keys are required to verify message signatures");if(0===y.signatures.length)throw Error("Message is not signed");y.data=f([y.data,x((async()=>{await F.anyPromise(y.signatures.map((e=>e.verified)))}))])}return y.data=await Jo(y.data),y}catch(e){throw F.wrapError("Error decrypting message",e)}}async function Ho({message:e,signingKeys:t,recipientKeys:r=[],format:i="armored",detached:n=!1,signingKeyIDs:s=[],date:a=new Date,signingUserIDs:o=[],recipientUserIDs:c=[],signatureNotations:u=[],config:h,...y}){if(Yo(h={...M,...h}),$o(e),Qo(i),t=Zo(t),s=Zo(s),o=Zo(o),r=Zo(r),c=Zo(c),u=Zo(u),y.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");if(void 0!==y.armor)throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");const l=Object.keys(y);if(l.length>0)throw Error("Unknown option: "+l.join(", "));if(e instanceof Bo&&"binary"===i)throw Error("Cannot return signed cleartext message in binary format");if(e instanceof Bo&&n)throw Error("Cannot detach-sign a cleartext message");if(!t||0===t.length)throw Error("No signing keys provided");try{let y;if(y=n?await e.signDetached(t,r,void 0,s,a,o,c,u,h):await e.sign(t,r,void 0,s,a,o,c,u,h),"object"===i)return y;return y="armored"===i?y.armor(h):y.write(),n&&(y=v(e.packets.write(),(async(e,t)=>{await Promise.all([m(y,t),U(e).catch((()=>{}))])}))),await Jo(y)}catch(e){throw F.wrapError("Error signing message",e)}}async function _o({message:e,verificationKeys:t,expectSigned:r=!1,format:i="utf8",signature:n=null,date:s=new Date,config:a,...o}){if(Yo(a={...M,...a}),$o(e),t=Zo(t),o.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");const c=Object.keys(o);if(c.length>0)throw Error("Unknown option: "+c.join(", "));if(e instanceof Bo&&"binary"===i)throw Error("Can't return cleartext message data as binary");if(e instanceof Bo&&n)throw Error("Can't verify detached cleartext signature");try{const o={};if(o.signatures=n?await e.verifyDetached(n,t,s,a):await e.verify(t,s,a),o.data="binary"===i?e.getLiteralData():e.getText(),e.fromStream&&!n&&ec(o,e),r){if(0===o.signatures.length)throw Error("Message is not signed");o.data=f([o.data,x((async()=>{await F.anyPromise(o.signatures.map((e=>e.verified)))}))])}return o.data=await Jo(o.data),o}catch(e){throw F.wrapError("Error verifying signed message",e)}}async function Go({encryptionKeys:e,date:t=new Date,encryptionUserIDs:r=[],config:i,...n}){if(Yo(i={...M,...i}),e=Zo(e),r=Zo(r),n.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");const s=Object.keys(n);if(s.length>0)throw Error("Unknown option: "+s.join(", "));try{return await Po.generateSessionKey(e,t,r,i)}catch(e){throw F.wrapError("Error generating session key",e)}}async function qo({data:e,algorithm:t,aeadAlgorithm:r,encryptionKeys:i,passwords:n,format:s="armored",wildcard:a=!1,encryptionKeyIDs:o=[],date:c=new Date,encryptionUserIDs:u=[],config:h,...y}){if(Yo(h={...M,...h}),function(e){if(!F.isUint8Array(e))throw Error("Parameter [data] must be of type Uint8Array")}(e),function(e,t){if(!F.isString(e))throw Error("Parameter ["+t+"] must be of type String")}(t,"algorithm"),Qo(s),i=Zo(i),n=Zo(n),o=Zo(o),u=Zo(u),y.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");const l=Object.keys(y);if(l.length>0)throw Error("Unknown option: "+l.join(", "));if(!(i&&0!==i.length||n&&0!==n.length))throw Error("No encryption keys or passwords provided.");try{return tc(await Po.encryptSessionKey(e,t,r,i,n,a,o,c,u,h),s,h)}catch(e){throw F.wrapError("Error encrypting session key",e)}}async function Vo({message:e,decryptionKeys:t,passwords:r,date:i=new Date,config:n,...s}){if(Yo(n={...M,...n}),Wo(e),t=Zo(t),r=Zo(r),s.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");const a=Object.keys(s);if(a.length>0)throw Error("Unknown option: "+a.join(", "));try{return await e.decryptSessionKeys(t,r,void 0,i,n)}catch(e){throw F.wrapError("Error decrypting session keys",e)}}function Wo(e){if(!(e instanceof Po))throw Error("Parameter [message] needs to be of type Message")}function $o(e){if(!(e instanceof Bo||e instanceof Po))throw Error("Parameter [message] needs to be of type Message or CleartextMessage")}function Qo(e){if("armored"!==e&&"binary"!==e&&"object"!==e)throw Error("Unsupported format "+e)}const Xo=Object.keys(M).length;function Yo(e){const t=Object.keys(e);if(t.length!==Xo)for(const e of t)if(void 0===M[e])throw Error("Unknown config property: "+e)}function Zo(e){return e&&!F.isArray(e)&&(e=[e]),e}async function Jo(e){return"array"===F.isStream(e)?U(e):e}function ec(e,t){e.data=v(t.packets.stream,(async(t,r)=>{await m(e.data,r,{preventClose:!0});const i=C(r);try{await U(t,(e=>e)),await i.close()}catch(e){await i.abort(e)}}))}function tc(e,t,r){switch(t){case"object":return e;case"armored":return e.armor(r);case"binary":return e.write();default:throw Error("Unsupported format "+t)}}export{Da as AEADEncryptedDataPacket,Bo as CleartextMessage,wa as CompressedDataPacket,aa as LiteralDataPacket,La as MarkerPacket,Po as Message,ga as OnePassSignaturePacket,fa as PacketList,_a as PaddingPacket,go as PrivateKey,po as PublicKey,xa as PublicKeyEncryptedSessionKeyPacket,Ba as PublicKeyPacket,Fa as PublicSubkeyPacket,Na as SecretKeyPacket,Oa as SecretSubkeyPacket,qa as Signature,ya as SignaturePacket,co as Subkey,Sa as SymEncryptedIntegrityProtectedDataPacket,Ca as SymEncryptedSessionKeyPacket,Ma as SymmetricallyEncryptedDataPacket,Ha as TrustPacket,Vi as UnparseablePacket,Ra as UserAttributePacket,ja as UserIDPacket,Z as armor,M as config,Mo as createCleartextMessage,Io as createMessage,Oo as decrypt,No as decryptKey,Vo as decryptSessionKeys,jo as encrypt,zo as encryptKey,qo as encryptSessionKey,T as enums,Lo as generateKey,Go as generateSessionKey,To as readCleartextMessage,bo as readKey,vo as readKeys,xo as readMessage,ko as readPrivateKey,Ao as readPrivateKeys,Va as readSignature,Fo as reformatKey,Ro as revokeKey,Ho as sign,Y as unarmor,_o as verify};
//# sourceMappingURL=openpgp.min.mjs.map
