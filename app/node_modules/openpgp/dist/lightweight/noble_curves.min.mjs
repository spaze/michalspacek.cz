/*! OpenPGP.js v6.2.0 - 2025-07-17 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;import{h as t,a as f,b as e,i as n,c as r,d as o,H as i,e as s,t as a,f as c,g as d,r as u,s as l,j as h,k as b,l as p,u as g,m as y,n as m,o as w,p as B}from"./sha512.min.mjs";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const E=/* @__PURE__ */BigInt(0),x=/* @__PURE__ */BigInt(1);function v(t,f){if("boolean"!=typeof f)throw Error(t+" boolean expected, got "+f)}function I(t){const f=t.toString(16);return 1&f.length?"0"+f:f}function S(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return""===t?E:BigInt("0x"+t)}function O(t){return S(e(t))}function R(t){return f(t),S(e(Uint8Array.from(t).reverse()))}function F(f,e){return t(f.toString(16).padStart(2*e,"0"))}function A(t,f){return F(t,f).reverse()}function N(f,e,r){let o;if("string"==typeof e)try{o=t(e)}catch(t){throw Error(f+" must be hex string or Uint8Array, cause: "+t)}else{if(!n(e))throw Error(f+" must be hex string or Uint8Array");o=Uint8Array.from(e)}const i=o.length;if("number"==typeof r&&i!==r)throw Error(f+" of length "+r+" expected, got "+i);return o}const P=t=>"bigint"==typeof t&&E<=t;function q(t,f,e,n){if(!function(t,f,e){return P(t)&&P(f)&&P(e)&&f<=t&&t<e}(f,e,n))throw Error("expected valid "+t+": "+e+" <= n < "+n+", got "+f)}const z=t=>(x<<BigInt(t))-x;function H(t,f,e={}){if(!t||"object"!=typeof t)throw Error("expected valid options object");function n(f,e,n){const r=t[f];if(n&&void 0===r)return;const o=typeof r;if(o!==e||null===r)throw Error(`param "${f}" is invalid: expected ${e}, got ${o}`)}Object.entries(f).forEach((([t,f])=>n(t,f,!1))),Object.entries(e).forEach((([t,f])=>n(t,f,!0)))}function U(t){const f=new WeakMap;return(e,...n)=>{const r=f.get(e);if(void 0!==r)return r;const o=t(e,...n);return f.set(e,o),o}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),Z=BigInt(1),V=/* @__PURE__ */BigInt(2),G=/* @__PURE__ */BigInt(3),j=/* @__PURE__ */BigInt(4),k=/* @__PURE__ */BigInt(5),T=/* @__PURE__ */BigInt(8);function L(t,f){const e=t%f;return e>=C?e:f+e}function K(t,f,e){let n=t;for(;f-- >C;)n*=n,n%=e;return n}function _(t,f){if(t===C)throw Error("invert: expected non-zero number");if(f<=C)throw Error("invert: expected positive modulus, got "+f);let e=L(t,f),n=f,r=C,o=Z;for(;e!==C;){const t=n%e,f=r-o*(n/e);n=e,e=t,r=o,o=f}if(n!==Z)throw Error("invert: does not exist");return L(r,f)}function D(t,f){const e=(t.ORDER+Z)/j,n=t.pow(f,e);if(!t.eql(t.sqr(n),f))throw Error("Cannot find square root");return n}function Y(t,f){const e=(t.ORDER-k)/T,n=t.mul(f,V),r=t.pow(n,e),o=t.mul(f,r),i=t.mul(t.mul(o,V),r),s=t.mul(o,t.sub(i,t.ONE));if(!t.eql(t.sqr(s),f))throw Error("Cannot find square root");return s}function M(t){return t%j===G?D:t%T===k?Y:function(t){if(t<BigInt(3))throw Error("sqrt is not defined for small field");let f=t-Z,e=0;for(;f%V===C;)f/=V,e++;let n=V;const r=Q(t);for(;1===J(r,n);)if(n++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===e)return D;let o=r.pow(n,f);const i=(f+Z)/V;return function(t,n){if(t.is0(n))return n;if(1!==J(t,n))throw Error("Cannot find square root");let r=e,s=t.mul(t.ONE,o),a=t.pow(n,f),c=t.pow(n,i);for(;!t.eql(a,t.ONE);){if(t.is0(a))return t.ZERO;let f=1,e=t.sqr(a);for(;!t.eql(e,t.ONE);)if(f++,e=t.sqr(e),f===r)throw Error("Cannot find square root");const n=Z<<BigInt(r-f-1),o=t.pow(s,n);r=f,s=t.sqr(o),a=t.mul(a,s),c=t.mul(c,o)}return c}}(t)}const $=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function W(t,f,e=!1){const n=Array(f.length).fill(e?t.ZERO:void 0),r=f.reduce(((f,e,r)=>t.is0(e)?f:(n[r]=f,t.mul(f,e))),t.ONE),o=t.inv(r);return f.reduceRight(((f,e,r)=>t.is0(e)?f:(n[r]=t.mul(f,n[r]),t.mul(f,e))),o),n}function J(t,f){const e=(t.ORDER-Z)/V,n=t.pow(f,e),r=t.eql(n,t.ONE),o=t.eql(n,t.ZERO),i=t.eql(n,t.neg(t.ONE));if(!r&&!o&&!i)throw Error("invalid Legendre symbol result");return r?1:o?0:-1}function Q(t,f,e=!1,n={}){if(t<=C)throw Error("invalid field: expected ORDER > 0, got "+t);let r,i;if("object"==typeof f&&null!=f){if(n.sqrt||e)throw Error("cannot specify opts in two arguments");const t=f;t.BITS&&(r=t.BITS),t.sqrt&&(i=t.sqrt),"boolean"==typeof t.isLE&&(e=t.isLE)}else"number"==typeof f&&(r=f),n.sqrt&&(i=n.sqrt);const{nBitLength:s,nByteLength:a}=function(t,f){void 0!==f&&o(f);const e=void 0!==f?f:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}(t,r);if(a>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let c;const d=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:a,MASK:z(s),ZERO:C,ONE:Z,create:f=>L(f,t),isValid:f=>{if("bigint"!=typeof f)throw Error("invalid field element: expected bigint, got "+typeof f);return C<=f&&f<t},is0:t=>t===C,isValidNot0:t=>!d.is0(t)&&d.isValid(t),isOdd:t=>(t&Z)===Z,neg:f=>L(-f,t),eql:(t,f)=>t===f,sqr:f=>L(f*f,t),add:(f,e)=>L(f+e,t),sub:(f,e)=>L(f-e,t),mul:(f,e)=>L(f*e,t),pow:(t,f)=>function(t,f,e){if(e<C)throw Error("invalid exponent, negatives unsupported");if(e===C)return t.ONE;if(e===Z)return f;let n=t.ONE,r=f;for(;e>C;)e&Z&&(n=t.mul(n,r)),r=t.sqr(r),e>>=Z;return n}(d,t,f),div:(f,e)=>L(f*_(e,t),t),sqrN:t=>t*t,addN:(t,f)=>t+f,subN:(t,f)=>t-f,mulN:(t,f)=>t*f,inv:f=>_(f,t),sqrt:i||(f=>(c||(c=M(t)),c(d,f))),toBytes:t=>e?A(t,a):F(t,a),fromBytes:t=>{if(t.length!==a)throw Error("Field.fromBytes: expected "+a+" bytes, got "+t.length);return e?R(t):O(t)},invertBatch:t=>W(d,t),cmov:(t,f,e)=>e?f:t});return Object.freeze(d)}function X(t){if("bigint"!=typeof t)throw Error("field order must be bigint");const f=t.toString(2).length;return Math.ceil(f/8)}function tt(t){const f=X(t);return f+Math.ceil(f/2)}class ft extends i{constructor(t,f){super(),this.finished=!1,this.destroyed=!1,s(t);const e=a(f);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(e.length>n?t.create().update(e).digest():e);for(let t=0;t<r.length;t++)r[t]^=54;this.iHash.update(r),this.oHash=t.create();for(let t=0;t<r.length;t++)r[t]^=106;this.oHash.update(r),c(r)}update(t){return d(this),this.iHash.update(t),this}digestInto(t){d(this),f(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:f,iHash:e,finished:n,destroyed:r,blockLen:o,outputLen:i}=this;return t.finished=n,t.destroyed=r,t.blockLen=o,t.outputLen=i,t.oHash=f._cloneInto(t.oHash),t.iHash=e._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const et=(t,f,e)=>new ft(t,f).update(e).digest();et.create=(t,f)=>new ft(t,f)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */;const nt=BigInt(0),rt=BigInt(1);function ot(t,f){const e=f.negate();return t?e:f}function it(t,f,e){const n="pz"===f?t=>t.pz:t=>t.ez,r=W(t.Fp,e.map(n));return e.map(((t,f)=>t.toAffine(r[f]))).map(t.fromAffine)}function st(t,f){if(!Number.isSafeInteger(t)||t<=0||t>f)throw Error("invalid window size, expected [1.."+f+"], got W="+t)}function at(t,f){st(t,f);const e=2**t;return{windows:Math.ceil(f/t)+1,windowSize:2**(t-1),mask:z(t),maxNumber:e,shiftBy:BigInt(t)}}function ct(t,f,e){const{windowSize:n,mask:r,maxNumber:o,shiftBy:i}=e;let s=Number(t&r),a=t>>i;s>n&&(s-=o,a+=rt);const c=f*n;return{nextN:a,offset:c+Math.abs(s)-1,isZero:0===s,isNeg:s<0,isNegF:f%2!=0,offsetF:c}}const dt=new WeakMap,ut=new WeakMap;function lt(t){return ut.get(t)||1}function ht(t){if(t!==nt)throw Error("invalid wNAF")}function bt(t,f){return{constTimeNegate:ot,hasPrecomputes:t=>1!==lt(t),unsafeLadder(f,e,n=t.ZERO){let r=f;for(;e>nt;)e&rt&&(n=n.add(r)),r=r.double(),e>>=rt;return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=at(e,f),o=[];let i=t,s=i;for(let t=0;t<n;t++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(e,n,r){let o=t.ZERO,i=t.BASE;const s=at(e,f);for(let t=0;t<s.windows;t++){const{nextN:f,offset:e,isZero:a,isNeg:c,isNegF:d,offsetF:u}=ct(r,t,s);r=f,a?i=i.add(ot(d,n[u])):o=o.add(ot(c,n[e]))}return ht(r),{p:o,f:i}},wNAFUnsafe(e,n,r,o=t.ZERO){const i=at(e,f);for(let t=0;t<i.windows&&r!==nt;t++){const{nextN:f,offset:e,isZero:s,isNeg:a}=ct(r,t,i);if(r=f,!s){const t=n[e];o=o.add(a?t.negate():t)}}return ht(r),o},getPrecomputes(t,f,e){let n=dt.get(f);return n||(n=this.precomputeWindow(f,t),1!==t&&("function"==typeof e&&(n=e(n)),dt.set(f,n))),n},wNAFCached(t,f,e){const n=lt(t);return this.wNAF(n,this.getPrecomputes(n,t,e),f)},wNAFCachedUnsafe(t,f,e,n){const r=lt(t);return 1===r?this.unsafeLadder(t,f,n):this.wNAFUnsafe(r,this.getPrecomputes(r,t,e),f,n)},setWindowSize(t,e){st(e,f),ut.set(t,e),dt.delete(t)}}}function pt(t,f,e,n){!function(t,f){if(!Array.isArray(t))throw Error("array expected");t.forEach(((t,e)=>{if(!(t instanceof f))throw Error("invalid point at index "+e)}))}(e,t),function(t,f){if(!Array.isArray(t))throw Error("array of scalars expected");t.forEach(((t,e)=>{if(!f.isValid(t))throw Error("invalid scalar at index "+e)}))}(n,f);const r=e.length,o=n.length;if(r!==o)throw Error("arrays of points and scalars must have equal length");const i=t.ZERO,s=function(t){let f;for(f=0;t>E;t>>=x,f+=1);return f}(BigInt(r));let a=1;s>12?a=s-3:s>4?a=s-2:s>0&&(a=2);const c=z(a),d=Array(Number(c)+1).fill(i);let u=i;for(let t=Math.floor((f.BITS-1)/a)*a;t>=0;t-=a){d.fill(i);for(let f=0;f<o;f++){const r=n[f],o=Number(r>>BigInt(t)&c);d[o]=d[o].add(e[f])}let f=i;for(let t=d.length-1,e=i;t>0;t--)e=e.add(d[t]),f=f.add(e);if(u=u.add(f),0!==t)for(let t=0;t<a;t++)u=u.double()}return u}function gt(t,f){if(f){if(f.ORDER!==t)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(t){H(t,$.reduce(((t,f)=>(t[f]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(f),f}return Q(t)}function yt(t,f,e={}){if(!f||"object"!=typeof f)throw Error(`expected valid ${t} CURVE object`);for(const t of["p","n","h"]){const e=f[t];if(!("bigint"==typeof e&&e>nt))throw Error(`CURVE.${t} must be positive bigint`)}const n=gt(f.p,e.Fp),r=gt(f.n,e.Fn),o=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const t of o)if(!n.isValid(f[t]))throw Error(`CURVE.${t} must be valid field element of CURVE.Fp`);return{Fp:n,Fn:r}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function mt(t){void 0!==t.lowS&&v("lowS",t.lowS),void 0!==t.prehash&&v("prehash",t.prehash)}const wt={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,f)=>{const{Err:e}=wt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&f.length)throw new e("tlv.encode: unpadded data");const n=f.length/2,r=I(n);if(r.length/2&128)throw new e("tlv.encode: long form length too big");const o=n>127?I(r.length/2|128):"";return I(t)+o+r+f},decode(t,f){const{Err:e}=wt;let n=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(f.length<2||f[n++]!==t)throw new e("tlv.decode: wrong tlv");const r=f[n++];let o=0;if(!!(128&r)){const t=127&r;if(!t)throw new e("tlv.decode(long): indefinite length not supported");if(t>4)throw new e("tlv.decode(long): byte length is too big");const i=f.subarray(n,n+t);if(i.length!==t)throw new e("tlv.decode: length bytes not complete");if(0===i[0])throw new e("tlv.decode(long): zero leftmost byte");for(const t of i)o=o<<8|t;if(n+=t,o<128)throw new e("tlv.decode(long): not minimal encoding")}else o=r;const i=f.subarray(n,n+o);if(i.length!==o)throw new e("tlv.decode: wrong value length");return{v:i,l:f.subarray(n+o)}}},_int:{encode(t){const{Err:f}=wt;if(t<Bt)throw new f("integer: negative integers are not allowed");let e=I(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new f("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:f}=wt;if(128&t[0])throw new f("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new f("invalid signature integer: unnecessary leading zero");return O(t)}},toSig(t){const{Err:f,_int:e,_tlv:n}=wt,r=N("signature",t),{v:o,l:i}=n.decode(48,r);if(i.length)throw new f("invalid signature: left bytes after parsing");const{v:s,l:a}=n.decode(2,o),{v:c,l:d}=n.decode(2,a);if(d.length)throw new f("invalid signature: left bytes after parsing");return{r:e.decode(s),s:e.decode(c)}},hexFromSig(t){const{_tlv:f,_int:e}=wt,n=f.encode(2,e.encode(t.r))+f.encode(2,e.encode(t.s));return f.encode(48,n)}},Bt=BigInt(0),Et=BigInt(1),xt=BigInt(2),vt=BigInt(3),It=BigInt(4);function St(t,f,e){const{BYTES:n}=t;return function(r){let o;if("bigint"==typeof r)o=r;else{let e=N("private key",r);if(f){if(!f.includes(2*e.length))throw Error("invalid private key");const t=new Uint8Array(n);t.set(e,t.length-e.length),e=t}try{o=t.fromBytes(e)}catch(t){throw Error(`invalid private key: expected ui8a of size ${n}, got ${typeof r}`)}}if(e&&(o=t.create(o)),!t.isValidNot0(o))throw Error("invalid private key: out of range [1..N-1]");return o}}function Ot(t,n={}){const{Fp:o,Fn:i}=yt("weierstrass",t,n),{h:s,n:a}=t;H(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=n;if(c&&(!o.is0(t.a)||"bigint"!=typeof c.beta||"function"!=typeof c.splitScalar))throw Error('invalid endo: expected "beta": bigint and "splitScalar": function');function d(){if(!o.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const u=n.toBytes||function(t,f,e){const{x:n,y:i}=f.toAffine(),s=o.toBytes(n);if(v("isCompressed",e),e){d();const t=!o.isOdd(i);return r(Rt(t),s)}return r(Uint8Array.of(4),s,o.toBytes(i))},l=n.fromBytes||function(t){f(t);const e=o.BYTES,n=e+1,r=2*e+1,i=t.length,s=t[0],a=t.subarray(1);if(i!==n||2!==s&&3!==s){if(i===r&&4===s){const t=o.fromBytes(a.subarray(0*e,1*e)),f=o.fromBytes(a.subarray(1*e,2*e));if(!b(t,f))throw Error("bad point: is not on curve");return{x:t,y:f}}throw Error(`bad point: got length ${i}, expected compressed=${n} or uncompressed=${r}`)}{const t=o.fromBytes(a);if(!o.isValid(t))throw Error("bad point: is not on curve, wrong x");const f=h(t);let e;try{e=o.sqrt(f)}catch(t){const f=t instanceof Error?": "+t.message:"";throw Error("bad point: is not on curve, sqrt error"+f)}d();return!(1&~s)!==o.isOdd(e)&&(e=o.neg(e)),{x:t,y:e}}},h=function(t,f,e){return function(n){const r=t.sqr(n),o=t.mul(r,n);return t.add(t.add(o,t.mul(n,f)),e)}}(o,t.a,t.b);function b(t,f){const e=o.sqr(f),n=h(t);return o.eql(e,n)}if(!b(t.Gx,t.Gy))throw Error("bad curve params: generator point");const p=o.mul(o.pow(t.a,vt),It),g=o.mul(o.sqr(t.b),BigInt(27));if(o.is0(o.add(p,g)))throw Error("bad curve params: a or b");function y(t,f,e=!1){if(!o.isValid(f)||e&&o.is0(f))throw Error("bad point coordinate "+t);return f}function m(t){if(!(t instanceof x))throw Error("ProjectivePoint expected")}const w=U(((t,f)=>{const{px:e,py:n,pz:r}=t;if(o.eql(r,o.ONE))return{x:e,y:n};const i=t.is0();null==f&&(f=i?o.ONE:o.inv(r));const s=o.mul(e,f),a=o.mul(n,f),c=o.mul(r,f);if(i)return{x:o.ZERO,y:o.ZERO};if(!o.eql(c,o.ONE))throw Error("invZ was invalid");return{x:s,y:a}})),B=U((t=>{if(t.is0()){if(n.allowInfinityPoint&&!o.is0(t.py))return;throw Error("bad point: ZERO")}const{x:f,y:e}=t.toAffine();if(!o.isValid(f)||!o.isValid(e))throw Error("bad point: x or y not field elements");if(!b(f,e))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));function E(t,f,e,n,r){return e=new x(o.mul(e.px,t),e.py,e.pz),f=ot(n,f),e=ot(r,e),f.add(e)}class x{constructor(t,f,e){this.px=y("x",t),this.py=y("y",f,!0),this.pz=y("z",e),Object.freeze(this)}static fromAffine(t){const{x:f,y:e}=t||{};if(!t||!o.isValid(f)||!o.isValid(e))throw Error("invalid affine point");if(t instanceof x)throw Error("projective point not allowed");return o.is0(f)&&o.is0(e)?x.ZERO:new x(f,e,o.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){return it(x,"pz",t)}static fromBytes(t){return f(t),x.fromHex(t)}static fromHex(t){const f=x.fromAffine(l(N("pointHex",t)));return f.assertValidity(),f}static fromPrivateKey(t){const f=St(i,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return x.BASE.multiply(f(t))}static msm(t,f){return pt(x,i,t,f)}precompute(t=8,f=!0){return S.setWindowSize(this,t),f||this.multiply(vt),this}_setWindowSize(t){this.precompute(t)}assertValidity(){B(this)}hasEvenY(){const{y:t}=this.toAffine();if(!o.isOdd)throw Error("Field doesn't support isOdd");return!o.isOdd(t)}equals(t){m(t);const{px:f,py:e,pz:n}=this,{px:r,py:i,pz:s}=t,a=o.eql(o.mul(f,s),o.mul(r,n)),c=o.eql(o.mul(e,s),o.mul(i,n));return a&&c}negate(){return new x(this.px,o.neg(this.py),this.pz)}double(){const{a:f,b:e}=t,n=o.mul(e,vt),{px:r,py:i,pz:s}=this;let a=o.ZERO,c=o.ZERO,d=o.ZERO,u=o.mul(r,r),l=o.mul(i,i),h=o.mul(s,s),b=o.mul(r,i);return b=o.add(b,b),d=o.mul(r,s),d=o.add(d,d),a=o.mul(f,d),c=o.mul(n,h),c=o.add(a,c),a=o.sub(l,c),c=o.add(l,c),c=o.mul(a,c),a=o.mul(b,a),d=o.mul(n,d),h=o.mul(f,h),b=o.sub(u,h),b=o.mul(f,b),b=o.add(b,d),d=o.add(u,u),u=o.add(d,u),u=o.add(u,h),u=o.mul(u,b),c=o.add(c,u),h=o.mul(i,s),h=o.add(h,h),u=o.mul(h,b),a=o.sub(a,u),d=o.mul(h,l),d=o.add(d,d),d=o.add(d,d),new x(a,c,d)}add(f){m(f);const{px:e,py:n,pz:r}=this,{px:i,py:s,pz:a}=f;let c=o.ZERO,d=o.ZERO,u=o.ZERO;const l=t.a,h=o.mul(t.b,vt);let b=o.mul(e,i),p=o.mul(n,s),g=o.mul(r,a),y=o.add(e,n),w=o.add(i,s);y=o.mul(y,w),w=o.add(b,p),y=o.sub(y,w),w=o.add(e,r);let B=o.add(i,a);return w=o.mul(w,B),B=o.add(b,g),w=o.sub(w,B),B=o.add(n,r),c=o.add(s,a),B=o.mul(B,c),c=o.add(p,g),B=o.sub(B,c),u=o.mul(l,w),c=o.mul(h,g),u=o.add(c,u),c=o.sub(p,u),u=o.add(p,u),d=o.mul(c,u),p=o.add(b,b),p=o.add(p,b),g=o.mul(l,g),w=o.mul(h,w),p=o.add(p,g),g=o.sub(b,g),g=o.mul(l,g),w=o.add(w,g),b=o.mul(p,w),d=o.add(d,b),b=o.mul(B,w),c=o.mul(y,c),c=o.sub(c,b),b=o.mul(y,p),u=o.mul(B,u),u=o.add(u,b),new x(c,d,u)}subtract(t){return this.add(t.negate())}is0(){return this.equals(x.ZERO)}multiply(t){const{endo:f}=n;if(!i.isValidNot0(t))throw Error("invalid scalar: out of range");let e,r;const o=t=>S.wNAFCached(this,t,x.normalizeZ);if(f){const{k1neg:n,k1:i,k2neg:s,k2:a}=f.splitScalar(t),{p:c,f:d}=o(i),{p:u,f:l}=o(a);r=d.add(l),e=E(f.beta,c,u,n,s)}else{const{p:f,f:n}=o(t);e=f,r=n}return x.normalizeZ([e,r])[0]}multiplyUnsafe(t){const{endo:f}=n,e=this;if(!i.isValid(t))throw Error("invalid scalar: out of range");if(t===Bt||e.is0())return x.ZERO;if(t===Et)return e;if(S.hasPrecomputes(this))return this.multiply(t);if(f){const{k1neg:n,k1:r,k2neg:o,k2:i}=f.splitScalar(t),{p1:s,p2:a}=function(t,f,e,n){let r=f,o=t.ZERO,i=t.ZERO;for(;e>nt||n>nt;)e&rt&&(o=o.add(r)),n&rt&&(i=i.add(r)),r=r.double(),e>>=rt,n>>=rt;return{p1:o,p2:i}}(x,e,r,i);return E(f.beta,s,a,n,o)}return S.wNAFCachedUnsafe(e,t)}multiplyAndAddUnsafe(t,f,e){const n=this.multiplyUnsafe(f).add(t.multiplyUnsafe(e));return n.is0()?void 0:n}toAffine(t){return w(this,t)}isTorsionFree(){const{isTorsionFree:t}=n;return s===Et||(t?t(x,this):S.wNAFCachedUnsafe(this,a).is0())}clearCofactor(){const{clearCofactor:t}=n;return s===Et?this:t?t(x,this):this.multiplyUnsafe(s)}toBytes(t=!0){return v("isCompressed",t),this.assertValidity(),u(x,this,t)}toRawBytes(t=!0){return this.toBytes(t)}toHex(t=!0){return e(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}x.BASE=new x(t.Gx,t.Gy,o.ONE),x.ZERO=new x(o.ZERO,o.ONE,o.ZERO),x.Fp=o,x.Fn=i;const I=i.BITS,S=bt(x,n.endo?Math.ceil(I/2):I);return x}function Rt(t){return Uint8Array.of(t?2:3)}function Ft(f,o,i={}){H(o,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const s=o.randomBytes||u,a=o.hmac||((t,...f)=>et(o.hash,t,r(...f))),{Fp:c,Fn:d}=f,{ORDER:l,BITS:h}=d;function b(t){return t>l>>Et}function p(t,f){if(!d.isValidNot0(f))throw Error(`invalid signature ${t}: out of range 1..CURVE.n`)}class g{constructor(t,f,e){p("r",t),p("s",f),this.r=t,this.s=f,null!=e&&(this.recovery=e),Object.freeze(this)}static fromCompact(t){const f=d.BYTES,e=N("compactSignature",t,2*f);return new g(d.fromBytes(e.subarray(0,f)),d.fromBytes(e.subarray(f,2*f)))}static fromDER(t){const{r:f,s:e}=wt.toSig(N("DER",t));return new g(f,e)}assertValidity(){}addRecoveryBit(t){return new g(this.r,this.s,t)}recoverPublicKey(t){const e=c.ORDER,{r:n,s:o,recovery:i}=this;if(null==i||![0,1,2,3].includes(i))throw Error("recovery id invalid");if(l*xt<e&&i>1)throw Error("recovery id is ambiguous for h>1 curve");const s=2===i||3===i?n+l:n;if(!c.isValid(s))throw Error("recovery id 2 or 3 invalid");const a=c.toBytes(s),u=f.fromHex(r(Rt(!(1&i)),a)),h=d.inv(s),b=E(N("msgHash",t)),p=d.create(-b*h),g=d.create(o*h),y=f.BASE.multiplyUnsafe(p).add(u.multiplyUnsafe(g));if(y.is0())throw Error("point at infinify");return y.assertValidity(),y}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,d.neg(this.s),this.recovery):this}toBytes(f){if("compact"===f)return r(d.toBytes(this.r),d.toBytes(this.s));if("der"===f)return t(wt.hexFromSig(this));throw Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return e(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return e(this.toBytes("compact"))}}const y=St(d,i.allowedPrivateKeyLengths,i.wrapPrivateKey),m={isValidPrivateKey(t){try{return y(t),!0}catch(t){return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const t=l;return function(t,f,e=!1){const n=t.length,r=X(f),o=tt(f);if(n<16||n<o||n>1024)throw Error("expected "+o+"-1024 bytes of input, got "+n);const i=L(e?R(t):O(t),f-Z)+Z;return e?A(i,r):F(i,r)}(s(tt(t)),t)},precompute:(t=8,e=f.BASE)=>e.precompute(t,!1)};function w(t){if("bigint"==typeof t)return!1;if(t instanceof f)return!0;const e=N("key",t).length,n=c.BYTES,r=n+1,o=2*n+1;return i.allowedPrivateKeyLengths||d.BYTES===r?void 0:e===r||e===o}const B=o.bits2int||function(t){if(t.length>8192)throw Error("input is too large");const f=O(t),e=8*t.length-h;return e>0?f>>BigInt(e):f},E=o.bits2int_modN||function(t){return d.create(B(t))},x=z(h);function v(t){return q("num < 2^"+h,t,Bt,x),d.toBytes(t)}function I(t,e,n=S){if(["recovered","canonical"].some((t=>t in n)))throw Error("sign() legacy options not supported");const{hash:i}=o;let{lowS:a,prehash:u,extraEntropy:l}=n;null==a&&(a=!0),t=N("msgHash",t),mt(n),u&&(t=N("prehashed msgHash",i(t)));const h=E(t),p=y(e),m=[v(p),v(h)];if(null!=l&&!1!==l){const t=!0===l?s(c.BYTES):l;m.push(N("extraEntropy",t))}const w=r(...m),x=h;return{seed:w,k2sig:function(t){const e=B(t);if(!d.isValidNot0(e))return;const n=d.inv(e),r=f.BASE.multiply(e).toAffine(),o=d.create(r.x);if(o===Bt)return;const i=d.create(n*d.create(x+o*p));if(i===Bt)return;let s=(r.x===o?0:2)|Number(r.y&Et),c=i;return a&&b(i)&&(c=function(t){return b(t)?d.neg(t):t}(i),s^=1),new g(o,c,s)}}}const S={lowS:o.lowS,prehash:!1},P={lowS:o.lowS,prehash:!1};return f.BASE.precompute(8),Object.freeze({getPublicKey:function(t,e=!0){return f.fromPrivateKey(t).toBytes(e)},getSharedSecret:function(t,e,n=!0){if(!0===w(t))throw Error("first arg must be private key");if(!1===w(e))throw Error("second arg must be public key");return f.fromHex(e).multiply(y(t)).toBytes(n)},sign:function(t,f,e=S){const{seed:n,k2sig:i}=I(t,f,e);return function(t,f,e){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof f||f<2)throw Error("qByteLen must be a number");if("function"!=typeof e)throw Error("hmacFn must be a function");const n=t=>new Uint8Array(t),o=t=>Uint8Array.of(t);let i=n(t),s=n(t),a=0;const c=()=>{i.fill(1),s.fill(0),a=0},d=(...t)=>e(s,i,...t),u=(t=n(0))=>{s=d(o(0),t),i=d(),0!==t.length&&(s=d(o(1),t),i=d())},l=()=>{if(a++>=1e3)throw Error("drbg: tried 1000 values");let t=0;const e=[];for(;t<f;){i=d();const f=i.slice();e.push(f),t+=i.length}return r(...e)};return(t,f)=>{let e;for(c(),u(t);!(e=f(l()));)u();return c(),e}}(o.hash.outputLen,d.BYTES,a)(n,i)},verify:function(t,e,r,i=P){const s=t;e=N("msgHash",e),r=N("publicKey",r),mt(i);const{lowS:a,prehash:c,format:u}=i;if("strict"in i)throw Error("options.strict was renamed to lowS");if(void 0!==u&&!["compact","der","js"].includes(u))throw Error('format must be "compact", "der" or "js"');const l="string"==typeof s||n(s),h=!l&&!u&&"object"==typeof s&&null!==s&&"bigint"==typeof s.r&&"bigint"==typeof s.s;if(!l&&!h)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");let b,p;try{if(h){if(void 0!==u&&"js"!==u)throw Error("invalid format");b=new g(s.r,s.s)}if(l){try{"compact"!==u&&(b=g.fromDER(s))}catch(t){if(!(t instanceof wt.Err))throw t}b||"der"===u||(b=g.fromCompact(s))}p=f.fromHex(r)}catch(t){return!1}if(!b)return!1;if(a&&b.hasHighS())return!1;c&&(e=o.hash(e));const{r:y,s:m}=b,w=E(e),B=d.inv(m),x=d.create(w*B),v=d.create(y*B),I=f.BASE.multiplyUnsafe(x).add(p.multiplyUnsafe(v));return!I.is0()&&d.create(I.x)===y},utils:m,Point:f,Signature:g})}function At(t){const{CURVE:f,curveOpts:e}=function(t){const f={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy};return{CURVE:f,curveOpts:{Fp:t.Fp,Fn:Q(f.n,t.nBitLength),allowedPrivateKeyLengths:t.allowedPrivateKeyLengths,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,wrapPrivateKey:t.wrapPrivateKey,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}(t);return{CURVE:f,curveOpts:e,ecdsaOpts:{hash:t.hash,hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN}}}function Nt(t){const{CURVE:f,curveOpts:e,ecdsaOpts:n}=At(t);return function(t,f){return Object.assign({},f,{ProjectivePoint:f.Point,CURVE:t})}(t,Ft(Ot(f,e),n,e))}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Pt(t,f){const e=f=>Nt({...t,hash:f});return{...e(f),create:e}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},zt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},Ht={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},Ut=Q(qt.p),Ct=Q(zt.p),Zt=Q(Ht.p),Vt=Pt({...qt,Fp:Ut,lowS:!1},l),Gt=Pt({...zt,Fp:Ct,lowS:!1},h),jt=Pt({...Ht,Fp:Zt,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},b),kt=BigInt(0),Tt=BigInt(1),Lt=BigInt(2),Kt=BigInt(8),_t={zip215:!0};function Dt(t,n={}){const{Fp:r,Fn:o}=yt("edwards",t,n),{h:i,n:s}=t;H(n,{},{uvRatio:"function"});const a=Lt<<BigInt(8*o.BYTES)-Tt,c=t=>r.create(t),d=n.uvRatio||((t,f)=>{try{return{isValid:!0,value:r.sqrt(r.div(t,f))}}catch(t){return{isValid:!1,value:kt}}});if(!function(t,f,e,n){const r=t.sqr(e),o=t.sqr(n),i=t.add(t.mul(f.a,r),o),s=t.add(t.ONE,t.mul(f.d,t.mul(r,o)));return t.eql(i,s)}(r,t,t.Gx,t.Gy))throw Error("bad curve params: generator point");function u(t,f,e=!1){return q("coordinate "+t,f,e?Tt:kt,a),f}function l(t){if(!(t instanceof p))throw Error("ExtendedPoint expected")}const h=U(((t,f)=>{const{ex:e,ey:n,ez:o}=t,i=t.is0();null==f&&(f=i?Kt:r.inv(o));const s=c(e*f),a=c(n*f),d=c(o*f);if(i)return{x:kt,y:Tt};if(d!==Tt)throw Error("invZ was invalid");return{x:s,y:a}})),b=U((f=>{const{a:e,d:n}=t;if(f.is0())throw Error("bad point: ZERO");const{ex:r,ey:o,ez:i,et:s}=f,a=c(r*r),d=c(o*o),u=c(i*i),l=c(u*u),h=c(a*e);if(c(u*c(h+d))!==c(l+c(n*c(a*d))))throw Error("bad point: equation left != right (1)");if(c(r*o)!==c(i*s))throw Error("bad point: equation left != right (2)");return!0}));class p{constructor(t,f,e,n){this.ex=u("x",t),this.ey=u("y",f),this.ez=u("z",e,!0),this.et=u("t",n),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof p)throw Error("extended point not allowed");const{x:f,y:e}=t||{};return u("x",f),u("y",e),new p(f,e,Tt,c(f*e))}static normalizeZ(t){return it(p,"ez",t)}static msm(t,f){return pt(p,o,t,f)}_setWindowSize(t){this.precompute(t)}precompute(t=8,f=!0){return g.setWindowSize(this,t),f||this.multiply(Lt),this}assertValidity(){b(this)}equals(t){l(t);const{ex:f,ey:e,ez:n}=this,{ex:r,ey:o,ez:i}=t,s=c(f*i),a=c(r*n),d=c(e*i),u=c(o*n);return s===a&&d===u}is0(){return this.equals(p.ZERO)}negate(){return new p(c(-this.ex),this.ey,this.ez,c(-this.et))}double(){const{a:f}=t,{ex:e,ey:n,ez:r}=this,o=c(e*e),i=c(n*n),s=c(Lt*c(r*r)),a=c(f*o),d=e+n,u=c(c(d*d)-o-i),l=a+i,h=l-s,b=a-i,g=c(u*h),y=c(l*b),m=c(u*b),w=c(h*l);return new p(g,y,w,m)}add(f){l(f);const{a:e,d:n}=t,{ex:r,ey:o,ez:i,et:s}=this,{ex:a,ey:d,ez:u,et:h}=f,b=c(r*a),g=c(o*d),y=c(s*n*h),m=c(i*u),w=c((r+o)*(a+d)-b-g),B=m-y,E=m+y,x=c(g-e*b),v=c(w*B),I=c(E*x),S=c(w*x),O=c(B*E);return new p(v,I,O,S)}subtract(t){return this.add(t.negate())}multiply(t){const f=t;q("scalar",f,Tt,s);const{p:e,f:n}=g.wNAFCached(this,f,p.normalizeZ);return p.normalizeZ([e,n])[0]}multiplyUnsafe(t,f=p.ZERO){const e=t;return q("scalar",e,kt,s),e===kt?p.ZERO:this.is0()||e===Tt?this:g.wNAFCachedUnsafe(this,e,p.normalizeZ,f)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return g.wNAFCachedUnsafe(this,s).is0()}toAffine(t){return h(this,t)}clearCofactor(){return i===Tt?this:this.multiplyUnsafe(i)}static fromBytes(t,e=!1){return f(t),this.fromHex(t,e)}static fromHex(f,e=!1){const{d:n,a:o}=t,i=r.BYTES;f=N("pointHex",f,i),v("zip215",e);const s=f.slice(),u=f[i-1];s[i-1]=-129&u;const l=R(s),h=e?a:r.ORDER;q("pointHex.y",l,kt,h);const b=c(l*l),g=c(b-Tt),y=c(n*b-o);let{isValid:m,value:w}=d(g,y);if(!m)throw Error("Point.fromHex: invalid y coordinate");const B=(w&Tt)===Tt,E=!!(128&u);if(!e&&w===kt&&E)throw Error("Point.fromHex: x=0 and x_0=1");return E!==B&&(w=c(-w)),p.fromAffine({x:w,y:l})}static fromPrivateScalar(t){return p.BASE.multiply(t)}toBytes(){const{x:t,y:f}=this.toAffine(),e=A(f,r.BYTES);return e[e.length-1]|=t&Tt?128:0,e}toRawBytes(){return this.toBytes()}toHex(){return e(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}p.BASE=new p(t.Gx,t.Gy,Tt,c(t.Gx*t.Gy)),p.ZERO=new p(kt,Tt,Tt,kt),p.Fp=r,p.Fn=o;const g=bt(p,8*o.BYTES);return p}function Yt(t,f){H(f,{hash:"function"},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:e,hash:n}=f,{BASE:o,Fp:i,Fn:s}=t,a=s.ORDER,c=f.randomBytes||u,d=f.adjustScalarBytes||(t=>t),l=f.domain||((t,f,e)=>{if(v("phflag",e),f.length||e)throw Error("Contexts/pre-hash are not supported");return t});function h(t){return s.create(t)}function b(t){return h(R(t))}function p(t){const{head:f,prefix:e,scalar:r}=function(t){const f=i.BYTES;t=N("private key",t,f);const e=N("hashed private key",n(t),2*f),r=d(e.slice(0,f));return{head:r,prefix:e.slice(f,2*f),scalar:b(r)}}(t),s=o.multiply(r),a=s.toBytes();return{head:f,prefix:e,scalar:r,point:s,pointBytes:a}}function g(t=Uint8Array.of(),...f){const o=r(...f);return b(n(l(o,N("context",t),!!e)))}const y=_t;o.precompute(8);return{getPublicKey:function(t){return p(t).pointBytes},sign:function(t,f,n={}){t=N("message",t),e&&(t=e(t));const{prefix:s,scalar:c,pointBytes:d}=p(f),u=g(n.context,s,t),l=o.multiply(u).toBytes(),b=h(u+g(n.context,l,d,t)*c);q("signature.s",b,kt,a);const y=i.BYTES;return N("result",r(l,A(b,y)),2*y)},verify:function(f,n,r,s=y){const{context:a,zip215:c}=s,d=i.BYTES;f=N("signature",f,2*d),n=N("message",n),r=N("publicKey",r,d),void 0!==c&&v("zip215",c),e&&(n=e(n));const u=R(f.slice(d,2*d));let l,h,b;try{l=t.fromHex(r,c),h=t.fromHex(f.slice(0,d),c),b=o.multiplyUnsafe(u)}catch(t){return!1}if(!c&&l.isSmallOrder())return!1;const p=g(a,h.toBytes(),l.toBytes(),n);return h.add(l.multiplyUnsafe(p)).subtract(b).clearCofactor().is0()},utils:{getExtendedPublicKey:p,randomPrivateKey:()=>c(i.BYTES),precompute:(f=8,e=t.BASE)=>e.precompute(f,!1)},Point:t}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Mt=BigInt(0),$t=BigInt(1),Wt=BigInt(2);function Jt(t){const f=(H(e=t,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...e}));var e;const{P:n,type:r,adjustScalarBytes:o,powPminus2:i,randomBytes:s}=f,a="x25519"===r;if(!a&&"x448"!==r)throw Error("invalid type");const c=s||u,d=a?255:448,l=a?32:56,h=a?BigInt(9):BigInt(5),b=a?BigInt(121665):BigInt(39081),p=a?Wt**BigInt(254):Wt**BigInt(447),g=a?BigInt(8)*Wt**BigInt(251)-$t:BigInt(4)*Wt**BigInt(445)-$t,y=p+g+$t,m=t=>L(t,n),w=B(h);function B(t){return A(m(t),l)}function E(t,f){const e=function(t,f){q("u",t,Mt,n),q("scalar",f,p,y);const e=f,r=t;let o=$t,s=Mt,a=t,c=$t,u=Mt;for(let t=BigInt(d-1);t>=Mt;t--){const f=e>>t&$t;u^=f,({x_2:o,x_3:a}=v(u,o,a)),({x_2:s,x_3:c}=v(u,s,c)),u=f;const n=o+s,i=m(n*n),d=o-s,l=m(d*d),h=i-l,p=a+c,g=m((a-c)*n),y=m(p*d),w=g+y,B=g-y;a=m(w*w),c=m(r*m(B*B)),o=m(i*l),s=m(h*(i+m(b*h)))}({x_2:o,x_3:a}=v(u,o,a)),({x_2:s,x_3:c}=v(u,s,c));const l=i(s);return m(o*l)}(function(t){const f=N("u coordinate",t,l);return a&&(f[31]&=127),m(R(f))}(f),function(t){return R(o(N("scalar",t,l)))}(t));if(e===Mt)throw Error("invalid private or public key received");return B(e)}function x(t){return E(t,w)}function v(t,f,e){const n=m(t*(f-e));return{x_2:f=m(f-n),x_3:e=m(e+n)}}return{scalarMult:E,scalarMultBase:x,getSharedSecret:(t,f)=>E(t,f),getPublicKey:t=>x(t),utils:{randomPrivateKey:()=>c(l)},GuBytes:w.slice()}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3"),h:BigInt(4),a:BigInt(1),d:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756"),Gx:BigInt("0x4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e"),Gy:BigInt("0x693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14")};Dt(Object.assign({},Qt,{d:BigInt("0xd78b4bdc7f0daf19f24f38c29373a2ccad46157242a50f37809b1da3412a12e79ccc9c81264cfe9ad080997058fb61c4243cc32dbaa156b9"),Gx:BigInt("0x79a70b2b70400553ae7c9df416c792c61128751ac92969240c25a07d728bdc93e21f7787ed6972249de732f38496cd11698713093e9c04fc"),Gy:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000001")}));const Xt=/* @__PURE__ */p((()=>y.create({dkLen:114}))),tf=BigInt(1),ff=BigInt(2),ef=BigInt(3);BigInt(4);const nf=BigInt(11),rf=BigInt(22),of=BigInt(44),sf=BigInt(88),af=BigInt(223);function cf(t){const f=Qt.p,e=t*t*t%f,n=e*e*t%f,r=K(n,ef,f)*n%f,o=K(r,ef,f)*n%f,i=K(o,ff,f)*e%f,s=K(i,nf,f)*i%f,a=K(s,rf,f)*s%f,c=K(a,of,f)*a%f,d=K(c,sf,f)*c%f,u=K(d,of,f)*a%f,l=K(u,ff,f)*e%f,h=K(l,tf,f)*t%f;return K(h,af,f)*l%f}function df(t){return t[0]&=252,t[55]|=128,t[56]=0,t}function uf(t,f){const e=Qt.p,n=L(t*t*f,e),r=L(n*t,e),o=L(r*n*f,e),i=L(r*cf(o),e),s=L(i*i,e);return{isValid:L(s*f,e)===t,value:i}}const lf=/* @__PURE__ */(()=>Q(Qt.p,456,!0))(),hf=function(t){const{CURVE:f,curveOpts:e,eddsaOpts:n}=function(t){const f={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy};return{CURVE:f,curveOpts:{Fp:t.Fp,Fn:Q(f.n,t.nBitLength,!0),uvRatio:t.uvRatio},eddsaOpts:{hash:t.hash,randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve}}}(t);return function(t,f){return Object.assign({},f,{ExtendedPoint:f.Point,CURVE:t})}(t,Yt(Dt(f,e),n))}(/* @__PURE__ */(()=>({...Qt,Fp:lf,nBitLength:456,hash:Xt,adjustScalarBytes:df,domain:(t,f,e)=>{if(f.length>255)throw Error("context must be smaller than 255, got: "+f.length);return r(g("SigEd448"),new Uint8Array([e?1:0,f.length]),f,t)},uvRatio:uf}))()),bf=/* @__PURE__ */(()=>{const t=Qt.p;return Jt({P:t,type:"x448",powPminus2:f=>L(K(cf(f),ff,t)*f,t),adjustScalarBytes:df})})(),pf={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const gf=BigInt(1),yf=BigInt(2),mf=(t,f)=>(t+f/yf)/f;const wf=Q(pf.p,void 0,void 0,{sqrt:function(t){const f=pf.p,e=BigInt(3),n=BigInt(6),r=BigInt(11),o=BigInt(22),i=BigInt(23),s=BigInt(44),a=BigInt(88),c=t*t*t%f,d=c*c*t%f,u=K(d,e,f)*d%f,l=K(u,e,f)*d%f,h=K(l,yf,f)*c%f,b=K(h,r,f)*h%f,p=K(b,o,f)*b%f,g=K(p,s,f)*p%f,y=K(g,a,f)*g%f,m=K(y,s,f)*p%f,w=K(m,e,f)*d%f,B=K(w,i,f)*b%f,E=K(B,n,f)*c%f,x=K(E,yf,f);if(!wf.eql(wf.sqr(x),t))throw Error("Cannot find square root");return x}}),Bf=Pt({...pf,Fp:wf,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const f=pf.n,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-gf*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),s=mf(o*t,f),a=mf(-n*t,f);let c=L(t-s*e-a*r,f),d=L(-s*n-a*o,f);const u=c>i,l=d>i;if(u&&(c=f-c),l&&(d=f-d),c>i||d>i)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:c,k2neg:l,k2:d}}}},l),Ef=Q(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),xf=Pt({a:Ef.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:Ef,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},m),vf=Q(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),If=Pt({a:vf.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:vf,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},w),Sf=Q(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),Of=Pt({a:Sf.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:Sf,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},B),Rf=new Map(Object.entries({nistP256:Vt,nistP384:Gt,nistP521:jt,brainpoolP256r1:xf,brainpoolP384r1:If,brainpoolP512r1:Of,secp256k1:Bf,x448:bf,ed448:hf}));export{Rf as nobleCurves};
//# sourceMappingURL=noble_curves.min.mjs.map
