{"version":3,"file":"openpgp.min.mjs","sources":["../../node_modules/@openpgp/web-stream-tools/lib/writer.js","../../node_modules/@openpgp/web-stream-tools/lib/util.js","../../node_modules/@openpgp/web-stream-tools/lib/reader.js","../../node_modules/@openpgp/web-stream-tools/lib/streams.js","../../src/enums.js","../../src/config/config.js","../../src/util.js","../../src/encoding/base64.js","../../src/encoding/armor.js","../../../../src/crypto/biginteger.ts","../../src/crypto/random.js","../../../../src/crypto/public_key/prime.ts","../../src/crypto/hash/index.js","../../src/crypto/pkcs1.js","../../src/crypto/public_key/rsa.js","../../src/crypto/public_key/elgamal.js","../../src/type/oid.js","../../src/packet/packet.js","../../src/crypto/public_key/elliptic/eddsa.js","../../node_modules/@noble/ciphers/esm/utils.js","../../node_modules/@noble/ciphers/esm/_polyval.js","../../node_modules/@noble/ciphers/esm/aes.js","../../src/crypto/cipher/index.js","../../src/crypto/aes_kw.js","../../src/crypto/hkdf.js","../../src/crypto/public_key/elliptic/ecdh_x.js","../../src/crypto/public_key/elliptic/oid_curves.js","../../src/crypto/public_key/elliptic/ecdsa.js","../../src/crypto/public_key/elliptic/eddsa_legacy.js","../../src/crypto/pkcs5.js","../../src/crypto/public_key/elliptic/ecdh.js","../../src/crypto/public_key/dsa.js","../../src/type/ecdh_symkey.js","../../src/type/kdf_params.js","../../src/type/ecdh_x_symkey.js","../../src/crypto/crypto.js","../../src/crypto/cipherMode/cfb.js","../../src/crypto/cmac.js","../../src/crypto/cipherMode/eax.js","../../src/crypto/cipherMode/ocb.js","../../src/crypto/cipherMode/gcm.js","../../src/crypto/cipherMode/index.js","../../src/crypto/signature.js","../../src/type/s2k/argon2.js","../../src/type/s2k/generic.js","../../src/type/s2k/index.js","../../node_modules/fflate/esm/browser.js","../../src/packet/literal_data.js","../../src/type/keyid.js","../../src/packet/signature.js","../../src/packet/one_pass_signature.js","../../src/packet/packetlist.js","../../../../src/packet/grammar.ts","../../src/packet/compressed_data.js","../../src/packet/sym_encrypted_integrity_protected_data.js","../../src/packet/aead_encrypted_data.js","../../src/packet/public_key_encrypted_session_key.js","../../src/packet/sym_encrypted_session_key.js","../../src/packet/public_key.js","../../src/packet/symmetrically_encrypted_data.js","../../src/packet/marker.js","../../src/packet/public_subkey.js","../../src/packet/user_attribute.js","../../src/packet/secret_key.js","../../src/packet/userid.js","../../src/packet/secret_subkey.js","../../src/packet/trust.js","../../src/packet/padding.js","../../src/signature.js","../../src/key/helper.js","../../src/key/user.js","../../src/key/subkey.js","../../src/key/key.js","../../src/key/public_key.js","../../src/key/private_key.js","../../src/key/factory.js","../../src/message.js","../../src/cleartext.js","../../src/openpgp.js"],"sourcesContent":["const doneWritingPromise = Symbol('doneWritingPromise');\nconst doneWritingResolve = Symbol('doneWritingResolve');\nconst doneWritingReject = Symbol('doneWritingReject');\n\nconst readingIndex = Symbol('readingIndex');\n\nclass ArrayStream extends Array {\n  constructor() {\n    super();\n    // ES5 patch, see https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work\n    Object.setPrototypeOf(this, ArrayStream.prototype);\n\n    this[doneWritingPromise] = new Promise((resolve, reject) => {\n      this[doneWritingResolve] = resolve;\n      this[doneWritingReject] = reject;\n    });\n    this[doneWritingPromise].catch(() => {});\n  }\n}\n\nArrayStream.prototype.getReader = function() {\n  if (this[readingIndex] === undefined) {\n    this[readingIndex] = 0;\n  }\n  return {\n    read: async () => {\n      await this[doneWritingPromise];\n      if (this[readingIndex] === this.length) {\n        return { value: undefined, done: true };\n      }\n      return { value: this[this[readingIndex]++], done: false };\n    }\n  };\n};\n\nArrayStream.prototype.readToEnd = async function(join) {\n  await this[doneWritingPromise];\n  const result = join(this.slice(this[readingIndex]));\n  this.length = 0;\n  return result;\n};\n\nArrayStream.prototype.clone = function() {\n  const clone = new ArrayStream();\n  clone[doneWritingPromise] = this[doneWritingPromise].then(() => {\n    clone.push(...this);\n  });\n  return clone;\n};\n\n/**\n * Check whether data is an ArrayStream\n * @param {Any} input  data to check\n * @returns {boolean}\n */\nfunction isArrayStream(input) {\n  return input && input.getReader && Array.isArray(input);\n}\n\n/**\n * A wrapper class over the native WritableStreamDefaultWriter.\n * It also lets you \"write data to\" array streams instead of streams.\n * @class\n */\nfunction Writer(input) {\n  if (!isArrayStream(input)) {\n    const writer = input.getWriter();\n    const releaseLock = writer.releaseLock;\n    writer.releaseLock = () => {\n      writer.closed.catch(function() {});\n      releaseLock.call(writer);\n    };\n    return writer;\n  }\n  this.stream = input;\n}\n\n/**\n * Write a chunk of data.\n * @returns {Promise<undefined>}\n * @async\n */\nWriter.prototype.write = async function(chunk) {\n  this.stream.push(chunk);\n};\n\n/**\n * Close the stream.\n * @returns {Promise<undefined>}\n * @async\n */\nWriter.prototype.close = async function() {\n  this.stream[doneWritingResolve]();\n};\n\n/**\n * Error the stream.\n * @returns {Promise<Object>}\n * @async\n */\nWriter.prototype.abort = async function(reason) {\n  this.stream[doneWritingReject](reason);\n  return reason;\n};\n\n/**\n * Release the writer's lock.\n * @returns {undefined}\n * @async\n */\nWriter.prototype.releaseLock = function() {};\n\nexport { ArrayStream, isArrayStream, Writer, doneWritingPromise };\n","/* eslint-disable no-prototype-builtins */\nimport { isArrayStream } from './writer.js';\nconst isNode = typeof globalThis.process === 'object' &&\n  typeof globalThis.process.versions === 'object';\n\n/**\n * Check whether data is a Stream, and if so of which type\n * @param {Any} input  data to check\n * @returns {'web'|'node'|'array'|'web-like'|false}\n */\nfunction isStream(input) {\n  if (isArrayStream(input)) {\n    return 'array';\n  }\n  if (globalThis.ReadableStream && globalThis.ReadableStream.prototype.isPrototypeOf(input)) {\n    return 'web';\n  }\n  // try and detect a node native stream without having to import its class\n  if (input &&\n    !(globalThis.ReadableStream && input instanceof globalThis.ReadableStream) &&\n    typeof input._read === 'function' && typeof input._readableState === 'object') {\n    throw new Error('Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`');\n  }\n  if (input && input.getReader) {\n    return 'web-like';\n  }\n  return false;\n}\n\n/**\n * Check whether data is a Uint8Array\n * @param {Any} input  data to check\n * @returns {Boolean}\n */\nfunction isUint8Array(input) {\n  return Uint8Array.prototype.isPrototypeOf(input);\n}\n\n/**\n * Concat Uint8Arrays\n * @param {Array<Uint8array>} Array of Uint8Arrays to concatenate\n * @returns {Uint8array} Concatenated array\n */\nfunction concatUint8Array(arrays) {\n  if (arrays.length === 1) return arrays[0];\n\n  let totalLength = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    if (!isUint8Array(arrays[i])) {\n      throw new Error('concatUint8Array: Data must be in the form of a Uint8Array');\n    }\n\n    totalLength += arrays[i].length;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let pos = 0;\n  arrays.forEach(function (element) {\n    result.set(element, pos);\n    pos += element.length;\n  });\n\n  return result;\n}\n\nexport { isNode, isStream, isArrayStream, isUint8Array, concatUint8Array };\n","import { isUint8Array, isStream, isArrayStream } from './util.js';\nimport * as streams from './streams.js';\n\nconst doneReadingSet = new WeakSet();\n/**\n * The external buffer is used to store values that have been peeked or unshifted from the original stream.\n * Because of how streams are implemented, such values cannot be \"put back\" in the original stream,\n * but they need to be returned first when reading from the input again.\n */\nconst externalBuffer = Symbol('externalBuffer');\n\n/**\n * A wrapper class over the native ReadableStreamDefaultReader.\n * This additionally implements pushing back data on the stream, which\n * lets us implement peeking and a host of convenience functions.\n * It also lets you read data other than streams, such as a Uint8Array.\n * @class\n */\nfunction Reader(input) {\n  this.stream = input;\n  if (input[externalBuffer]) {\n    this[externalBuffer] = input[externalBuffer].slice();\n  }\n  if (isArrayStream(input)) {\n    const reader = input.getReader();\n    this._read = reader.read.bind(reader);\n    this._releaseLock = () => {};\n    this._cancel = () => {};\n    return;\n  }\n  let streamType = isStream(input);\n  if (streamType) {\n    const reader = input.getReader();\n    this._read = reader.read.bind(reader);\n    this._releaseLock = () => {\n      reader.closed.catch(function() {});\n      reader.releaseLock();\n    };\n    this._cancel = reader.cancel.bind(reader);\n    return;\n  }\n  let doneReading = false;\n  this._read = async () => {\n    if (doneReading || doneReadingSet.has(input)) {\n      return { value: undefined, done: true };\n    }\n    doneReading = true;\n    return { value: input, done: false };\n  };\n  this._releaseLock = () => {\n    if (doneReading) {\n      try {\n        doneReadingSet.add(input);\n      } catch(e) {}\n    }\n  };\n}\n\n/**\n * Read a chunk of data.\n * @returns {Promise<Object>} Either { done: false, value: Uint8Array | String } or { done: true, value: undefined }\n * @async\n */\nReader.prototype.read = async function() {\n  if (this[externalBuffer] && this[externalBuffer].length) {\n    const value = this[externalBuffer].shift();\n    return { done: false, value };\n  }\n  return this._read();\n};\n\n/**\n * Allow others to read the stream.\n */\nReader.prototype.releaseLock = function() {\n  if (this[externalBuffer]) {\n    this.stream[externalBuffer] = this[externalBuffer];\n  }\n  this._releaseLock();\n};\n\n/**\n * Cancel the stream.\n */\nReader.prototype.cancel = function(reason) {\n  return this._cancel(reason);\n};\n\n/**\n * Read up to and including the first \\n character.\n * @returns {Promise<String|Undefined>}\n * @async\n */\nReader.prototype.readLine = async function() {\n  let buffer = [];\n  let returnVal;\n  while (!returnVal) {\n    let { done, value } = await this.read();\n    value += '';\n    if (done) {\n      if (buffer.length) return streams.concat(buffer);\n      return;\n    }\n    const lineEndIndex = value.indexOf('\\n') + 1;\n    if (lineEndIndex) {\n      returnVal = streams.concat(buffer.concat(value.substr(0, lineEndIndex)));\n      buffer = [];\n    }\n    if (lineEndIndex !== value.length) {\n      buffer.push(value.substr(lineEndIndex));\n    }\n  }\n  this.unshift(...buffer);\n  return returnVal;\n};\n\n/**\n * Read a single byte/character.\n * @returns {Promise<Number|String|Undefined>}\n * @async\n */\nReader.prototype.readByte = async function() {\n  const { done, value } = await this.read();\n  if (done) return;\n  const byte = value[0];\n  this.unshift(streams.slice(value, 1));\n  return byte;\n};\n\n/**\n * Read a specific amount of bytes/characters, unless the stream ends before that amount.\n * @returns {Promise<Uint8Array|String|Undefined>}\n * @async\n */\nReader.prototype.readBytes = async function(length) {\n  const buffer = [];\n  let bufferLength = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { done, value } = await this.read();\n    if (done) {\n      if (buffer.length) return streams.concat(buffer);\n      return;\n    }\n    buffer.push(value);\n    bufferLength += value.length;\n    if (bufferLength >= length) {\n      const bufferConcat = streams.concat(buffer);\n      this.unshift(streams.slice(bufferConcat, length));\n      return streams.slice(bufferConcat, 0, length);\n    }\n  }\n};\n\n/**\n * Peek (look ahead) a specific amount of bytes/characters, unless the stream ends before that amount.\n * @returns {Promise<Uint8Array|String|Undefined>}\n * @async\n */\nReader.prototype.peekBytes = async function(length) {\n  const bytes = await this.readBytes(length);\n  this.unshift(bytes);\n  return bytes;\n};\n\n/**\n * Push data to the front of the stream.\n * Data must have been read in the last call to read*.\n * @param {...(Uint8Array|String|Undefined)} values\n */\nReader.prototype.unshift = function(...values) {\n  if (!this[externalBuffer]) {\n    this[externalBuffer] = [];\n  }\n  if (\n    values.length === 1 && isUint8Array(values[0]) &&\n    this[externalBuffer].length && values[0].length &&\n    this[externalBuffer][0].byteOffset >= values[0].length\n  ) {\n    this[externalBuffer][0] = new Uint8Array(\n      this[externalBuffer][0].buffer,\n      this[externalBuffer][0].byteOffset - values[0].length,\n      this[externalBuffer][0].byteLength + values[0].length\n    );\n    return;\n  }\n  this[externalBuffer].unshift(...values.filter(value => value && value.length));\n};\n\n/**\n * Read the stream to the end and return its contents, concatenated by the join function (defaults to streams.concat).\n * @param {Function} join\n * @returns {Promise<Uint8array|String|Any>} the return value of join()\n * @async\n */\nReader.prototype.readToEnd = async function(join=streams.concat) {\n  const result = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { done, value } = await this.read();\n    if (done) break;\n    result.push(value);\n  }\n  return join(result);\n};\n\nexport { Reader, externalBuffer };\n","import { isStream, isArrayStream, isUint8Array, concatUint8Array } from './util.js';\nimport { Reader, externalBuffer } from './reader.js';\nimport { ArrayStream, Writer } from './writer.js';\n\n/**\n * Convert data to Stream\n * @param {ReadableStream|Uint8array|String} input  data to convert\n * @returns {ReadableStream} Converted data\n */\nfunction toStream(input) {\n  let streamType = isStream(input);\n  if (streamType) {\n    return input;\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(input);\n      controller.close();\n    }\n  });\n}\n\n/**\n * Convert non-streamed data to ArrayStream; this is a noop if `input` is already a stream.\n * @param {Object} input  data to convert\n * @returns {ArrayStream} Converted data\n */\nfunction toArrayStream(input) {\n  if (isStream(input)) {\n    return input;\n  }\n  const stream = new ArrayStream();\n  (async () => {\n    const writer = getWriter(stream);\n    await writer.write(input);\n    await writer.close();\n  })();\n  return stream;\n}\n\n/**\n * Concat a list of Uint8Arrays, Strings or Streams\n * The caller should not mix Uint8Arrays with Strings, but may mix Streams with non-Streams.\n * @param {Array<Uint8array|String|ReadableStream>} Array of Uint8Arrays/Strings/Streams to concatenate\n * @returns {Uint8array|String|ReadableStream} Concatenated array\n */\nfunction concat(list) {\n  if (list.some(stream => isStream(stream) && !isArrayStream(stream))) {\n    return concatStream(list);\n  }\n  if (list.some(stream => isArrayStream(stream))) {\n    return concatArrayStream(list);\n  }\n  if (typeof list[0] === 'string') {\n    return list.join('');\n  }\n  return concatUint8Array(list);\n}\n\n/**\n * Concat a list of Streams\n * @param {Array<ReadableStream|Uint8array|String>} list  Array of Uint8Arrays/Strings/Streams to concatenate\n * @returns {ReadableStream} Concatenated list\n */\nfunction concatStream(list) {\n  list = list.map(toStream);\n  const transform = transformWithCancel(async function(reason) {\n    await Promise.all(transforms.map(stream => cancel(stream, reason)));\n  });\n  let prev = Promise.resolve();\n  const transforms = list.map((stream, i) => transformPair(stream, (readable, writable) => {\n    prev = prev.then(() => pipe(readable, transform.writable, {\n      preventClose: i !== list.length - 1\n    }));\n    return prev;\n  }));\n  return transform.readable;\n}\n\n/**\n * Concat a list of ArrayStreams\n * @param {Array<ArrayStream|Uint8array|String>} list  Array of Uint8Arrays/Strings/ArrayStreams to concatenate\n * @returns {ArrayStream} Concatenated streams\n */\nfunction concatArrayStream(list) {\n  const result = new ArrayStream();\n  let prev = Promise.resolve();\n  list.forEach((stream, i) => {\n    prev = prev.then(() => pipe(stream, result, {\n      preventClose: i !== list.length - 1\n    }));\n    return prev;\n  });\n  return result;\n}\n\n/**\n * Pipe a readable stream to a writable stream. Don't throw on input stream errors, but forward them to the output stream.\n * @param {ReadableStream|Uint8array|String} input\n * @param {WritableStream} target\n * @param {Object} (optional) options\n * @returns {Promise<undefined>} Promise indicating when piping has finished (input stream closed or errored)\n * @async\n */\nasync function pipe(input, target, {\n  preventClose = false,\n  preventAbort = false,\n  preventCancel = false\n} = {}) {\n  if (isStream(input) && !isArrayStream(input)) {\n    input = toStream(input);\n    try {\n      if (input[externalBuffer]) {\n        const writer = getWriter(target);\n        for (let i = 0; i < input[externalBuffer].length; i++) {\n          await writer.ready;\n          await writer.write(input[externalBuffer][i]);\n        }\n        writer.releaseLock();\n      }\n      await input.pipeTo(target, {\n        preventClose,\n        preventAbort,\n        preventCancel\n      });\n    } catch(e) {}\n    return;\n  }\n  input = toArrayStream(input);\n  const reader = getReader(input);\n  const writer = getWriter(target);\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      await writer.ready;\n      const { done, value } = await reader.read();\n      if (done) {\n        if (!preventClose) await writer.close();\n        break;\n      }\n      await writer.write(value);\n    }\n  } catch (e) {\n    if (!preventAbort) await writer.abort(e);\n  } finally {\n    reader.releaseLock();\n    writer.releaseLock();\n  }\n}\n\n/**\n * Pipe a readable stream through a transform stream.\n * @param {ReadableStream|Uint8array|String} input\n * @param {Object} (optional) options\n * @returns {ReadableStream} transformed stream\n */\nfunction transformRaw(input, options) {\n  const transformStream = new TransformStream(options);\n  pipe(input, transformStream.writable);\n  return transformStream.readable;\n}\n\n/**\n * Create a cancelable TransformStream.\n * @param {Function} cancel\n * @returns {TransformStream}\n */\nfunction transformWithCancel(customCancel) {\n  let pulled = false;\n  let cancelled = false;\n  let backpressureChangePromiseResolve, backpressureChangePromiseReject;\n  let outputController;\n  return {\n    readable: new ReadableStream({\n      start(controller) {\n        outputController = controller;\n      },\n      pull() {\n        if (backpressureChangePromiseResolve) {\n          backpressureChangePromiseResolve();\n        } else {\n          pulled = true;\n        }\n      },\n      async cancel(reason) {\n        cancelled = true;\n        if (customCancel) {\n          await customCancel(reason);\n        }\n        if (backpressureChangePromiseReject) {\n          backpressureChangePromiseReject(reason);\n        }\n      }\n    }, {highWaterMark: 0}),\n    writable: new WritableStream({\n      write: async function(chunk) {\n        if (cancelled) {\n          throw new Error('Stream is cancelled');\n        }\n        outputController.enqueue(chunk);\n        if (!pulled) {\n          await new Promise((resolve, reject) => {\n            backpressureChangePromiseResolve = resolve;\n            backpressureChangePromiseReject = reject;\n          });\n          backpressureChangePromiseResolve = null;\n          backpressureChangePromiseReject = null;\n        } else {\n          pulled = false;\n        }\n      },\n      close: outputController.close.bind(outputController),\n      abort: outputController.error.bind(outputController)\n    })\n  };\n}\n\n/**\n * Transform a stream using helper functions which are called on each chunk, and on stream close, respectively.\n * @param {ReadableStream|Uint8array|String} input\n * @param {Function} process\n * @param {Function} finish\n * @returns {ReadableStream|Uint8array|String}\n */\nfunction transform(input, process = () => undefined, finish = () => undefined) {\n  if (isArrayStream(input)) {\n    const output = new ArrayStream();\n    (async () => {\n      const writer = getWriter(output);\n      try {\n        const data = await readToEnd(input);\n        const result1 = process(data);\n        const result2 = finish();\n        let result;\n        if (result1 !== undefined && result2 !== undefined) result = concat([result1, result2]);\n        else result = result1 !== undefined ? result1 : result2;\n        await writer.write(result);\n        await writer.close();\n      } catch (e) {\n        await writer.abort(e);\n      }\n    })();\n    return output;\n  }\n  if (isStream(input)) {\n    return transformRaw(input, {\n      async transform(value, controller) {\n        try {\n          const result = await process(value);\n          if (result !== undefined) controller.enqueue(result);\n        } catch(e) {\n          controller.error(e);\n        }\n      },\n      async flush(controller) {\n        try {\n          const result = await finish();\n          if (result !== undefined) controller.enqueue(result);\n        } catch(e) {\n          controller.error(e);\n        }\n      }\n    });\n  }\n  const result1 = process(input);\n  const result2 = finish();\n  if (result1 !== undefined && result2 !== undefined) return concat([result1, result2]);\n  return result1 !== undefined ? result1 : result2;\n}\n\n/**\n * Transform a stream using a helper function which is passed a readable and a writable stream.\n *   This function also maintains the possibility to cancel the input stream,\n *   and does so on cancelation of the output stream, despite cancelation\n *   normally being impossible when the input stream is being read from.\n * @param {ReadableStream|Uint8array|String} input\n * @param {Function} fn\n * @returns {ReadableStream}\n */\nfunction transformPair(input, fn) {\n  if (isStream(input) && !isArrayStream(input)) {\n    let incomingTransformController;\n    const incoming = new TransformStream({\n      start(controller) {\n        incomingTransformController = controller;\n      }\n    });\n\n    const pipeDonePromise = pipe(input, incoming.writable);\n\n    const outgoing = transformWithCancel(async function(reason) {\n      incomingTransformController.error(reason);\n      await pipeDonePromise;\n      await new Promise(setTimeout);\n    });\n    fn(incoming.readable, outgoing.writable);\n    return outgoing.readable;\n  }\n  input = toArrayStream(input);\n  const output = new ArrayStream();\n  fn(input, output);\n  return output;\n}\n\n/**\n * Parse a stream using a helper function which is passed a Reader.\n *   The reader additionally has a remainder() method which returns a\n *   stream pointing to the remainder of input, and is linked to input\n *   for cancelation.\n * @param {ReadableStream|Uint8array|String} input\n * @param {Function} fn\n * @returns {Any} the return value of fn()\n */\nfunction parse(input, fn) {\n  let returnValue;\n  const transformed = transformPair(input, (readable, writable) => {\n    const reader = getReader(readable);\n    reader.remainder = () => {\n      reader.releaseLock();\n      pipe(readable, writable);\n      return transformed;\n    };\n    returnValue = fn(reader);\n  });\n  return returnValue;\n}\n\n/**\n * Tee a Stream for reading it twice. The input stream can no longer be read after tee()ing.\n *   Reading either of the two returned streams will pull from the input stream.\n *   The input stream will only be canceled if both of the returned streams are canceled.\n * @param {ReadableStream|Uint8array|String} input\n * @returns {Array<ReadableStream|Uint8array|String>} array containing two copies of input\n */\nfunction tee(input) {\n  if (isArrayStream(input)) {\n    throw new Error('ArrayStream cannot be tee()d, use clone() instead');\n  }\n  if (isStream(input)) {\n    const teed = toStream(input).tee();\n    teed[0][externalBuffer] = teed[1][externalBuffer] = input[externalBuffer];\n    return teed;\n  }\n  return [slice(input), slice(input)];\n}\n\n/**\n * Clone a Stream for reading it twice. The input stream can still be read after clone()ing.\n *   Reading from the clone will pull from the input stream.\n *   The input stream will only be canceled if both the clone and the input stream are canceled.\n * @param {ReadableStream|Uint8array|String} input\n * @returns {ReadableStream|Uint8array|String} cloned input\n */\nfunction clone(input) {\n  if (isArrayStream(input)) {\n    return input.clone();\n  }\n  if (isStream(input)) {\n    const teed = tee(input);\n    overwrite(input, teed[0]);\n    return teed[1];\n  }\n  return slice(input);\n}\n\n/**\n * Clone a Stream for reading it twice. Data will arrive at the same rate as the input stream is being read.\n *   Reading from the clone will NOT pull from the input stream. Data only arrives when reading the input stream.\n *   The input stream will NOT be canceled if the clone is canceled, only if the input stream are canceled.\n *   If the input stream is canceled, the clone will be errored.\n * @param {ReadableStream|Uint8array|String} input\n * @returns {ReadableStream|Uint8array|String} cloned input\n */\nfunction passiveClone(input) {\n  if (isArrayStream(input)) {\n    return clone(input);\n  }\n  if (isStream(input)) {\n    return new ReadableStream({\n      start(controller) {\n        const transformed = transformPair(input, async (readable, writable) => {\n          const reader = getReader(readable);\n          const writer = getWriter(writable);\n          try {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n              await writer.ready;\n              const { done, value } = await reader.read();\n              if (done) {\n                try { controller.close(); } catch(e) {}\n                await writer.close();\n                return;\n              }\n              try { controller.enqueue(value); } catch(e) {}\n              await writer.write(value);\n            }\n          } catch(e) {\n            controller.error(e);\n            await writer.abort(e);\n          }\n        });\n        overwrite(input, transformed);\n      }\n    });\n  }\n  return slice(input);\n}\n\n/**\n * Modify a stream object to point to a different stream object.\n *   This is used internally by clone() and passiveClone() to provide an abstraction over tee().\n * @param {ReadableStream} input\n * @param {ReadableStream} clone\n */\nfunction overwrite(input, clone) {\n  // Overwrite input.getReader, input.locked, etc to point to clone\n  Object.entries(Object.getOwnPropertyDescriptors(input.constructor.prototype)).forEach(([name, descriptor]) => {\n    if (name === 'constructor') {\n      return;\n    }\n    if (descriptor.value) {\n      descriptor.value = descriptor.value.bind(clone);\n    } else {\n      descriptor.get = descriptor.get.bind(clone);\n    }\n    Object.defineProperty(input, name, descriptor);\n  });\n}\n\n/**\n * Return a stream pointing to a part of the input stream.\n * @param {ReadableStream|Uint8array|String} input\n * @returns {ReadableStream|Uint8array|String} clone\n */\nfunction slice(input, begin=0, end=Infinity) {\n  if (isArrayStream(input)) {\n    throw new Error('Not implemented');\n  }\n  if (isStream(input)) {\n    if (begin >= 0 && end >= 0) {\n      let bytesRead = 0;\n      return transformRaw(input, {\n        transform(value, controller) {\n          if (bytesRead < end) {\n            if (bytesRead + value.length >= begin) {\n              controller.enqueue(slice(value, Math.max(begin - bytesRead, 0), end - bytesRead));\n            }\n            bytesRead += value.length;\n          } else {\n            controller.terminate();\n          }\n        }\n      });\n    }\n    if (begin < 0 && (end < 0 || end === Infinity)) {\n      let lastBytes = [];\n      return transform(input, value => {\n        if (value.length >= -begin) lastBytes = [value];\n        else lastBytes.push(value);\n      }, () => slice(concat(lastBytes), begin, end));\n    }\n    if (begin === 0 && end < 0) {\n      let lastBytes;\n      return transform(input, value => {\n        const returnValue = lastBytes ? concat([lastBytes, value]) : value;\n        if (returnValue.length >= -end) {\n          lastBytes = slice(returnValue, end);\n          return slice(returnValue, begin, end);\n        }\n          lastBytes = returnValue;\n      });\n    }\n    console.warn(`stream.slice(input, ${begin}, ${end}) not implemented efficiently.`);\n    return fromAsync(async () => slice(await readToEnd(input), begin, end));\n  }\n  if (input[externalBuffer]) {\n    input = concat(input[externalBuffer].concat([input]));\n  }\n  if (isUint8Array(input)) {\n    return input.subarray(begin, end === Infinity ? input.length : end);\n  }\n  return input.slice(begin, end);\n}\n\n/**\n * Read a stream to the end and return its contents, concatenated by the join function (defaults to concat).\n * @param {ReadableStream|Uint8array|String} input\n * @param {Function} join\n * @returns {Promise<Uint8array|String|Any>} the return value of join()\n * @async\n */\nasync function readToEnd(input, join=concat) {\n  if (isArrayStream(input)) {\n    return input.readToEnd(join);\n  }\n  if (isStream(input)) {\n    return getReader(input).readToEnd(join);\n  }\n  return input;\n}\n\n/**\n * Cancel a stream.\n * @param {ReadableStream|Uint8array|String} input\n * @param {Any} reason\n * @returns {Promise<Any>} indicates when the stream has been canceled\n * @async\n */\nasync function cancel(input, reason) {\n  if (isStream(input)) {\n    if (input.cancel) {\n      const cancelled = await input.cancel(reason);\n      // the stream is not always cancelled at this point, so we wait some more\n      await new Promise(setTimeout);\n      return cancelled;\n    }\n    if (input.destroy) {\n      input.destroy(reason);\n      await new Promise(setTimeout);\n      return reason;\n    }\n  }\n}\n\n/**\n * Convert an async function to an ArrayStream. When the function returns, its return value is written to the stream.\n * @param {Function} fn\n * @returns {ArrayStream}\n */\nfunction fromAsync(fn) {\n  const arrayStream = new ArrayStream();\n  (async () => {\n    const writer = getWriter(arrayStream);\n    try {\n      await writer.write(await fn());\n      await writer.close();\n    } catch (e) {\n      await writer.abort(e);\n    }\n  })();\n  return arrayStream;\n}\n\n/**\n * Get a Reader\n * @param {ReadableStream|Uint8array|String} input\n * @returns {Reader}\n */\nfunction getReader(input) {\n  return new Reader(input);\n}\n\n/**\n * Get a Writer\n * @param {WritableStream} input\n * @returns {Writer}\n */\nfunction getWriter(input) {\n  return new Writer(input);\n}\n\n\nexport {\n  ArrayStream,\n  toStream,\n  concatStream,\n  concat,\n  getReader,\n  getWriter,\n  pipe,\n  transformRaw,\n  transform,\n  transformPair,\n  parse,\n  clone,\n  passiveClone,\n  slice,\n  readToEnd,\n  cancel,\n  fromAsync\n};\n","/**\n * @module enums\n */\n\nconst byValue = Symbol('byValue');\n\nexport default {\n\n  /** Maps curve names under various standards to one\n   * @see {@link https://wiki.gnupg.org/ECC|ECC - GnuPG wiki}\n   * @enum {String}\n   * @readonly\n   */\n  curve: {\n    /** NIST P-256 Curve */\n    'nistP256':               'nistP256',\n    /** @deprecated use `nistP256` instead */\n    'p256':                   'nistP256',\n\n    /** NIST P-384 Curve */\n    'nistP384':               'nistP384',\n    /** @deprecated use `nistP384` instead */\n    'p384':                   'nistP384',\n\n    /** NIST P-521 Curve */\n    'nistP521':               'nistP521',\n    /** @deprecated use `nistP521` instead */\n    'p521':                   'nistP521',\n\n    /** SECG SECP256k1 Curve */\n    'secp256k1':              'secp256k1',\n\n    /** Ed25519 - deprecated by crypto-refresh (replaced by standaone Ed25519 algo) */\n    'ed25519Legacy':          'ed25519Legacy',\n    /** @deprecated use `ed25519Legacy` instead */\n    'ed25519':                'ed25519Legacy',\n\n    /** Curve25519 - deprecated by crypto-refresh (replaced by standaone X25519 algo) */\n    'curve25519Legacy':       'curve25519Legacy',\n    /** @deprecated use `curve25519Legacy` instead */\n    'curve25519':             'curve25519Legacy',\n\n    /** BrainpoolP256r1 Curve */\n    'brainpoolP256r1':       'brainpoolP256r1',\n\n    /** BrainpoolP384r1 Curve */\n    'brainpoolP384r1':       'brainpoolP384r1',\n\n    /** BrainpoolP512r1 Curve */\n    'brainpoolP512r1':       'brainpoolP512r1'\n  },\n\n  /** A string to key specifier type\n   * @enum {Integer}\n   * @readonly\n   */\n  s2k: {\n    simple: 0,\n    salted: 1,\n    iterated: 3,\n    argon2: 4,\n    gnu: 101\n  },\n\n  /** {@link https://tools.ietf.org/html/draft-ietf-openpgp-crypto-refresh-08.html#section-9.1|crypto-refresh RFC, section 9.1}\n   * @enum {Integer}\n   * @readonly\n   */\n  publicKey: {\n    /** RSA (Encrypt or Sign) [HAC] */\n    rsaEncryptSign: 1,\n    /** RSA (Encrypt only) [HAC] */\n    rsaEncrypt: 2,\n    /** RSA (Sign only) [HAC] */\n    rsaSign: 3,\n    /** Elgamal (Encrypt only) [ELGAMAL] [HAC] */\n    elgamal: 16,\n    /** DSA (Sign only) [FIPS186] [HAC] */\n    dsa: 17,\n    /** ECDH (Encrypt only) [RFC6637] */\n    ecdh: 18,\n    /** ECDSA (Sign only) [RFC6637] */\n    ecdsa: 19,\n    /** EdDSA (Sign only) - deprecated by crypto-refresh (replaced by `ed25519` identifier below)\n     * [{@link https://tools.ietf.org/html/draft-koch-eddsa-for-openpgp-04|Draft RFC}] */\n    eddsaLegacy: 22,\n    /** Reserved for AEDH */\n    aedh: 23,\n    /** Reserved for AEDSA */\n    aedsa: 24,\n    /** X25519 (Encrypt only) */\n    x25519: 25,\n    /** X448 (Encrypt only) */\n    x448: 26,\n    /** Ed25519 (Sign only) */\n    ed25519: 27,\n    /** Ed448 (Sign only) */\n    ed448: 28\n  },\n\n  /** {@link https://tools.ietf.org/html/rfc4880#section-9.2|RFC4880, section 9.2}\n   * @enum {Integer}\n   * @readonly\n   */\n  symmetric: {\n    /** Not implemented! */\n    idea: 1,\n    tripledes: 2,\n    cast5: 3,\n    blowfish: 4,\n    aes128: 7,\n    aes192: 8,\n    aes256: 9,\n    twofish: 10\n  },\n\n  /** {@link https://tools.ietf.org/html/rfc4880#section-9.3|RFC4880, section 9.3}\n   * @enum {Integer}\n   * @readonly\n   */\n  compression: {\n    uncompressed: 0,\n    /** RFC1951 */\n    zip: 1,\n    /** RFC1950 */\n    zlib: 2,\n    bzip2: 3\n  },\n\n  /** {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC4880, section 9.4}\n   * @enum {Integer}\n   * @readonly\n   */\n  hash: {\n    md5: 1,\n    sha1: 2,\n    ripemd: 3,\n    sha256: 8,\n    sha384: 9,\n    sha512: 10,\n    sha224: 11,\n    sha3_256: 12,\n    sha3_512: 14\n  },\n\n  /** A list of hash names as accepted by webCrypto functions.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest|Parameters, algo}\n   * @enum {String}\n   */\n  webHash: {\n    'SHA-1': 2,\n    'SHA-256': 8,\n    'SHA-384': 9,\n    'SHA-512': 10\n  },\n\n  /** {@link https://www.rfc-editor.org/rfc/rfc9580.html#name-aead-algorithms}\n   * @enum {Integer}\n   * @readonly\n   */\n  aead: {\n    eax: 1,\n    ocb: 2,\n    gcm: 3,\n    /** @deprecated used by OpenPGP.js v5 for legacy AEAD support; use `gcm` instead for the RFC9580-standardized ID */\n    experimentalGCM: 100 // Private algorithm\n  },\n\n  /** A list of packet types and numeric tags associated with them.\n   * @enum {Integer}\n   * @readonly\n   */\n  packet: {\n    publicKeyEncryptedSessionKey: 1,\n    signature: 2,\n    symEncryptedSessionKey: 3,\n    onePassSignature: 4,\n    secretKey: 5,\n    publicKey: 6,\n    secretSubkey: 7,\n    compressedData: 8,\n    symmetricallyEncryptedData: 9,\n    marker: 10,\n    literalData: 11,\n    trust: 12,\n    userID: 13,\n    publicSubkey: 14,\n    userAttribute: 17,\n    symEncryptedIntegrityProtectedData: 18,\n    modificationDetectionCode: 19,\n    aeadEncryptedData: 20, // see IETF draft: https://tools.ietf.org/html/draft-ford-openpgp-format-00#section-2.1\n    padding: 21\n  },\n\n  /** Data types in the literal packet\n   * @enum {Integer}\n   * @readonly\n   */\n  literal: {\n    /** Binary data 'b' */\n    binary: 'b'.charCodeAt(),\n    /** Text data 't' */\n    text: 't'.charCodeAt(),\n    /** Utf8 data 'u' */\n    utf8: 'u'.charCodeAt(),\n    /** MIME message body part 'm' */\n    mime: 'm'.charCodeAt()\n  },\n\n\n  /** One pass signature packet type\n   * @enum {Integer}\n   * @readonly\n   */\n  signature: {\n    /** 0x00: Signature of a binary document. */\n    binary: 0,\n    /** 0x01: Signature of a canonical text document.\n     *\n     * Canonicalyzing the document by converting line endings. */\n    text: 1,\n    /** 0x02: Standalone signature.\n     *\n     * This signature is a signature of only its own subpacket contents.\n     * It is calculated identically to a signature over a zero-lengh\n     * binary document.  Note that it doesn't make sense to have a V3\n     * standalone signature. */\n    standalone: 2,\n    /** 0x10: Generic certification of a User ID and Public-Key packet.\n     *\n     * The issuer of this certification does not make any particular\n     * assertion as to how well the certifier has checked that the owner\n     * of the key is in fact the person described by the User ID. */\n    certGeneric: 16,\n    /** 0x11: Persona certification of a User ID and Public-Key packet.\n     *\n     * The issuer of this certification has not done any verification of\n     * the claim that the owner of this key is the User ID specified. */\n    certPersona: 17,\n    /** 0x12: Casual certification of a User ID and Public-Key packet.\n     *\n     * The issuer of this certification has done some casual\n     * verification of the claim of identity. */\n    certCasual: 18,\n    /** 0x13: Positive certification of a User ID and Public-Key packet.\n     *\n     * The issuer of this certification has done substantial\n     * verification of the claim of identity.\n     *\n     * Most OpenPGP implementations make their \"key signatures\" as 0x10\n     * certifications.  Some implementations can issue 0x11-0x13\n     * certifications, but few differentiate between the types. */\n    certPositive: 19,\n    /** 0x30: Certification revocation signature\n     *\n     * This signature revokes an earlier User ID certification signature\n     * (signature class 0x10 through 0x13) or direct-key signature\n     * (0x1F).  It should be issued by the same key that issued the\n     * revoked signature or an authorized revocation key.  The signature\n     * is computed over the same data as the certificate that it\n     * revokes, and should have a later creation date than that\n     * certificate. */\n    certRevocation: 48,\n    /** 0x18: Subkey Binding Signature\n     *\n     * This signature is a statement by the top-level signing key that\n     * indicates that it owns the subkey.  This signature is calculated\n     * directly on the primary key and subkey, and not on any User ID or\n     * other packets.  A signature that binds a signing subkey MUST have\n     * an Embedded Signature subpacket in this binding signature that\n     * contains a 0x19 signature made by the signing subkey on the\n     * primary key and subkey. */\n    subkeyBinding: 24,\n    /** 0x19: Primary Key Binding Signature\n     *\n     * This signature is a statement by a signing subkey, indicating\n     * that it is owned by the primary key and subkey.  This signature\n     * is calculated the same way as a 0x18 signature: directly on the\n     * primary key and subkey, and not on any User ID or other packets.\n     *\n     * When a signature is made over a key, the hash data starts with the\n     * octet 0x99, followed by a two-octet length of the key, and then body\n     * of the key packet.  (Note that this is an old-style packet header for\n     * a key packet with two-octet length.)  A subkey binding signature\n     * (type 0x18) or primary key binding signature (type 0x19) then hashes\n     * the subkey using the same format as the main key (also using 0x99 as\n     * the first octet). */\n    keyBinding: 25,\n    /** 0x1F: Signature directly on a key\n     *\n     * This signature is calculated directly on a key.  It binds the\n     * information in the Signature subpackets to the key, and is\n     * appropriate to be used for subpackets that provide information\n     * about the key, such as the Revocation Key subpacket.  It is also\n     * appropriate for statements that non-self certifiers want to make\n     * about the key itself, rather than the binding between a key and a\n     * name. */\n    key: 31,\n    /** 0x20: Key revocation signature\n     *\n     * The signature is calculated directly on the key being revoked.  A\n     * revoked key is not to be used.  Only revocation signatures by the\n     * key being revoked, or by an authorized revocation key, should be\n     * considered valid revocation signatures.a */\n    keyRevocation: 32,\n    /** 0x28: Subkey revocation signature\n     *\n     * The signature is calculated directly on the subkey being revoked.\n     * A revoked subkey is not to be used.  Only revocation signatures\n     * by the top-level signature key that is bound to this subkey, or\n     * by an authorized revocation key, should be considered valid\n     * revocation signatures.\n     *\n     * Key revocation signatures (types 0x20 and 0x28)\n     * hash only the key being revoked. */\n    subkeyRevocation: 40,\n    /** 0x40: Timestamp signature.\n     * This signature is only meaningful for the timestamp contained in\n     * it. */\n    timestamp: 64,\n    /** 0x50: Third-Party Confirmation signature.\n     *\n     * This signature is a signature over some other OpenPGP Signature\n     * packet(s).  It is analogous to a notary seal on the signed data.\n     * A third-party signature SHOULD include Signature Target\n     * subpacket(s) to give easy identification.  Note that we really do\n     * mean SHOULD.  There are plausible uses for this (such as a blind\n     * party that only sees the signature, not the key or source\n     * document) that cannot include a target subpacket. */\n    thirdParty: 80\n  },\n\n  /** Signature subpacket type\n   * @enum {Integer}\n   * @readonly\n   */\n  signatureSubpacket: {\n    signatureCreationTime: 2,\n    signatureExpirationTime: 3,\n    exportableCertification: 4,\n    trustSignature: 5,\n    regularExpression: 6,\n    revocable: 7,\n    keyExpirationTime: 9,\n    placeholderBackwardsCompatibility: 10,\n    preferredSymmetricAlgorithms: 11,\n    revocationKey: 12,\n    issuerKeyID: 16,\n    notationData: 20,\n    preferredHashAlgorithms: 21,\n    preferredCompressionAlgorithms: 22,\n    keyServerPreferences: 23,\n    preferredKeyServer: 24,\n    primaryUserID: 25,\n    policyURI: 26,\n    keyFlags: 27,\n    signersUserID: 28,\n    reasonForRevocation: 29,\n    features: 30,\n    signatureTarget: 31,\n    embeddedSignature: 32,\n    issuerFingerprint: 33,\n    preferredAEADAlgorithms: 34,\n    preferredCipherSuites: 39\n  },\n\n  /** Key flags\n   * @enum {Integer}\n   * @readonly\n   */\n  keyFlags: {\n    /** 0x01 - This key may be used to certify other keys. */\n    certifyKeys: 1,\n    /** 0x02 - This key may be used to sign data. */\n    signData: 2,\n    /** 0x04 - This key may be used to encrypt communications. */\n    encryptCommunication: 4,\n    /** 0x08 - This key may be used to encrypt storage. */\n    encryptStorage: 8,\n    /** 0x10 - The private component of this key may have been split\n     *        by a secret-sharing mechanism. */\n    splitPrivateKey: 16,\n    /** 0x20 - This key may be used for authentication. */\n    authentication: 32,\n    /** 0x80 - The private component of this key may be in the\n     *        possession of more than one person. */\n    sharedPrivateKey: 128\n  },\n\n  /** Armor type\n   * @enum {Integer}\n   * @readonly\n   */\n  armor: {\n    multipartSection: 0,\n    multipartLast: 1,\n    signed: 2,\n    message: 3,\n    publicKey: 4,\n    privateKey: 5,\n    signature: 6\n  },\n\n  /** {@link https://tools.ietf.org/html/rfc4880#section-5.2.3.23|RFC4880, section 5.2.3.23}\n   * @enum {Integer}\n   * @readonly\n   */\n  reasonForRevocation: {\n    /** No reason specified (key revocations or cert revocations) */\n    noReason: 0,\n    /** Key is superseded (key revocations) */\n    keySuperseded: 1,\n    /** Key material has been compromised (key revocations) */\n    keyCompromised: 2,\n    /** Key is retired and no longer used (key revocations) */\n    keyRetired: 3,\n    /** User ID information is no longer valid (cert revocations) */\n    userIDInvalid: 32\n  },\n\n  /** {@link https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-04#section-5.2.3.25|RFC4880bis-04, section 5.2.3.25}\n   * @enum {Integer}\n   * @readonly\n   */\n  features: {\n    /** 0x01 - Modification Detection (packets 18 and 19) */\n    modificationDetection: 1,\n    /** 0x02 - AEAD Encrypted Data Packet (packet 20) and version 5\n     *         Symmetric-Key Encrypted Session Key Packets (packet 3) */\n    aead: 2,\n    /** 0x04 - Version 5 Public-Key Packet format and corresponding new\n      *        fingerprint format */\n    v5Keys: 4,\n    seipdv2: 8\n  },\n\n  /**\n   * Asserts validity of given value and converts from string/integer to integer.\n   * @param {Object} type target enum type\n   * @param {String|Integer} e value to check and/or convert\n   * @returns {Integer} enum value if it exists\n   * @throws {Error} if the value is invalid\n   */\n  write: function(type, e) {\n    if (typeof e === 'number') {\n      e = this.read(type, e);\n    }\n\n    if (type[e] !== undefined) {\n      return type[e];\n    }\n\n    throw new Error('Invalid enum value.');\n  },\n\n  /**\n   * Converts enum integer value to the corresponding string, if it exists.\n   * @param {Object} type target enum type\n   * @param {Integer} e value to convert\n   * @returns {String} name of enum value if it exists\n   * @throws {Error} if the value is invalid\n   */\n  read: function(type, e) {\n    if (!type[byValue]) {\n      type[byValue] = [];\n      Object.entries(type).forEach(([key, value]) => {\n        type[byValue][value] = key;\n      });\n    }\n\n    if (type[byValue][e] !== undefined) {\n      return type[byValue][e];\n    }\n\n    throw new Error('Invalid enum value.');\n  }\n};\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * Global configuration values.\n */\n\nimport enums from '../enums';\n\nexport default {\n  /**\n   * @memberof module:config\n   * @property {Integer} preferredHashAlgorithm Default hash algorithm {@link module:enums.hash}\n   */\n  preferredHashAlgorithm: enums.hash.sha512,\n  /**\n   * @memberof module:config\n   * @property {Integer} preferredSymmetricAlgorithm Default encryption cipher {@link module:enums.symmetric}\n   */\n  preferredSymmetricAlgorithm: enums.symmetric.aes256,\n  /**\n   * @memberof module:config\n   * @property {Integer} compression Default compression algorithm {@link module:enums.compression}\n   */\n  preferredCompressionAlgorithm: enums.compression.uncompressed,\n  /**\n   * Use Authenticated Encryption with Additional Data (AEAD) protection for symmetric encryption.\n   * This option is applicable to:\n   * - key generation (encryption key preferences),\n   * - password-based message encryption, and\n   * - private key encryption.\n   * In the case of message encryption using public keys, the encryption key preferences are respected instead.\n   * Note: not all OpenPGP implementations are compatible with this option.\n   * @see {@link https://tools.ietf.org/html/draft-ietf-openpgp-crypto-refresh-10.html|draft-crypto-refresh-10}\n   * @memberof module:config\n   * @property {Boolean} aeadProtect\n   */\n  aeadProtect: false,\n  /**\n   * When reading OpenPGP v4 private keys (e.g. those generated in OpenPGP.js when not setting `config.v5Keys = true`)\n   * which were encrypted by OpenPGP.js v5 (or older) using `config.aeadProtect = true`,\n   * this option must be set, otherwise key parsing and/or key decryption will fail.\n   * Note: only set this flag if you know that the keys are of the legacy type, as non-legacy keys\n   * will be processed incorrectly.\n   */\n  parseAEADEncryptedV4KeysAsLegacy: false,\n  /**\n   * Default Authenticated Encryption with Additional Data (AEAD) encryption mode\n   * Only has an effect when aeadProtect is set to true.\n   * @memberof module:config\n   * @property {Integer} preferredAEADAlgorithm Default AEAD mode {@link module:enums.aead}\n   */\n  preferredAEADAlgorithm: enums.aead.gcm,\n  /**\n   * Chunk Size Byte for Authenticated Encryption with Additional Data (AEAD) mode\n   * Only has an effect when aeadProtect is set to true.\n   * Must be an integer value from 0 to 56.\n   * @memberof module:config\n   * @property {Integer} aeadChunkSizeByte\n   */\n  aeadChunkSizeByte: 12,\n  /**\n   * Use v6 keys.\n   * Note: not all OpenPGP implementations are compatible with this option.\n   * **FUTURE OPENPGP.JS VERSIONS MAY BREAK COMPATIBILITY WHEN USING THIS OPTION**\n   * @memberof module:config\n   * @property {Boolean} v6Keys\n   */\n  v6Keys: false,\n  /**\n   * Enable parsing v5 keys and v5 signatures (which is different from the AEAD-encrypted SEIPDv2 packet).\n   * These are non-standard entities, which in the crypto-refresh have been superseded\n   * by v6 keys and v6 signatures, respectively.\n   * However, generation of v5 entities was supported behind config flag in OpenPGP.js v5, and some other libraries,\n   * hence parsing them might be necessary in some cases.\n   * @memberof module:config\n   * @property {Boolean} enableParsingV5Entities\n   */\n  enableParsingV5Entities: false,\n  /**\n   * S2K (String to Key) type, used for key derivation in the context of secret key encryption\n   * and password-encrypted data. Weaker s2k options are not allowed.\n   * Note: Argon2 is the strongest option but not all OpenPGP implementations are compatible with it\n   * (pending standardisation).\n   * @memberof module:config\n   * @property {enums.s2k.argon2|enums.s2k.iterated} s2kType {@link module:enums.s2k}\n   */\n  s2kType: enums.s2k.iterated,\n  /**\n   * {@link https://tools.ietf.org/html/rfc4880#section-3.7.1.3| RFC4880 3.7.1.3}:\n   * Iteration Count Byte for Iterated and Salted S2K (String to Key).\n   * Only relevant if `config.s2kType` is set to `enums.s2k.iterated`.\n   * Note: this is the exponent value, not the final number of iterations (refer to specs for more details).\n   * @memberof module:config\n   * @property {Integer} s2kIterationCountByte\n   */\n  s2kIterationCountByte: 224,\n  /**\n   * {@link https://tools.ietf.org/html/draft-ietf-openpgp-crypto-refresh-07.html#section-3.7.1.4| draft-crypto-refresh 3.7.1.4}:\n   * Argon2 parameters for S2K (String to Key).\n   * Only relevant if `config.s2kType` is set to `enums.s2k.argon2`.\n   * Default settings correspond to the second recommendation from RFC9106 (\"uniformly safe option\"),\n   * to ensure compatibility with memory-constrained environments.\n   * For more details on the choice of parameters, see https://tools.ietf.org/html/rfc9106#section-4.\n   * @memberof module:config\n   * @property {Object} params\n   * @property {Integer} params.passes - number of iterations t\n   * @property {Integer} params.parallelism - degree of parallelism p\n   * @property {Integer} params.memoryExponent - one-octet exponent indicating the memory size, which will be: 2**memoryExponent kibibytes.\n   */\n  s2kArgon2Params: {\n    passes: 3,\n    parallelism: 4, // lanes\n    memoryExponent: 16 // 64 MiB of RAM\n  },\n  /**\n   * Allow decryption of messages without integrity protection.\n   * This is an **insecure** setting:\n   *  - message modifications cannot be detected, thus processing the decrypted data is potentially unsafe.\n   *  - it enables downgrade attacks against integrity-protected messages.\n   * @memberof module:config\n   * @property {Boolean} allowUnauthenticatedMessages\n   */\n  allowUnauthenticatedMessages: false,\n  /**\n   * Allow streaming unauthenticated data before its integrity has been checked. This would allow the application to\n   * process large streams while limiting memory usage by releasing the decrypted chunks as soon as possible\n   * and deferring checking their integrity until the decrypted stream has been read in full.\n   *\n   * This setting is **insecure** if the encrypted data has been corrupted by a malicious entity:\n   * - if the partially decrypted message is processed further or displayed to the user, it opens up the possibility of attacks such as EFAIL\n   *    (see https://efail.de/).\n   * - an attacker with access to traces or timing info of internal processing errors could learn some info about the data.\n   *\n   * NB: this setting does not apply to AEAD-encrypted data, where the AEAD data chunk is never released until integrity is confirmed.\n   * @memberof module:config\n   * @property {Boolean} allowUnauthenticatedStream\n   */\n  allowUnauthenticatedStream: false,\n  /**\n   * Minimum RSA key size allowed for key generation and message signing, verification and encryption.\n   * The default is 2047 since due to a bug, previous versions of OpenPGP.js could generate 2047-bit keys instead of 2048-bit ones.\n   * @memberof module:config\n   * @property {Number} minRSABits\n   */\n  minRSABits: 2047,\n  /**\n   * Work-around for rare GPG decryption bug when encrypting with multiple passwords.\n   * **Slower and slightly less secure**\n   * @memberof module:config\n   * @property {Boolean} passwordCollisionCheck\n   */\n  passwordCollisionCheck: false,\n  /**\n   * Allow decryption using RSA keys without `encrypt` flag.\n   * This setting is potentially insecure, but it is needed to get around an old openpgpjs bug\n   * where key flags were ignored when selecting a key for encryption.\n   * @memberof module:config\n   * @property {Boolean} allowInsecureDecryptionWithSigningKeys\n   */\n  allowInsecureDecryptionWithSigningKeys: false,\n  /**\n   * Allow verification of message signatures with keys whose validity at the time of signing cannot be determined.\n   * Instead, a verification key will also be consider valid as long as it is valid at the current time.\n   * This setting is potentially insecure, but it is needed to verify messages signed with keys that were later reformatted,\n   * and have self-signature's creation date that does not match the primary key creation date.\n   * @memberof module:config\n   * @property {Boolean} allowInsecureDecryptionWithSigningKeys\n   */\n  allowInsecureVerificationWithReformattedKeys: false,\n  /**\n   * Allow using keys that do not have any key flags set.\n   * Key flags are needed to restrict key usage to specific purposes: for instance, a signing key could only be allowed to certify other keys, and not sign messages\n   * (see https://www.ietf.org/archive/id/draft-ietf-openpgp-crypto-refresh-10.html#section-5.2.3.29).\n   * Some older keys do not declare any key flags, which means they are not allowed to be used for any operation.\n   * This setting allows using such keys for any operation for which they are compatible, based on their public key algorithm.\n   */\n  allowMissingKeyFlags: false,\n  /**\n   * Enable constant-time decryption of RSA- and ElGamal-encrypted session keys, to hinder Bleichenbacher-like attacks (https://link.springer.com/chapter/10.1007/BFb0055716).\n   * This setting has measurable performance impact and it is only helpful in application scenarios where both of the following conditions apply:\n   * - new/incoming messages are automatically decrypted (without user interaction);\n   * - an attacker can determine how long it takes to decrypt each message (e.g. due to decryption errors being logged remotely).\n   * See also `constantTimePKCS1DecryptionSupportedSymmetricAlgorithms`.\n   * @memberof module:config\n   * @property {Boolean} constantTimePKCS1Decryption\n   */\n  constantTimePKCS1Decryption: false,\n  /**\n   * This setting is only meaningful if `constantTimePKCS1Decryption` is enabled.\n   * Decryption of RSA- and ElGamal-encrypted session keys of symmetric algorithms different from the ones specified here will fail.\n   * However, the more algorithms are added, the slower the decryption procedure becomes.\n   * @memberof module:config\n   * @property {Set<Integer>} constantTimePKCS1DecryptionSupportedSymmetricAlgorithms {@link module:enums.symmetric}\n   */\n  constantTimePKCS1DecryptionSupportedSymmetricAlgorithms: new Set([enums.symmetric.aes128, enums.symmetric.aes192, enums.symmetric.aes256]),\n  /**\n   * @memberof module:config\n   * @property {Boolean} ignoreUnsupportedPackets Ignore unsupported/unrecognizable packets on parsing instead of throwing an error\n   */\n  ignoreUnsupportedPackets: true,\n  /**\n   * @memberof module:config\n   * @property {Boolean} ignoreMalformedPackets Ignore malformed packets on parsing instead of throwing an error\n   */\n  ignoreMalformedPackets: false,\n  /**\n   * @memberof module:config\n   * @property {Boolean} enforceGrammar whether parsed OpenPGP messages must comform to the OpenPGP grammar\n   *    defined in https://www.rfc-editor.org/rfc/rfc9580.html#name-openpgp-messages .\n   */\n  enforceGrammar: true,\n  /**\n   * Parsing of packets is normally restricted to a predefined set of packets. For example a Sym. Encrypted Integrity Protected Data Packet can only\n   * contain a certain set of packets including LiteralDataPacket. With this setting we can allow additional packets, which is probably not advisable\n   * as a global config setting, but can be used for specific function calls (e.g. decrypt method of Message).\n   * @memberof module:config\n   * @property {Array} additionalAllowedPackets Allow additional packets on parsing. Defined as array of packet classes, e.g. [PublicKeyPacket]\n   */\n  additionalAllowedPackets: [],\n  /**\n   * @memberof module:config\n   * @property {Boolean} showVersion Whether to include {@link module:config/config.versionString} in armored messages\n   */\n  showVersion: false,\n  /**\n   * @memberof module:config\n   * @property {Boolean} showComment Whether to include {@link module:config/config.commentString} in armored messages\n   */\n  showComment: false,\n  /**\n   * @memberof module:config\n   * @property {String} versionString A version string to be included in armored messages\n   */\n  versionString: 'OpenPGP.js VERSION',\n  /**\n   * @memberof module:config\n   * @property {String} commentString A comment string to be included in armored messages\n   */\n  commentString: 'https://openpgpjs.org',\n\n  /**\n   * Max userID string length (used for parsing)\n   * @memberof module:config\n   * @property {Integer} maxUserIDLength\n   */\n  maxUserIDLength: 1024 * 5,\n  /**\n   * Contains notatations that are considered \"known\". Known notations do not trigger\n   * validation error when the notation is marked as critical.\n   * @memberof module:config\n   * @property {Array} knownNotations\n   */\n  knownNotations: [],\n  /**\n   * If true, a salt notation is used to randomize signatures generated by v4 and v5 keys (v6 signatures are always non-deterministic, by design).\n   * This protects EdDSA signatures from potentially leaking the secret key in case of faults (i.e. bitflips) which, in principle, could occur\n   * during the signing computation. It is added to signatures of any algo for simplicity, and as it may also serve as protection in case of\n   * weaknesses in the hash algo, potentially hindering e.g. some chosen-prefix attacks.\n   * NOTE: the notation is interoperable, but will reveal that the signature has been generated using OpenPGP.js, which may not be desirable in some cases.\n   */\n  nonDeterministicSignaturesViaNotation: true,\n  /**\n   * Whether to use the the noble-curves library for curves (other than Curve25519) that are not supported by the available native crypto API.\n   * When false, certain standard curves will not be supported (depending on the platform).\n   * @memberof module:config\n   * @property {Boolean} useEllipticFallback\n   */\n  useEllipticFallback: true,\n  /**\n   * Reject insecure hash algorithms\n   * @memberof module:config\n   * @property {Set<Integer>} rejectHashAlgorithms {@link module:enums.hash}\n   */\n  rejectHashAlgorithms: new Set([enums.hash.md5, enums.hash.ripemd]),\n  /**\n   * Reject insecure message hash algorithms\n   * @memberof module:config\n   * @property {Set<Integer>} rejectMessageHashAlgorithms {@link module:enums.hash}\n   */\n  rejectMessageHashAlgorithms: new Set([enums.hash.md5, enums.hash.ripemd, enums.hash.sha1]),\n  /**\n   * Reject insecure public key algorithms for key generation and message encryption, signing or verification\n   * @memberof module:config\n   * @property {Set<Integer>} rejectPublicKeyAlgorithms {@link module:enums.publicKey}\n   */\n  rejectPublicKeyAlgorithms: new Set([enums.publicKey.elgamal, enums.publicKey.dsa]),\n  /**\n   * Reject non-standard curves for key generation, message encryption, signing or verification\n   * @memberof module:config\n   * @property {Set<String>} rejectCurves {@link module:enums.curve}\n   */\n  rejectCurves: new Set([enums.curve.secp256k1])\n};\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/* eslint-disable no-console */\n\n/**\n * This object contains utility functions\n * @module util\n */\n\nimport { concat as streamConcat, transform as streamTransform, concatUint8Array, isStream, isUint8Array } from '@openpgp/web-stream-tools';\nimport { createRequire } from 'module'; // Must be stripped in browser built\nimport enums from './enums';\nimport defaultConfig from './config';\n\nconst debugMode = (() => {\n  try {\n    return process.env.NODE_ENV === 'development'; // eslint-disable-line no-process-env\n  } catch (e) {}\n  return false;\n})();\n\nconst util = {\n  isString: function(data) {\n    return typeof data === 'string' || data instanceof String;\n  },\n\n  nodeRequire: createRequire(import.meta.url),\n\n  isArray: function(data) {\n    return data instanceof Array;\n  },\n\n  isUint8Array: isUint8Array,\n\n  isStream: isStream,\n\n  /**\n   * Load noble-curves lib on demand and return the requested curve function\n   * @param {enums.publicKey} publicKeyAlgo\n   * @param {enums.curve} [curveName] - for algos supporting different curves (e.g. ECDSA)\n   * @returns curve implementation\n   * @throws on unrecognized curve, or curve not implemented by noble-curve\n   */\n  getNobleCurve: async (publicKeyAlgo, curveName) => {\n    if (!defaultConfig.useEllipticFallback) {\n      throw new Error('This curve is only supported in the full build of OpenPGP.js');\n    }\n\n    const { nobleCurves } = await import('./crypto/public_key/elliptic/noble_curves');\n    switch (publicKeyAlgo) {\n      case enums.publicKey.ecdh:\n      case enums.publicKey.ecdsa: {\n        const curve = nobleCurves.get(curveName);\n        if (!curve) throw new Error('Unsupported curve');\n        return curve;\n      }\n      case enums.publicKey.x448:\n        return nobleCurves.get('x448');\n      case enums.publicKey.ed448:\n        return nobleCurves.get('ed448');\n      default:\n        throw new Error('Unsupported curve');\n    }\n  },\n\n  readNumber: function (bytes) {\n    let n = 0;\n    for (let i = 0; i < bytes.length; i++) {\n      n += (256 ** i) * bytes[bytes.length - 1 - i];\n    }\n    return n;\n  },\n\n  writeNumber: function (n, bytes) {\n    const b = new Uint8Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      b[i] = (n >> (8 * (bytes - i - 1))) & 0xFF;\n    }\n\n    return b;\n  },\n\n  readDate: function (bytes) {\n    const n = util.readNumber(bytes);\n    const d = new Date(n * 1000);\n    return d;\n  },\n\n  writeDate: function (time) {\n    const numeric = Math.floor(time.getTime() / 1000);\n\n    return util.writeNumber(numeric, 4);\n  },\n\n  normalizeDate: function (time = Date.now()) {\n    return time === null || time === Infinity ? time : new Date(Math.floor(+time / 1000) * 1000);\n  },\n\n  /**\n   * Read one MPI from bytes in input\n   * @param {Uint8Array} bytes - Input data to parse\n   * @returns {Uint8Array} Parsed MPI.\n   */\n  readMPI: function (bytes) {\n    const bits = (bytes[0] << 8) | bytes[1];\n    const bytelen = (bits + 7) >>> 3;\n    // There is a decryption oracle risk here by enforcing the MPI length using `readExactSubarray` in the context of SEIPDv1 encrypted signatures,\n    // where unauthenticated streamed decryption is done (via `config.allowUnauthenticatedStream`), since the decrypted signature data being processed\n    // has not been authenticated (yet).\n    // However, such config setting is known to be insecure, and there are other packet parsing errors that can cause similar issues.\n    // Also, AEAD is also not affected.\n    return util.readExactSubarray(bytes, 2, 2 + bytelen);\n  },\n\n  /**\n   * Read exactly `end - start` bytes from input.\n   * This is a stricter version of `.subarray`.\n   * @param {Uint8Array} input - Input data to parse\n   * @returns {Uint8Array} subarray of size always equal to `end - start`\n   * @throws if the input array is too short.\n   */\n  readExactSubarray: function (input, start, end) {\n    if (input.length < (end - start)) {\n      throw new Error('Input array too short');\n    }\n    return input.subarray(start, end);\n  },\n\n  /**\n   * Left-pad Uint8Array to length by adding 0x0 bytes\n   * @param {Uint8Array} bytes - Data to pad\n   * @param {Number} length - Padded length\n   * @returns {Uint8Array} Padded bytes.\n   */\n  leftPad(bytes, length) {\n    if (bytes.length > length) {\n      throw new Error('Input array too long');\n    }\n    const padded = new Uint8Array(length);\n    const offset = length - bytes.length;\n    padded.set(bytes, offset);\n    return padded;\n  },\n\n  /**\n   * Convert a Uint8Array to an MPI-formatted Uint8Array.\n   * @param {Uint8Array} bin - An array of 8-bit integers to convert\n   * @returns {Uint8Array} MPI-formatted Uint8Array.\n   */\n  uint8ArrayToMPI: function (bin) {\n    const bitSize = util.uint8ArrayBitLength(bin);\n    if (bitSize === 0) {\n      throw new Error('Zero MPI');\n    }\n    const stripped = bin.subarray(bin.length - Math.ceil(bitSize / 8));\n    const prefix = new Uint8Array([(bitSize & 0xFF00) >> 8, bitSize & 0xFF]);\n    return util.concatUint8Array([prefix, stripped]);\n  },\n\n  /**\n   * Return bit length of the input data\n   * @param {Uint8Array} bin input data (big endian)\n   * @returns bit length\n   */\n  uint8ArrayBitLength: function (bin) {\n    let i; // index of leading non-zero byte\n    for (i = 0; i < bin.length; i++) if (bin[i] !== 0) break;\n    if (i === bin.length) {\n      return 0;\n    }\n    const stripped = bin.subarray(i);\n    return (stripped.length - 1) * 8 + util.nbits(stripped[0]);\n  },\n\n  /**\n   * Convert a hex string to an array of 8-bit integers\n   * @param {String} hex - A hex string to convert\n   * @returns {Uint8Array} An array of 8-bit integers.\n   */\n  hexToUint8Array: function (hex) {\n    const result = new Uint8Array(hex.length >> 1);\n    for (let k = 0; k < hex.length >> 1; k++) {\n      result[k] = parseInt(hex.substr(k << 1, 2), 16);\n    }\n    return result;\n  },\n\n  /**\n   * Convert an array of 8-bit integers to a hex string\n   * @param {Uint8Array} bytes - Array of 8-bit integers to convert\n   * @returns {String} Hexadecimal representation of the array.\n   */\n  uint8ArrayToHex: function (bytes) {\n    const hexAlphabet = '0123456789abcdef';\n    let s = '';\n    bytes.forEach(v => { s += hexAlphabet[v >> 4] + hexAlphabet[v & 15]; });\n    return s;\n  },\n\n  /**\n   * Convert a string to an array of 8-bit integers\n   * @param {String} str - String to convert\n   * @returns {Uint8Array} An array of 8-bit integers.\n   */\n  stringToUint8Array: function (str) {\n    return streamTransform(str, str => {\n      if (!util.isString(str)) {\n        throw new Error('stringToUint8Array: Data must be in the form of a string');\n      }\n\n      const result = new Uint8Array(str.length);\n      for (let i = 0; i < str.length; i++) {\n        result[i] = str.charCodeAt(i);\n      }\n      return result;\n    });\n  },\n\n  /**\n   * Convert an array of 8-bit integers to a string\n   * @param {Uint8Array} bytes - An array of 8-bit integers to convert\n   * @returns {String} String representation of the array.\n   */\n  uint8ArrayToString: function (bytes) {\n    bytes = new Uint8Array(bytes);\n    const result = [];\n    const bs = 1 << 14;\n    const j = bytes.length;\n\n    for (let i = 0; i < j; i += bs) {\n      result.push(String.fromCharCode.apply(String, bytes.subarray(i, i + bs < j ? i + bs : j)));\n    }\n    return result.join('');\n  },\n\n  /**\n   * Convert a native javascript string to a Uint8Array of utf8 bytes\n   * @param {String|ReadableStream} str - The string to convert\n   * @returns {Uint8Array|ReadableStream} A valid squence of utf8 bytes.\n   */\n  encodeUTF8: function (str) {\n    const encoder = new TextEncoder('utf-8');\n    // eslint-disable-next-line no-inner-declarations\n    function process(value, lastChunk = false) {\n      return encoder.encode(value, { stream: !lastChunk });\n    }\n    return streamTransform(str, process, () => process('', true));\n  },\n\n  /**\n   * Convert a Uint8Array of utf8 bytes to a native javascript string\n   * @param {Uint8Array|ReadableStream} utf8 - A valid squence of utf8 bytes\n   * @returns {String|ReadableStream} A native javascript string.\n   */\n  decodeUTF8: function (utf8) {\n    const decoder = new TextDecoder('utf-8');\n    // eslint-disable-next-line no-inner-declarations\n    function process(value, lastChunk = false) {\n      return decoder.decode(value, { stream: !lastChunk });\n    }\n    return streamTransform(utf8, process, () => process(new Uint8Array(), true));\n  },\n\n  /**\n   * Concat a list of Uint8Arrays, Strings or Streams\n   * The caller must not mix Uint8Arrays with Strings, but may mix Streams with non-Streams.\n   * @param {Array<Uint8Array|String|ReadableStream>} Array - Of Uint8Arrays/Strings/Streams to concatenate\n   * @returns {Uint8Array|String|ReadableStream} Concatenated array.\n   */\n  concat: streamConcat,\n\n  /**\n   * Concat Uint8Arrays\n   * @param {Array<Uint8Array>} Array - Of Uint8Arrays to concatenate\n   * @returns {Uint8Array} Concatenated array.\n   */\n  concatUint8Array: concatUint8Array,\n\n  /**\n   * Check Uint8Array equality\n   * @param {Uint8Array} array1 - First array\n   * @param {Uint8Array} array2 - Second array\n   * @returns {Boolean} Equality.\n   */\n  equalsUint8Array: function (array1, array2) {\n    if (!util.isUint8Array(array1) || !util.isUint8Array(array2)) {\n      throw new Error('Data must be in the form of a Uint8Array');\n    }\n\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < array1.length; i++) {\n      if (array1[i] !== array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  /**\n   * Same as Array.findLastIndex, which is not supported on Safari 14 .\n   * @param {Array} arr\n   * @param {function(element, index, arr): boolean} findFn\n   * @return index of last element matching `findFn`, -1 if not found\n   */\n  findLastIndex: function(arr, findFn) {\n    for (let i = arr.length; i >= 0; i--) {\n      if (findFn(arr[i], i, arr)) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Calculates a 16bit sum of a Uint8Array by adding each character\n   * codes modulus 65535\n   * @param {Uint8Array} Uint8Array - To create a sum of\n   * @returns {Uint8Array} 2 bytes containing the sum of all charcodes % 65535.\n   */\n  writeChecksum: function (text) {\n    let s = 0;\n    for (let i = 0; i < text.length; i++) {\n      s = (s + text[i]) & 0xFFFF;\n    }\n    return util.writeNumber(s, 2);\n  },\n\n  /**\n   * Helper function to print a debug message. Debug\n   * messages are only printed if\n   * @param {String} str - String of the debug message\n   */\n  printDebug: function (str) {\n    if (debugMode) {\n      console.log('[OpenPGP.js debug]', str);\n    }\n  },\n\n  /**\n   * Helper function to print a debug error. Debug\n   * messages are only printed if\n   * @param {String} str - String of the debug message\n   */\n  printDebugError: function (error) {\n    if (debugMode) {\n      console.error('[OpenPGP.js debug]', error);\n    }\n  },\n\n  // returns bit length of the integer x\n  nbits: function (x) {\n    let r = 1;\n    let t = x >>> 16;\n    if (t !== 0) {\n      x = t;\n      r += 16;\n    }\n    t = x >> 8;\n    if (t !== 0) {\n      x = t;\n      r += 8;\n    }\n    t = x >> 4;\n    if (t !== 0) {\n      x = t;\n      r += 4;\n    }\n    t = x >> 2;\n    if (t !== 0) {\n      x = t;\n      r += 2;\n    }\n    t = x >> 1;\n    if (t !== 0) {\n      x = t;\n      r += 1;\n    }\n    return r;\n  },\n\n  /**\n   * If S[1] == 0, then double(S) == (S[2..128] || 0);\n   * otherwise, double(S) == (S[2..128] || 0) xor\n   * (zeros(120) || 10000111).\n   *\n   * Both OCB and EAX (through CMAC) require this function to be constant-time.\n   *\n   * @param {Uint8Array} data\n   */\n  double: function(data) {\n    const doubleVar = new Uint8Array(data.length);\n    const last = data.length - 1;\n    for (let i = 0; i < last; i++) {\n      doubleVar[i] = (data[i] << 1) ^ (data[i + 1] >> 7);\n    }\n    doubleVar[last] = (data[last] << 1) ^ ((data[0] >> 7) * 0x87);\n    return doubleVar;\n  },\n\n  /**\n   * Shift a Uint8Array to the right by n bits\n   * @param {Uint8Array} array - The array to shift\n   * @param {Integer} bits - Amount of bits to shift (MUST be smaller\n   * than 8)\n   * @returns {String} Resulting array.\n   */\n  shiftRight: function (array, bits) {\n    if (bits) {\n      for (let i = array.length - 1; i >= 0; i--) {\n        array[i] >>= bits;\n        if (i > 0) {\n          array[i] |= (array[i - 1] << (8 - bits));\n        }\n      }\n    }\n    return array;\n  },\n\n  /**\n   * Get native Web Cryptography API.\n   * @returns {Object} The SubtleCrypto API\n   * @throws if the API is not available\n   */\n  getWebCrypto: function() {\n    const globalWebCrypto = typeof globalThis !== 'undefined' && globalThis.crypto && globalThis.crypto.subtle;\n    // Fallback for Node 16, which does not expose WebCrypto as a global\n    const webCrypto = globalWebCrypto || this.getNodeCrypto()?.webcrypto.subtle;\n    if (!webCrypto) {\n      throw new Error('The WebCrypto API is not available');\n    }\n    return webCrypto;\n  },\n\n  /**\n   * Get native Node.js crypto api.\n   * @returns {Object} The crypto module or 'undefined'.\n   */\n  getNodeCrypto: function() {\n    return this.nodeRequire('crypto');\n  },\n\n  getNodeZlib: function() {\n    return this.nodeRequire('zlib');\n  },\n\n  /**\n   * Get native Node.js Buffer constructor. This should be used since\n   * Buffer is not available under browserify.\n   * @returns {Function} The Buffer constructor or 'undefined'.\n   */\n  getNodeBuffer: function() {\n    return (this.nodeRequire('buffer') || {}).Buffer;\n  },\n\n  getHardwareConcurrency: function() {\n    if (typeof navigator !== 'undefined') {\n      return navigator.hardwareConcurrency || 1;\n    }\n\n    const os = this.nodeRequire('os'); // Assume we're on Node.js.\n    return os.cpus().length;\n  },\n\n  /**\n   * Test email format to ensure basic compliance:\n   * - must include a single @\n   * - no control or space unicode chars allowed\n   * - no backslash and square brackets (as the latter can mess with the userID parsing)\n   * - cannot end with a punctuation char\n   * These checks are not meant to be exhaustive; applications are strongly encouraged to implement stricter validation,\n   * e.g. based on the W3C HTML spec (https://html.spec.whatwg.org/multipage/input.html#email-state-(type=email)).\n   */\n  isEmailAddress: function(data) {\n    if (!util.isString(data)) {\n      return false;\n    }\n    const re = /^[^\\p{C}\\p{Z}@<>\\\\]+@[^\\p{C}\\p{Z}@<>\\\\]+[^\\p{C}\\p{Z}\\p{P}]$/u;\n    return re.test(data);\n  },\n\n  /**\n   * Normalize line endings to <CR><LF>\n   * Support any encoding where CR=0x0D, LF=0x0A\n   */\n  canonicalizeEOL: function(data) {\n    const CR = 13;\n    const LF = 10;\n    let carryOverCR = false;\n\n    return streamTransform(data, bytes => {\n      if (carryOverCR) {\n        bytes = util.concatUint8Array([new Uint8Array([CR]), bytes]);\n      }\n\n      if (bytes[bytes.length - 1] === CR) {\n        carryOverCR = true;\n        bytes = bytes.subarray(0, -1);\n      } else {\n        carryOverCR = false;\n      }\n\n      let index;\n      const indices = [];\n      for (let i = 0; ; i = index) {\n        index = bytes.indexOf(LF, i) + 1;\n        if (index) {\n          if (bytes[index - 2] !== CR) indices.push(index);\n        } else {\n          break;\n        }\n      }\n      if (!indices.length) {\n        return bytes;\n      }\n\n      const normalized = new Uint8Array(bytes.length + indices.length);\n      let j = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const sub = bytes.subarray(indices[i - 1] || 0, indices[i]);\n        normalized.set(sub, j);\n        j += sub.length;\n        normalized[j - 1] = CR;\n        normalized[j] = LF;\n        j++;\n      }\n      normalized.set(bytes.subarray(indices[indices.length - 1] || 0), j);\n      return normalized;\n    }, () => (carryOverCR ? new Uint8Array([CR]) : undefined));\n  },\n\n  /**\n   * Convert line endings from canonicalized <CR><LF> to native <LF>\n   * Support any encoding where CR=0x0D, LF=0x0A\n   */\n  nativeEOL: function(data) {\n    const CR = 13;\n    const LF = 10;\n    let carryOverCR = false;\n\n    return streamTransform(data, bytes => {\n      if (carryOverCR && bytes[0] !== LF) {\n        bytes = util.concatUint8Array([new Uint8Array([CR]), bytes]);\n      } else {\n        bytes = new Uint8Array(bytes); // Don't mutate passed bytes\n      }\n\n      if (bytes[bytes.length - 1] === CR) {\n        carryOverCR = true;\n        bytes = bytes.subarray(0, -1);\n      } else {\n        carryOverCR = false;\n      }\n\n      let index;\n      let j = 0;\n      for (let i = 0; i !== bytes.length; i = index) {\n        index = bytes.indexOf(CR, i) + 1;\n        if (!index) index = bytes.length;\n        const last = index - (bytes[index] === LF ? 1 : 0);\n        if (i) bytes.copyWithin(j, i, last);\n        j += last - i;\n      }\n      return bytes.subarray(0, j);\n    }, () => (carryOverCR ? new Uint8Array([CR]) : undefined));\n  },\n\n  /**\n   * Remove trailing spaces, carriage returns and tabs from each line\n   */\n  removeTrailingSpaces: function(text) {\n    return text.split('\\n').map(line => {\n      let i = line.length - 1;\n      for (; i >= 0 && (line[i] === ' ' || line[i] === '\\t' || line[i] === '\\r'); i--);\n      return line.substr(0, i + 1);\n    }).join('\\n');\n  },\n\n  wrapError: function(error, cause) {\n    if (!cause) {\n      if (error instanceof Error) {\n        return error;\n      }\n      return new Error(error);\n    }\n\n    if (error instanceof Error) {\n      // update error message\n      try {\n        error.message += ': ' + cause.message;\n        error.cause = cause;\n      } catch (e) {}\n      return error;\n    }\n    return new Error(error + ': ' + cause.message, { cause });\n  },\n\n  /**\n   * Map allowed packet tags to corresponding classes\n   * Meant to be used to format `allowedPacket` for Packetlist.read\n   * @param {Array<Object>} allowedClasses\n   * @returns {Object} map from enum.packet to corresponding *Packet class\n   */\n  constructAllowedPackets: function(allowedClasses) {\n    const map = {};\n    allowedClasses.forEach(PacketClass => {\n      if (!PacketClass.tag) {\n        throw new Error('Invalid input: expected a packet class');\n      }\n      map[PacketClass.tag] = PacketClass;\n    });\n    return map;\n  },\n\n  /**\n   * Return a Promise that will resolve as soon as one of the promises in input resolves\n   * or will reject if all input promises all rejected\n   * (similar to Promise.any, but with slightly different error handling)\n   * @param {Array<Promise>} promises\n   * @return {Promise<Any>} Promise resolving to the result of the fastest fulfilled promise\n   *                          or rejected with the Error of the last resolved Promise (if all promises are rejected)\n   */\n  anyPromise: function(promises) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      let exception;\n      await Promise.all(promises.map(async promise => {\n        try {\n          resolve(await promise);\n        } catch (e) {\n          exception = e;\n        }\n      }));\n      reject(exception);\n    });\n  },\n\n  /**\n   * Return either `a` or `b` based on `cond`, in algorithmic constant time.\n   * @param {Boolean} cond\n   * @param {Uint8Array} a\n   * @param {Uint8Array} b\n   * @returns `a` if `cond` is true, `b` otherwise\n   */\n  selectUint8Array: function(cond, a, b) {\n    const length = Math.max(a.length, b.length);\n    const result = new Uint8Array(length);\n    let end = 0;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = (a[i] & (256 - cond)) | (b[i] & (255 + cond));\n      end += (cond & i < a.length) | ((1 - cond) & i < b.length);\n    }\n    return result.subarray(0, end);\n  },\n  /**\n   * Return either `a` or `b` based on `cond`, in algorithmic constant time.\n   * NB: it only supports `a, b` with values between 0-255.\n   * @param {Boolean} cond\n   * @param {Uint8} a\n   * @param {Uint8} b\n   * @returns `a` if `cond` is true, `b` otherwise\n   */\n  selectUint8: function(cond, a, b) {\n    return (a & (256 - cond)) | (b & (255 + cond));\n  },\n  /**\n   * @param {module:enums.symmetric} cipherAlgo\n   */\n  isAES: function(cipherAlgo) {\n    return cipherAlgo === enums.symmetric.aes128 || cipherAlgo === enums.symmetric.aes192 || cipherAlgo === enums.symmetric.aes256;\n  }\n};\n\nexport default util;\n","/* OpenPGP radix-64/base64 string encoding/decoding\n * Copyright 2005 Herbert Hanewinkel, www.haneWIN.de\n * version 1.0, check www.haneWIN.de for the latest version\n *\n * This software is provided as-is, without express or implied warranty.\n * Permission to use, copy, modify, distribute or sell this software, with or\n * without fee, for any purpose and by any individual or organization, is hereby\n * granted, provided that the above copyright notice and this paragraph appear\n * in all copies. Distribution as a part of an application or binary must\n * include the above copyright notice in the documentation and/or other materials\n * provided with the application or distribution.\n */\n\n/**\n * @module encoding/base64\n */\n\nimport { transform as streamTransform } from '@openpgp/web-stream-tools';\nimport util from '../util';\n\nconst Buffer = util.getNodeBuffer();\n\nlet encodeChunk;\nlet decodeChunk;\nif (Buffer) {\n  encodeChunk = buf => Buffer.from(buf).toString('base64');\n  decodeChunk = str => {\n    const b = Buffer.from(str, 'base64');\n    return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n  };\n} else {\n  encodeChunk = buf => btoa(util.uint8ArrayToString(buf));\n  decodeChunk = str => util.stringToUint8Array(atob(str));\n}\n\n/**\n * Convert binary array to radix-64\n * @param {Uint8Array | ReadableStream<Uint8Array>} data - Uint8Array to convert\n * @returns {String | ReadableStream<String>} Radix-64 version of input string.\n * @static\n */\nexport function encode(data) {\n  let buf = new Uint8Array();\n  return streamTransform(data, value => {\n    buf = util.concatUint8Array([buf, value]);\n    const r = [];\n    const bytesPerLine = 45; // 60 chars per line * (3 bytes / 4 chars of base64).\n    const lines = Math.floor(buf.length / bytesPerLine);\n    const bytes = lines * bytesPerLine;\n    const encoded = encodeChunk(buf.subarray(0, bytes));\n    for (let i = 0; i < lines; i++) {\n      r.push(encoded.substr(i * 60, 60));\n      r.push('\\n');\n    }\n    buf = buf.subarray(bytes);\n    return r.join('');\n  }, () => (buf.length ? encodeChunk(buf) + '\\n' : ''));\n}\n\n/**\n * Convert radix-64 to binary array\n * @param {String | ReadableStream<String>} data - Radix-64 string to convert\n * @returns {Uint8Array | ReadableStream<Uint8Array>} Binary array version of input string.\n * @static\n */\nexport function decode(data) {\n  let buf = '';\n  return streamTransform(data, value => {\n    buf += value;\n\n    // Count how many whitespace characters there are in buf\n    let spaces = 0;\n    const spacechars = [' ', '\\t', '\\r', '\\n'];\n    for (let i = 0; i < spacechars.length; i++) {\n      const spacechar = spacechars[i];\n      for (let pos = buf.indexOf(spacechar); pos !== -1; pos = buf.indexOf(spacechar, pos + 1)) {\n        spaces++;\n      }\n    }\n\n    // Backtrack until we have 4n non-whitespace characters\n    // that we can safely base64-decode\n    let length = buf.length;\n    for (; length > 0 && (length - spaces) % 4 !== 0; length--) {\n      if (spacechars.includes(buf[length])) spaces--;\n    }\n\n    const decoded = decodeChunk(buf.substr(0, length));\n    buf = buf.substr(length);\n    return decoded;\n  }, () => decodeChunk(buf));\n}\n\n/**\n * Convert a Base-64 encoded string an array of 8-bit integer\n *\n * Note: accepts both Radix-64 and URL-safe strings\n * @param {String} base64 - Base-64 encoded string to convert\n * @returns {Uint8Array} An array of 8-bit integers.\n */\nexport function b64ToUint8Array(base64) {\n  return decode(base64.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\n/**\n * Convert an array of 8-bit integer to a Base-64 encoded string\n * @param {Uint8Array} bytes - An array of 8-bit integers to convert\n * @param {bool} url - If true, output is URL-safe\n * @returns {String} Base-64 encoded string.\n */\nexport function uint8ArrayToB64(bytes, url) {\n  let encoded = encode(bytes).replace(/[\\r\\n]/g, '');\n  if (url) {\n    encoded = encoded.replace(/[+]/g, '-').replace(/[/]/g, '_').replace(/[=]/g, '');\n  }\n  return encoded;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { transform as streamTransform, transformPair as streamTransformPair, getReader as streamGetReader, getWriter as streamGetWriter, isArrayStream, readToEnd as streamReadToEnd, passiveClone as streamPassiveClone } from '@openpgp/web-stream-tools';\nimport { encode as encodeBase64, decode as decodeBase64 } from './base64';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\n/**\n * Finds out which Ascii Armoring type is used. Throws error if unknown type.\n * @param {String} text - ascii armored text\n * @returns {Integer} 0 = MESSAGE PART n of m.\n *         1 = MESSAGE PART n\n *         2 = SIGNED MESSAGE\n *         3 = PGP MESSAGE\n *         4 = PUBLIC KEY BLOCK\n *         5 = PRIVATE KEY BLOCK\n *         6 = SIGNATURE\n * @private\n */\nfunction getType(text) {\n  const reHeader = /^-----BEGIN PGP (MESSAGE, PART \\d+\\/\\d+|MESSAGE, PART \\d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m;\n\n  const header = text.match(reHeader);\n\n  if (!header) {\n    throw new Error('Unknown ASCII armor type');\n  }\n\n  // BEGIN PGP MESSAGE, PART X/Y\n  // Used for multi-part messages, where the armor is split amongst Y\n  // parts, and this is the Xth part out of Y.\n  if (/MESSAGE, PART \\d+\\/\\d+/.test(header[1])) {\n    return enums.armor.multipartSection;\n  }\n  // BEGIN PGP MESSAGE, PART X\n  // Used for multi-part messages, where this is the Xth part of an\n  // unspecified number of parts. Requires the MESSAGE-ID Armor\n  // Header to be used.\n  if (/MESSAGE, PART \\d+/.test(header[1])) {\n    return enums.armor.multipartLast;\n  }\n  // BEGIN PGP SIGNED MESSAGE\n  if (/SIGNED MESSAGE/.test(header[1])) {\n    return enums.armor.signed;\n  }\n  // BEGIN PGP MESSAGE\n  // Used for signed, encrypted, or compressed files.\n  if (/MESSAGE/.test(header[1])) {\n    return enums.armor.message;\n  }\n  // BEGIN PGP PUBLIC KEY BLOCK\n  // Used for armoring public keys.\n  if (/PUBLIC KEY BLOCK/.test(header[1])) {\n    return enums.armor.publicKey;\n  }\n  // BEGIN PGP PRIVATE KEY BLOCK\n  // Used for armoring private keys.\n  if (/PRIVATE KEY BLOCK/.test(header[1])) {\n    return enums.armor.privateKey;\n  }\n  // BEGIN PGP SIGNATURE\n  // Used for detached signatures, OpenPGP/MIME signatures, and\n  // cleartext signatures. Note that PGP 2.x uses BEGIN PGP MESSAGE\n  // for detached signatures.\n  if (/SIGNATURE/.test(header[1])) {\n    return enums.armor.signature;\n  }\n}\n\n/**\n * Add additional information to the armor version of an OpenPGP binary\n * packet block.\n * @author  Alex\n * @version 2011-12-16\n * @param {String} [customComment] - Additional comment to add to the armored string\n * @returns {String} The header information.\n * @private\n */\nfunction addheader(customComment, config) {\n  let result = '';\n  if (config.showVersion) {\n    result += 'Version: ' + config.versionString + '\\n';\n  }\n  if (config.showComment) {\n    result += 'Comment: ' + config.commentString + '\\n';\n  }\n  if (customComment) {\n    result += 'Comment: ' + customComment + '\\n';\n  }\n  result += '\\n';\n  return result;\n}\n\n/**\n * Calculates a checksum over the given data and returns it base64 encoded\n * @param {String | ReadableStream<String>} data - Data to create a CRC-24 checksum for\n * @returns {String | ReadableStream<String>} Base64 encoded checksum.\n * @private\n */\nfunction getCheckSum(data) {\n  const crc = createcrc24(data);\n  return encodeBase64(crc);\n}\n\n// https://create.stephan-brumme.com/crc32/#slicing-by-8-overview\n\nconst crc_table = [\n  new Array(0xFF),\n  new Array(0xFF),\n  new Array(0xFF),\n  new Array(0xFF)\n];\n\nfor (let i = 0; i <= 0xFF; i++) {\n  let crc = i << 16;\n  for (let j = 0; j < 8; j++) {\n    crc = (crc << 1) ^ ((crc & 0x800000) !== 0 ? 0x864CFB : 0);\n  }\n  crc_table[0][i] =\n    ((crc & 0xFF0000) >> 16) |\n    (crc & 0x00FF00) |\n    ((crc & 0x0000FF) << 16);\n}\nfor (let i = 0; i <= 0xFF; i++) {\n  crc_table[1][i] = (crc_table[0][i] >> 8) ^ crc_table[0][crc_table[0][i] & 0xFF];\n}\nfor (let i = 0; i <= 0xFF; i++) {\n  crc_table[2][i] = (crc_table[1][i] >> 8) ^ crc_table[0][crc_table[1][i] & 0xFF];\n}\nfor (let i = 0; i <= 0xFF; i++) {\n  crc_table[3][i] = (crc_table[2][i] >> 8) ^ crc_table[0][crc_table[2][i] & 0xFF];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView#Endianness\nconst isLittleEndian = (function() {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 0xFF, true /* littleEndian */);\n  // Int16Array uses the platform's endianness.\n  return new Int16Array(buffer)[0] === 0xFF;\n}());\n\n/**\n * Internal function to calculate a CRC-24 checksum over a given string (data)\n * @param {String | ReadableStream<String>} input - Data to create a CRC-24 checksum for\n * @returns {Uint8Array | ReadableStream<Uint8Array>} The CRC-24 checksum.\n * @private\n */\nfunction createcrc24(input) {\n  let crc = 0xCE04B7;\n  return streamTransform(input, value => {\n    const len32 = isLittleEndian ? Math.floor(value.length / 4) : 0;\n    const arr32 = new Uint32Array(value.buffer, value.byteOffset, len32);\n    for (let i = 0; i < len32; i++) {\n      crc ^= arr32[i];\n      crc =\n        crc_table[0][(crc >> 24) & 0xFF] ^\n        crc_table[1][(crc >> 16) & 0xFF] ^\n        crc_table[2][(crc >> 8) & 0xFF] ^\n        crc_table[3][(crc >> 0) & 0xFF];\n    }\n    for (let i = len32 * 4; i < value.length; i++) {\n      crc = (crc >> 8) ^ crc_table[0][(crc & 0xFF) ^ value[i]];\n    }\n  }, () => new Uint8Array([crc, crc >> 8, crc >> 16]));\n}\n\n/**\n * Verify armored headers. crypto-refresh-06, section 6.2:\n * \"An OpenPGP implementation may consider improperly formatted Armor\n * Headers to be corruption of the ASCII Armor, but SHOULD make an\n * effort to recover.\"\n * @private\n * @param {Array<String>} headers - Armor headers\n */\nfunction verifyHeaders(headers) {\n  for (let i = 0; i < headers.length; i++) {\n    if (!/^([^\\s:]|[^\\s:][^:]*[^\\s:]): .+$/.test(headers[i])) {\n      util.printDebugError(new Error('Improperly formatted armor header: ' + headers[i]));\n    }\n    if (!/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(headers[i])) {\n      util.printDebugError(new Error('Unknown header: ' + headers[i]));\n    }\n  }\n}\n\n/**\n * Remove the (optional) checksum from an armored message.\n * @param {String} text - OpenPGP armored message\n * @returns {String} The body of the armored message.\n * @private\n */\nfunction removeChecksum(text) {\n  let body = text;\n\n  const lastEquals = text.lastIndexOf('=');\n\n  if (lastEquals >= 0 && lastEquals !== text.length - 1) { // '=' as the last char means no checksum\n    body = text.slice(0, lastEquals);\n  }\n\n  return body;\n}\n\n/**\n * Dearmor an OpenPGP armored message; verify the checksum and return\n * the encoded bytes\n * @param {String} input - OpenPGP armored message\n * @returns {Promise<Object>} An object with attribute \"text\" containing the message text,\n * an attribute \"data\" containing a stream of bytes and \"type\" for the ASCII armor type\n * @async\n * @static\n */\nexport function unarmor(input) {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise(async (resolve, reject) => {\n    try {\n      const reSplit = /^-----[^-]+-----$/m;\n      const reEmptyLine = /^[ \\f\\r\\t\\u00a0\\u2000-\\u200a\\u202f\\u205f\\u3000]*$/;\n\n      let type;\n      const headers = [];\n      let lastHeaders = headers;\n      let headersDone;\n      let text = [];\n      let textDone;\n      const data = decodeBase64(streamTransformPair(input, async (readable, writable) => {\n        const reader = streamGetReader(readable);\n        try {\n          while (true) {\n            let line = await reader.readLine();\n            if (line === undefined) {\n              throw new Error('Misformed armored text');\n            }\n            // remove trailing whitespace at end of lines\n            line = util.removeTrailingSpaces(line.replace(/[\\r\\n]/g, ''));\n            if (!type) {\n              if (reSplit.test(line)) {\n                type = getType(line);\n              }\n            } else if (!headersDone) {\n              if (reSplit.test(line)) {\n                reject(new Error('Mandatory blank line missing between armor headers and armor data'));\n              }\n              if (!reEmptyLine.test(line)) {\n                lastHeaders.push(line);\n              } else {\n                verifyHeaders(lastHeaders);\n                headersDone = true;\n                if (textDone || type !== enums.armor.signed) {\n                  resolve({ text, data, headers, type });\n                  break;\n                }\n              }\n            } else if (!textDone && type === enums.armor.signed) {\n              if (!reSplit.test(line)) {\n                // Reverse dash-escaping for msg\n                text.push(line.replace(/^- /, ''));\n              } else {\n                text = text.join('\\r\\n');\n                textDone = true;\n                verifyHeaders(lastHeaders);\n                lastHeaders = [];\n                headersDone = false;\n              }\n            }\n          }\n        } catch (e) {\n          reject(e);\n          return;\n        }\n        const writer = streamGetWriter(writable);\n        try {\n          while (true) {\n            await writer.ready;\n            const { done, value } = await reader.read();\n            if (done) {\n              throw new Error('Misformed armored text');\n            }\n            const line = value + '';\n            if (line.indexOf('=') === -1 && line.indexOf('-') === -1) {\n              await writer.write(line);\n            } else {\n              let remainder = await reader.readToEnd();\n              if (!remainder.length) remainder = '';\n              remainder = line + remainder;\n              remainder = util.removeTrailingSpaces(remainder.replace(/\\r/g, ''));\n              const parts = remainder.split(reSplit);\n              if (parts.length === 1) {\n                throw new Error('Misformed armored text');\n              }\n              const body = removeChecksum(parts[0].slice(0, -1));\n              await writer.write(body);\n              break;\n            }\n          }\n          await writer.ready;\n          await writer.close();\n        } catch (e) {\n          await writer.abort(e);\n        }\n      }));\n    } catch (e) {\n      reject(e);\n    }\n  }).then(async result => {\n    if (isArrayStream(result.data)) {\n      result.data = await streamReadToEnd(result.data);\n    }\n    return result;\n  });\n}\n\n\n/**\n * Armor an OpenPGP binary packet block\n * @param {module:enums.armor} messageType - Type of the message\n * @param {Uint8Array | ReadableStream<Uint8Array>} body - The message body to armor\n * @param {Integer} [partIndex]\n * @param {Integer} [partTotal]\n * @param {String} [customComment] - Additional comment to add to the armored string\n * @param {Boolean} [emitChecksum] - Whether to compute and include the CRC checksum\n *  (NB: some types of data must not include it, but compliance is left as responsibility of the caller: this function does not carry out any checks)\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {String | ReadableStream<String>} Armored text.\n * @static\n */\nexport function armor(messageType, body, partIndex, partTotal, customComment, emitChecksum = false, config = defaultConfig) {\n  let text;\n  let hash;\n  if (messageType === enums.armor.signed) {\n    text = body.text;\n    hash = body.hash;\n    body = body.data;\n  }\n  // unless explicitly forbidden by the spec, we need to include the checksum to work around a GnuPG bug\n  // where data fails to be decoded if the base64 ends with no padding chars (=) (see https://dev.gnupg.org/T7071)\n  const maybeBodyClone = emitChecksum && streamPassiveClone(body);\n\n  const result = [];\n  switch (messageType) {\n    case enums.armor.multipartSection:\n      result.push('-----BEGIN PGP MESSAGE, PART ' + partIndex + '/' + partTotal + '-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP MESSAGE, PART ' + partIndex + '/' + partTotal + '-----\\n');\n      break;\n    case enums.armor.multipartLast:\n      result.push('-----BEGIN PGP MESSAGE, PART ' + partIndex + '-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP MESSAGE, PART ' + partIndex + '-----\\n');\n      break;\n    case enums.armor.signed:\n      result.push('-----BEGIN PGP SIGNED MESSAGE-----\\n');\n      result.push(hash ? `Hash: ${hash}\\n\\n` : '\\n');\n      result.push(text.replace(/^-/mg, '- -'));\n      result.push('\\n-----BEGIN PGP SIGNATURE-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP SIGNATURE-----\\n');\n      break;\n    case enums.armor.message:\n      result.push('-----BEGIN PGP MESSAGE-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP MESSAGE-----\\n');\n      break;\n    case enums.armor.publicKey:\n      result.push('-----BEGIN PGP PUBLIC KEY BLOCK-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP PUBLIC KEY BLOCK-----\\n');\n      break;\n    case enums.armor.privateKey:\n      result.push('-----BEGIN PGP PRIVATE KEY BLOCK-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP PRIVATE KEY BLOCK-----\\n');\n      break;\n    case enums.armor.signature:\n      result.push('-----BEGIN PGP SIGNATURE-----\\n');\n      result.push(addheader(customComment, config));\n      result.push(encodeBase64(body));\n      maybeBodyClone && result.push('=', getCheckSum(maybeBodyClone));\n      result.push('-----END PGP SIGNATURE-----\\n');\n      break;\n  }\n\n  return util.concat(result);\n}\n","// Operations are not constant time, but we try and limit timing leakage where we can\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport function uint8ArrayToBigInt(bytes: Uint8Array) {\n  const hexAlphabet = '0123456789ABCDEF';\n  let s = '';\n  bytes.forEach(v => {\n    s += hexAlphabet[v >> 4] + hexAlphabet[v & 15];\n  });\n  return BigInt('0x0' + s);\n}\n\nexport function mod(a: bigint, m: bigint) {\n  const reduced = a % m;\n  return reduced < _0n ? reduced + m : reduced;\n}\n\n/**\n * Compute modular exponentiation using square and multiply\n * @param {BigInt} a - Base\n * @param {BigInt} e - Exponent\n * @param {BigInt} n - Modulo\n * @returns {BigInt} b ** e mod n.\n */\nexport function modExp(b: bigint, e: bigint, n: bigint) {\n  if (n === _0n) throw Error('Modulo cannot be zero');\n  if (n === _1n) return BigInt(0);\n  if (e < _0n) throw Error('Unsopported negative exponent');\n\n  let exp = e;\n  let x = b;\n\n  x %= n;\n  let r = BigInt(1);\n  while (exp > _0n) {\n    const lsb = exp & _1n;\n    exp >>= _1n; // e / 2\n    // Always compute multiplication step, to reduce timing leakage\n    const rx = (r * x) % n;\n    // Update r only if lsb is 1 (odd exponent)\n    r = lsb ? rx : r;\n    x = (x * x) % n; // Square\n  }\n  return r;\n}\n\n\nfunction abs(x: bigint) {\n  return x >= _0n ? x : -x;\n}\n\n/**\n * Extended Eucleadian algorithm (http://anh.cs.luc.edu/331/notes/xgcd.pdf)\n * Given a and b, compute (x, y) such that ax + by = gdc(a, b).\n * Negative numbers are also supported.\n * @param {BigInt} a - First operand\n * @param {BigInt} b - Second operand\n * @returns {{ gcd, x, y: bigint }}\n */\nfunction _egcd(aInput: bigint, bInput: bigint) {\n  let x = BigInt(0);\n  let y = BigInt(1);\n  let xPrev = BigInt(1);\n  let yPrev = BigInt(0);\n\n  // Deal with negative numbers: run algo over absolute values,\n  // and \"move\" the sign to the returned x and/or y.\n  // See https://math.stackexchange.com/questions/37806/extended-euclidean-algorithm-with-negative-numbers\n  let a = abs(aInput);\n  let b = abs(bInput);\n  const aNegated = aInput < _0n;\n  const bNegated = bInput < _0n;\n\n  while (b !== _0n) {\n    const q = a / b;\n    let tmp = x;\n    x = xPrev - q * x;\n    xPrev = tmp;\n\n    tmp = y;\n    y = yPrev - q * y;\n    yPrev = tmp;\n\n    tmp = b;\n    b = a % b;\n    a = tmp;\n  }\n\n  return {\n    x: aNegated ? -xPrev : xPrev,\n    y: bNegated ? -yPrev : yPrev,\n    gcd: a\n  };\n}\n\n/**\n * Compute the inverse of `a` modulo `n`\n * Note: `a` and and `n` must be relatively prime\n * @param {BigInt} a\n * @param {BigInt} n - Modulo\n * @returns {BigInt} x such that a*x = 1 mod n\n * @throws {Error} if the inverse does not exist\n */\nexport function modInv(a: bigint, n: bigint) {\n  const { gcd, x } = _egcd(a, n);\n  if (gcd !== _1n) {\n    throw new Error('Inverse does not exist');\n  }\n  return mod(x + n, n);\n}\n\n/**\n * Compute greatest common divisor between this and n\n * @param {BigInt} aInput - Operand\n * @param {BigInt} bInput - Operand\n * @returns {BigInt} gcd\n */\nexport function gcd(aInput: bigint, bInput: bigint) {\n  let a = aInput;\n  let b = bInput;\n  while (b !== _0n) {\n    const tmp = b;\n    b = a % b;\n    a = tmp;\n  }\n  return a;\n}\n\n/**\n * Get this value as an exact Number (max 53 bits)\n * Fails if this value is too large\n * @returns {Number}\n */\nexport function bigIntToNumber(x: bigint) {\n  const number = Number(x);\n  if (number > Number.MAX_SAFE_INTEGER) {\n    // We throw and error to conform with the bn.js implementation\n    throw new Error('Number can only safely store up to 53 bits');\n  }\n  return number;\n}\n\n/**\n * Get value of i-th bit\n * @param {BigInt} x\n * @param {Number} i - Bit index\n * @returns {Number} Bit value.\n */\nexport function getBit(x:bigint, i: number) {\n  const bit = (x >> BigInt(i)) & _1n;\n  return bit === _0n ? 0 : 1;\n}\n\n/**\n * Compute bit length\n */\nexport function bitLength(x: bigint) {\n  // -1n >> -1n is -1n\n  // 1n >> 1n is 0n\n  const target = x < _0n ? BigInt(-1) : _0n;\n  let bitlen = 1;\n  let tmp = x;\n  // eslint-disable-next-line no-cond-assign\n  while ((tmp >>= _1n) !== target) {\n    bitlen++;\n  }\n  return bitlen;\n}\n\n/**\n * Compute byte length\n */\nexport function byteLength(x: bigint) {\n  const target = x < _0n ? BigInt(-1) : _0n;\n  const _8n = BigInt(8);\n  let len = 1;\n  let tmp = x;\n  // eslint-disable-next-line no-cond-assign\n  while ((tmp >>= _8n) !== target) {\n    len++;\n  }\n  return len;\n}\n\n/**\n * Get Uint8Array representation of this number\n * @param {String} endian - Endianess of output array (defaults to 'be')\n * @param {Number} length - Of output array\n * @returns {Uint8Array}\n */\nexport function bigIntToUint8Array(x: bigint, endian = 'be', length: number) {\n  // we get and parse the hex string (https://coolaj86.com/articles/convert-js-bigints-to-typedarrays/)\n  // this is faster than shift+mod iterations\n  let hex = x.toString(16);\n  if (hex.length % 2 === 1) {\n    hex = '0' + hex;\n  }\n\n  const rawLength = hex.length / 2;\n  const bytes = new Uint8Array(length || rawLength);\n  // parse hex\n  const offset = length ? length - rawLength : 0;\n  let i = 0;\n  while (i < rawLength) {\n    bytes[i + offset] = parseInt(hex.slice(2 * i, 2 * i + 2), 16);\n    i++;\n  }\n\n  if (endian !== 'be') {\n    bytes.reverse();\n  }\n\n  return bytes;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n// The GPG4Browsers crypto interface\n\n/**\n * @fileoverview Provides tools for retrieving secure randomness from browsers or Node.js\n * @module crypto/random\n */\nimport { byteLength, mod, uint8ArrayToBigInt } from './biginteger';\nimport util from '../util';\n\nconst nodeCrypto = util.getNodeCrypto();\n\n/**\n * Retrieve secure random byte array of the specified length\n * @param {Integer} length - Length in bytes to generate\n * @returns {Uint8Array} Random byte array.\n */\nexport function getRandomBytes(length) {\n  const webcrypto = typeof crypto !== 'undefined' ? crypto : nodeCrypto?.webcrypto;\n  if (webcrypto?.getRandomValues) {\n    const buf = new Uint8Array(length);\n    return webcrypto.getRandomValues(buf);\n  } else {\n    throw new Error('No secure random number generator available.');\n  }\n}\n\n/**\n * Create a secure random BigInt that is greater than or equal to min and less than max.\n * @param {bigint} min - Lower bound, included\n * @param {bigint} max - Upper bound, excluded\n * @returns {bigint} Random BigInt.\n * @async\n */\nexport function getRandomBigInteger(min, max) {\n  if (max < min) {\n    throw new Error('Illegal parameter value: max <= min');\n  }\n\n  const modulus = max - min;\n  const bytes = byteLength(modulus);\n\n  // Using a while loop is necessary to avoid bias introduced by the mod operation.\n  // However, we request 64 extra random bits so that the bias is negligible.\n  // Section B.1.1 here: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n  const r = uint8ArrayToBigInt(getRandomBytes(bytes + 8));\n  return mod(r, modulus) + min;\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2018 Proton Technologies AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Algorithms for probabilistic random prime generation\n * @module crypto/public_key/prime\n */\nimport { bigIntToNumber, bitLength, gcd, getBit, mod, modExp } from '../biginteger';\nimport { getRandomBigInteger } from '../random';\n\nconst _1n = BigInt(1);\n\n/**\n * Generate a probably prime random number\n * @param bits - Bit length of the prime\n * @param e - Optional RSA exponent to check against the prime\n * @param k - Optional number of iterations of Miller-Rabin test\n */\nexport function randomProbablePrime(bits: number, e: bigint, k: number) {\n  const _30n = BigInt(30);\n  const min = _1n << BigInt(bits - 1);\n  /*\n   * We can avoid any multiples of 3 and 5 by looking at n mod 30\n   * n mod 30 = 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n   * the next possible prime is mod 30:\n   *            1  7  7  7  7  7  7 11 11 11 11 13 13 17 17 17 17 19 19 23 23 23 23 29 29 29 29 29 29 1\n   */\n  const adds = [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2];\n\n  let n = getRandomBigInteger(min, min << _1n);\n  let i = bigIntToNumber(mod(n, _30n));\n\n  do {\n    n += BigInt(adds[i]);\n    i = (i + adds[i]) % adds.length;\n    // If reached the maximum, go back to the minimum.\n    if (bitLength(n) > bits) {\n      n = mod(n, min << _1n); n += min;\n      i = bigIntToNumber(mod(n, _30n));\n    }\n  } while (!isProbablePrime(n, e, k));\n  return n;\n}\n\n/**\n * Probabilistic primality testing\n * @param n - Number to test\n * @param e - Optional RSA exponent to check against the prime\n * @param k - Optional number of iterations of Miller-Rabin test\n */\nexport function isProbablePrime(n: bigint, e: bigint, k: number) {\n  if (e && gcd(n - _1n, e) !== _1n) {\n    return false;\n  }\n  if (!divisionTest(n)) {\n    return false;\n  }\n  if (!fermat(n)) {\n    return false;\n  }\n  if (!millerRabin(n, k)) {\n    return false;\n  }\n  // TODO implement the Lucas test\n  // See Section C.3.3 here: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n  return true;\n}\n\n/**\n * Tests whether n is probably prime or not using Fermat's test with b = 2.\n * Fails if b^(n-1) mod n != 1.\n * @param n - Number to test\n * @param b - Optional Fermat test base\n */\nexport function fermat(n: bigint, b = BigInt(2)) {\n  return modExp(b, n - _1n, n) === _1n;\n}\n\nexport function divisionTest(n: bigint) {\n  const _0n = BigInt(0);\n  return smallPrimes.every(m => mod(n, m) !== _0n);\n}\n\n// https://github.com/gpg/libgcrypt/blob/master/cipher/primegen.c\nconst smallPrimes = [\n  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n  47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\n  103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n  157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\n  211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\n  269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n  331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\n  389, 397, 401, 409, 419, 421, 431, 433, 439, 443,\n  449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n  509, 521, 523, 541, 547, 557, 563, 569, 571, 577,\n  587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\n  643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n  709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\n  773, 787, 797, 809, 811, 821, 823, 827, 829, 839,\n  853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n  919, 929, 937, 941, 947, 953, 967, 971, 977, 983,\n  991, 997, 1009, 1013, 1019, 1021, 1031, 1033,\n  1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091,\n  1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151,\n  1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213,\n  1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277,\n  1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307,\n  1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399,\n  1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451,\n  1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493,\n  1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559,\n  1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609,\n  1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667,\n  1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733,\n  1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789,\n  1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871,\n  1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931,\n  1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997,\n  1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053,\n  2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111,\n  2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161,\n  2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243,\n  2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297,\n  2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357,\n  2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411,\n  2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473,\n  2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551,\n  2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633,\n  2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687,\n  2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729,\n  2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791,\n  2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851,\n  2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917,\n  2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999,\n  3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061,\n  3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137,\n  3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209,\n  3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271,\n  3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331,\n  3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391,\n  3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467,\n  3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533,\n  3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583,\n  3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643,\n  3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709,\n  3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779,\n  3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851,\n  3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917,\n  3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989,\n  4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049,\n  4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111,\n  4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177,\n  4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243,\n  4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297,\n  4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391,\n  4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457,\n  4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519,\n  4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597,\n  4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657,\n  4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729,\n  4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799,\n  4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889,\n  4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951,\n  4957, 4967, 4969, 4973, 4987, 4993, 4999\n].map(n => BigInt(n));\n\n\n// Miller-Rabin - Miller Rabin algorithm for primality test\n// Copyright Fedor Indutny, 2014.\n//\n// This software is licensed under the MIT License.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Adapted on Jan 2018 from version 4.0.1 at https://github.com/indutny/miller-rabin\n\n// Sample syntax for Fixed-Base Miller-Rabin:\n// millerRabin(n, k, () => new BN(small_primes[Math.random() * small_primes.length | 0]))\n\n/**\n * Tests whether n is probably prime or not using the Miller-Rabin test.\n * See HAC Remark 4.28.\n * @param n - Number to test\n * @param k - Optional number of iterations of Miller-Rabin test\n * @param rand - Optional function to generate potential witnesses\n * @returns {boolean}\n * @async\n */\nexport function millerRabin(n: bigint, k: number, rand?: () => bigint) {\n  const len = bitLength(n);\n\n  if (!k) {\n    k = Math.max(1, (len / 48) | 0);\n  }\n\n  const n1 = n - _1n; // n - 1\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  let s = 0;\n  while (!getBit(n1, s)) { s++; }\n  const d = n >> BigInt(s);\n\n  for (; k > 0; k--) {\n    const a = rand ? rand() : getRandomBigInteger(BigInt(2), n1);\n\n    let x = modExp(a, d, n);\n    if (x === _1n || x === n1) {\n      continue;\n    }\n\n    let i;\n    for (i = 1; i < s; i++) {\n      x = mod(x * x, n);\n\n      if (x === _1n) {\n        return false;\n      }\n      if (x === n1) {\n        break;\n      }\n    }\n\n    if (i === s) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * @fileoverview Provides an interface to hashing functions available in Node.js or external libraries.\n * @see {@link https://github.com/asmcrypto/asmcrypto.js|asmCrypto}\n * @see {@link https://github.com/indutny/hash.js|hash.js}\n * @module crypto/hash\n */\n\nimport { transform as streamTransform, isArrayStream, readToEnd as streamReadToEnd } from '@openpgp/web-stream-tools';\nimport util from '../../util';\nimport enums from '../../enums';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\nconst nodeCryptoHashes = nodeCrypto && nodeCrypto.getHashes();\n\nfunction nodeHash(type) {\n  if (!nodeCrypto || !nodeCryptoHashes.includes(type)) {\n    return;\n  }\n  return async function (data) {\n    const shasum = nodeCrypto.createHash(type);\n    return streamTransform(data, value => {\n      shasum.update(value);\n    }, () => new Uint8Array(shasum.digest()));\n  };\n}\n\nfunction nobleHash(nobleHashName, webCryptoHashName) {\n  const getNobleHash = async () => {\n    const { nobleHashes } = await import('./noble_hashes');\n    const hash = nobleHashes.get(nobleHashName);\n    if (!hash) throw new Error('Unsupported hash');\n    return hash;\n  };\n\n  return async function(data) {\n    if (isArrayStream(data)) {\n      data = await streamReadToEnd(data);\n    }\n    if (util.isStream(data)) {\n      const hash = await getNobleHash();\n\n      const hashInstance = hash.create();\n      return streamTransform(data, value => {\n        hashInstance.update(value);\n      }, () => hashInstance.digest());\n    } else if (webCrypto && webCryptoHashName) {\n      return new Uint8Array(await webCrypto.digest(webCryptoHashName, data));\n    } else {\n      const hash = await getNobleHash();\n\n      return hash(data);\n    }\n  };\n}\n\nconst md5 = nodeHash('md5') || nobleHash('md5');\nconst sha1 = nodeHash('sha1') || nobleHash('sha1', 'SHA-1');\nconst sha224 = nodeHash('sha224') || nobleHash('sha224');\nconst sha256 = nodeHash('sha256') || nobleHash('sha256', 'SHA-256');\nconst sha384 = nodeHash('sha384') || nobleHash('sha384', 'SHA-384');\nconst sha512 = nodeHash('sha512') || nobleHash('sha512', 'SHA-512');\nconst ripemd = nodeHash('ripemd160') || nobleHash('ripemd160');\nconst sha3_256 = nodeHash('sha3-256') || nobleHash('sha3_256');\nconst sha3_512 = nodeHash('sha3-512') || nobleHash('sha3_512');\n\n/**\n * Create a hash on the specified data using the specified algorithm\n * @param {module:enums.hash} algo - Hash algorithm type (see {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC 4880 9.4})\n * @param {Uint8Array} data - Data to be hashed\n * @returns {Promise<Uint8Array>} Hash value.\n */\nexport function computeDigest(algo, data) {\n  switch (algo) {\n    case enums.hash.md5:\n      return md5(data);\n    case enums.hash.sha1:\n      return sha1(data);\n    case enums.hash.ripemd:\n      return ripemd(data);\n    case enums.hash.sha256:\n      return sha256(data);\n    case enums.hash.sha384:\n      return sha384(data);\n    case enums.hash.sha512:\n      return sha512(data);\n    case enums.hash.sha224:\n      return sha224(data);\n    case enums.hash.sha3_256:\n      return sha3_256(data);\n    case enums.hash.sha3_512:\n      return sha3_512(data);\n    default:\n      throw new Error('Unsupported hash function');\n  }\n}\n\n/**\n * Returns the hash size in bytes of the specified hash algorithm type\n * @param {module:enums.hash} algo - Hash algorithm type (See {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC 4880 9.4})\n * @returns {Integer} Size in bytes of the resulting hash.\n */\nexport function getHashByteLength(algo) {\n  switch (algo) {\n    case enums.hash.md5:\n      return 16;\n    case enums.hash.sha1:\n    case enums.hash.ripemd:\n      return 20;\n    case enums.hash.sha256:\n      return 32;\n    case enums.hash.sha384:\n      return 48;\n    case enums.hash.sha512:\n      return 64;\n    case enums.hash.sha224:\n      return 28;\n    case enums.hash.sha3_256:\n      return 32;\n    case enums.hash.sha3_512:\n      return 64;\n    default:\n      throw new Error('Invalid hash algorithm.');\n  }\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Provides EME-PKCS1-v1_5 encoding and decoding and EMSA-PKCS1-v1_5 encoding function\n * @see module:crypto/public_key/rsa\n * @see module:crypto/public_key/elliptic/ecdh\n * @see PublicKeyEncryptedSessionKeyPacket\n * @module crypto/pkcs1\n */\n\nimport { getRandomBytes } from './random';\nimport { getHashByteLength } from './hash';\nimport util from '../util';\n\n/**\n * ASN1 object identifiers for hashes\n * @see {@link https://tools.ietf.org/html/rfc4880#section-5.2.2}\n */\nconst hash_headers = [];\nhash_headers[1] = [0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04,\n  0x10];\nhash_headers[2] = [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14];\nhash_headers[3] = [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02, 0x01, 0x05, 0x00, 0x04, 0x14];\nhash_headers[8] = [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00,\n  0x04, 0x20];\nhash_headers[9] = [0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00,\n  0x04, 0x30];\nhash_headers[10] = [0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,\n  0x00, 0x04, 0x40];\nhash_headers[11] = [0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,\n  0x00, 0x04, 0x1C];\n\n/**\n * Create padding with secure random data\n * @private\n * @param {Integer} length - Length of the padding in bytes\n * @returns {Uint8Array} Random padding.\n */\nfunction getPKCS1Padding(length) {\n  const result = new Uint8Array(length);\n  let count = 0;\n  while (count < length) {\n    const randomBytes = getRandomBytes(length - count);\n    for (let i = 0; i < randomBytes.length; i++) {\n      if (randomBytes[i] !== 0) {\n        result[count++] = randomBytes[i];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Create a EME-PKCS1-v1_5 padded message\n * @see {@link https://tools.ietf.org/html/rfc4880#section-13.1.1|RFC 4880 13.1.1}\n * @param {Uint8Array} message - Message to be encoded\n * @param {Integer} keyLength - The length in octets of the key modulus\n * @returns {Uint8Array} EME-PKCS1 padded message.\n */\nexport function emeEncode(message, keyLength) {\n  const mLength = message.length;\n  // length checking\n  if (mLength > keyLength - 11) {\n    throw new Error('Message too long');\n  }\n  // Generate an octet string PS of length k - mLen - 3 consisting of\n  // pseudo-randomly generated nonzero octets\n  const PS = getPKCS1Padding(keyLength - mLength - 3);\n  // Concatenate PS, the message M, and other padding to form an\n  // encoded message EM of length k octets as EM = 0x00 || 0x02 || PS || 0x00 || M.\n  const encoded = new Uint8Array(keyLength);\n  // 0x00 byte\n  encoded[1] = 2;\n  encoded.set(PS, 2);\n  // 0x00 bytes\n  encoded.set(message, keyLength - mLength);\n  return encoded;\n}\n\n/**\n * Decode a EME-PKCS1-v1_5 padded message\n * @see {@link https://tools.ietf.org/html/rfc4880#section-13.1.2|RFC 4880 13.1.2}\n * @param {Uint8Array} encoded - Encoded message bytes\n * @param {Uint8Array} randomPayload - Data to return in case of decoding error (needed for constant-time processing)\n * @returns {Uint8Array} decoded data or `randomPayload` (on error, if given)\n * @throws {Error} on decoding failure, unless `randomPayload` is provided\n */\nexport function emeDecode(encoded, randomPayload) {\n  // encoded format: 0x00 0x02 <PS> 0x00 <payload>\n  let offset = 2;\n  let separatorNotFound = 1;\n  for (let j = offset; j < encoded.length; j++) {\n    separatorNotFound &= encoded[j] !== 0;\n    offset += separatorNotFound;\n  }\n\n  const psLen = offset - 2;\n  const payload = encoded.subarray(offset + 1); // discard the 0x00 separator\n  const isValidPadding = encoded[0] === 0 & encoded[1] === 2 & psLen >= 8 & !separatorNotFound;\n\n  if (randomPayload) {\n    return util.selectUint8Array(isValidPadding, payload, randomPayload);\n  }\n\n  if (isValidPadding) {\n    return payload;\n  }\n\n  throw new Error('Decryption error');\n}\n\n/**\n * Create a EMSA-PKCS1-v1_5 padded message\n * @see {@link https://tools.ietf.org/html/rfc4880#section-13.1.3|RFC 4880 13.1.3}\n * @param {Integer} algo - Hash algorithm type used\n * @param {Uint8Array} hashed - Message to be encoded\n * @param {Integer} emLen - Intended length in octets of the encoded message\n * @returns {Uint8Array} Encoded message.\n */\nexport function emsaEncode(algo, hashed, emLen) {\n  let i;\n  if (hashed.length !== getHashByteLength(algo)) {\n    throw new Error('Invalid hash length');\n  }\n  // produce an ASN.1 DER value for the hash function used.\n  // Let T be the full hash prefix\n  const hashPrefix = new Uint8Array(hash_headers[algo].length);\n  for (i = 0; i < hash_headers[algo].length; i++) {\n    hashPrefix[i] = hash_headers[algo][i];\n  }\n  // and let tLen be the length in octets prefix and hashed data\n  const tLen = hashPrefix.length + hashed.length;\n  if (emLen < tLen + 11) {\n    throw new Error('Intended encoded message length too short');\n  }\n  // an octet string PS consisting of emLen - tLen - 3 octets with hexadecimal value 0xFF\n  // The length of PS will be at least 8 octets\n  const PS = new Uint8Array(emLen - tLen - 3).fill(0xff);\n\n  // Concatenate PS, the hash prefix, hashed data, and other padding to form the\n  // encoded message EM as EM = 0x00 || 0x01 || PS || 0x00 || prefix || hashed\n  const EM = new Uint8Array(emLen);\n  EM[1] = 0x01;\n  EM.set(PS, 2);\n  EM.set(hashPrefix, emLen - tLen);\n  EM.set(hashed, emLen - hashed.length);\n  return EM;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview RSA implementation\n * @module crypto/public_key/rsa\n */\nimport { randomProbablePrime } from './prime';\nimport { getRandomBigInteger } from '../random';\nimport util from '../../util';\nimport { uint8ArrayToB64, b64ToUint8Array } from '../../encoding/base64';\nimport { emsaEncode, emeEncode, emeDecode } from '../pkcs1';\nimport enums from '../../enums';\nimport { bigIntToNumber, bigIntToUint8Array, bitLength, byteLength, mod, modExp, modInv, uint8ArrayToBigInt } from '../biginteger';\nimport { getHashByteLength } from '../hash';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\nconst _1n = BigInt(1);\n\n/** Create signature\n * @param {module:enums.hash} hashAlgo - Hash algorithm\n * @param {Uint8Array} data - Message\n * @param {Uint8Array} n - RSA public modulus\n * @param {Uint8Array} e - RSA public exponent\n * @param {Uint8Array} d - RSA private exponent\n * @param {Uint8Array} p - RSA private prime p\n * @param {Uint8Array} q - RSA private prime q\n * @param {Uint8Array} u - RSA private coefficient\n * @param {Uint8Array} hashed - Hashed message\n * @returns {Promise<Uint8Array>} RSA Signature.\n * @async\n */\nexport async function sign(hashAlgo, data, n, e, d, p, q, u, hashed) {\n  if (getHashByteLength(hashAlgo) >= n.length) {\n    // Throw here instead of `emsaEncode` below, to provide a clearer and consistent error\n    // e.g. if a 512-bit RSA key is used with a SHA-512 digest.\n    // The size limit is actually slightly different but here we only care about throwing\n    // on common key sizes.\n    throw new Error('Digest size cannot exceed key modulus size');\n  }\n\n  if (data && !util.isStream(data)) {\n    if (util.getWebCrypto()) {\n      try {\n        return await webSign(enums.read(enums.webHash, hashAlgo), data, n, e, d, p, q, u);\n      } catch (err) {\n        util.printDebugError(err);\n      }\n    } else if (util.getNodeCrypto()) {\n      return nodeSign(hashAlgo, data, n, e, d, p, q, u);\n    }\n  }\n  return bnSign(hashAlgo, n, d, hashed);\n}\n\n/**\n * Verify signature\n * @param {module:enums.hash} hashAlgo - Hash algorithm\n * @param {Uint8Array} data - Message\n * @param {Uint8Array} s - Signature\n * @param {Uint8Array} n - RSA public modulus\n * @param {Uint8Array} e - RSA public exponent\n * @param {Uint8Array} hashed - Hashed message\n * @returns {Boolean}\n * @async\n */\nexport async function verify(hashAlgo, data, s, n, e, hashed) {\n  if (data && !util.isStream(data)) {\n    if (util.getWebCrypto()) {\n      try {\n        return await webVerify(enums.read(enums.webHash, hashAlgo), data, s, n, e);\n      } catch (err) {\n        util.printDebugError(err);\n      }\n    } else if (util.getNodeCrypto()) {\n      return nodeVerify(hashAlgo, data, s, n, e);\n    }\n  }\n  return bnVerify(hashAlgo, s, n, e, hashed);\n}\n\n/**\n * Encrypt message\n * @param {Uint8Array} data - Message\n * @param {Uint8Array} n - RSA public modulus\n * @param {Uint8Array} e - RSA public exponent\n * @returns {Promise<Uint8Array>} RSA Ciphertext.\n * @async\n */\nexport async function encrypt(data, n, e) {\n  if (util.getNodeCrypto()) {\n    return nodeEncrypt(data, n, e);\n  }\n  return bnEncrypt(data, n, e);\n}\n\n/**\n * Decrypt RSA message\n * @param {Uint8Array} m - Message\n * @param {Uint8Array} n - RSA public modulus\n * @param {Uint8Array} e - RSA public exponent\n * @param {Uint8Array} d - RSA private exponent\n * @param {Uint8Array} p - RSA private prime p\n * @param {Uint8Array} q - RSA private prime q\n * @param {Uint8Array} u - RSA private coefficient\n * @param {Uint8Array} randomPayload - Data to return on decryption error, instead of throwing\n *                                     (needed for constant-time processing)\n * @returns {Promise<String>} RSA Plaintext.\n * @throws {Error} on decryption error, unless `randomPayload` is given\n * @async\n */\nexport async function decrypt(data, n, e, d, p, q, u, randomPayload) {\n  // Node v18.19.1, 20.11.1 and 21.6.2 have disabled support for PKCS#1 decryption,\n  // and we want to avoid checking the error type to decide if the random payload\n  // should indeed be returned.\n  if (util.getNodeCrypto() && !randomPayload) {\n    try {\n      return await nodeDecrypt(data, n, e, d, p, q, u);\n    } catch (err) {\n      util.printDebugError(err);\n    }\n  }\n  return bnDecrypt(data, n, e, d, p, q, u, randomPayload);\n}\n\n/**\n * Generate a new random private key B bits long with public exponent E.\n *\n * When possible, webCrypto or nodeCrypto is used. Otherwise, primes are generated using\n * 40 rounds of the Miller-Rabin probabilistic random prime generation algorithm.\n * @see module:crypto/public_key/prime\n * @param {Integer} bits - RSA bit length\n * @param {Integer} e - RSA public exponent\n * @returns {{n, e, d,\n *            p, q ,u: Uint8Array}} RSA public modulus, RSA public exponent, RSA private exponent,\n *                                  RSA private prime p, RSA private prime q, u = p ** -1 mod q\n * @async\n */\nexport async function generate(bits, e) {\n  e = BigInt(e);\n\n  // Native RSA keygen using Web Crypto\n  if (util.getWebCrypto()) {\n    const keyGenOpt = {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits, // the specified keysize in bits\n      publicExponent: bigIntToUint8Array(e), // take three bytes (max 65537) for exponent\n      hash: {\n        name: 'SHA-1' // not required for actual RSA keys, but for crypto api 'sign' and 'verify'\n      }\n    };\n    const keyPair = await webCrypto.generateKey(keyGenOpt, true, ['sign', 'verify']);\n\n    // export the generated keys as JsonWebKey (JWK)\n    // https://tools.ietf.org/html/draft-ietf-jose-json-web-key-33\n    const jwk = await webCrypto.exportKey('jwk', keyPair.privateKey);\n    // map JWK parameters to corresponding OpenPGP names\n    return jwkToPrivate(jwk, e);\n  } else if (util.getNodeCrypto()) {\n    const opts = {\n      modulusLength: bits,\n      publicExponent: bigIntToNumber(e),\n      publicKeyEncoding: { type: 'pkcs1', format: 'jwk' },\n      privateKeyEncoding: { type: 'pkcs1', format: 'jwk' }\n    };\n    const jwk = await new Promise((resolve, reject) => {\n      nodeCrypto.generateKeyPair('rsa', opts, (err, _, jwkPrivateKey) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(jwkPrivateKey);\n        }\n      });\n    });\n    return jwkToPrivate(jwk, e);\n  }\n\n  // RSA keygen fallback using 40 iterations of the Miller-Rabin test\n  // See https://stackoverflow.com/a/6330138 for justification\n  // Also see section C.3 here: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST\n  let p;\n  let q;\n  let n;\n  do {\n    q = randomProbablePrime(bits - (bits >> 1), e, 40);\n    p = randomProbablePrime(bits >> 1, e, 40);\n    n = p * q;\n  } while (bitLength(n) !== bits);\n\n  const phi = (p - _1n) * (q - _1n);\n\n  if (q < p) {\n    [p, q] = [q, p];\n  }\n\n  return {\n    n: bigIntToUint8Array(n),\n    e: bigIntToUint8Array(e),\n    d: bigIntToUint8Array(modInv(e, phi)),\n    p: bigIntToUint8Array(p),\n    q: bigIntToUint8Array(q),\n    // dp: d.mod(p.subn(1)),\n    // dq: d.mod(q.subn(1)),\n    u: bigIntToUint8Array(modInv(p, q))\n  };\n}\n\n/**\n * Validate RSA parameters\n * @param {Uint8Array} n - RSA public modulus\n * @param {Uint8Array} e - RSA public exponent\n * @param {Uint8Array} d - RSA private exponent\n * @param {Uint8Array} p - RSA private prime p\n * @param {Uint8Array} q - RSA private prime q\n * @param {Uint8Array} u - RSA inverse of p w.r.t. q\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(n, e, d, p, q, u) {\n  n = uint8ArrayToBigInt(n);\n  p = uint8ArrayToBigInt(p);\n  q = uint8ArrayToBigInt(q);\n\n  // expect pq = n\n  if ((p * q) !== n) {\n    return false;\n  }\n\n  const _2n = BigInt(2);\n  // expect p*u = 1 mod q\n  u = uint8ArrayToBigInt(u);\n  if (mod(p * u, q) !== BigInt(1)) {\n    return false;\n  }\n\n  e = uint8ArrayToBigInt(e);\n  d = uint8ArrayToBigInt(d);\n  /**\n   * In RSA pkcs#1 the exponents (d, e) are inverses modulo lcm(p-1, q-1)\n   * We check that [de = 1 mod (p-1)] and [de = 1 mod (q-1)]\n   * By CRT on coprime factors of (p-1, q-1) it follows that [de = 1 mod lcm(p-1, q-1)]\n   *\n   * We blind the multiplication with r, and check that rde = r mod lcm(p-1, q-1)\n   */\n  const nSizeOver3 = BigInt(Math.floor(bitLength(n) / 3));\n  const r = getRandomBigInteger(_2n, _2n << nSizeOver3); // r in [ 2, 2^{|n|/3} ) < p and q\n  const rde = r * d * e;\n\n  const areInverses = mod(rde, p - _1n) === r && mod(rde, q - _1n) === r;\n  if (!areInverses) {\n    return false;\n  }\n\n  return true;\n}\n\nasync function bnSign(hashAlgo, n, d, hashed) {\n  n = uint8ArrayToBigInt(n);\n  const m = uint8ArrayToBigInt(emsaEncode(hashAlgo, hashed, byteLength(n)));\n  d = uint8ArrayToBigInt(d);\n  return bigIntToUint8Array(modExp(m, d, n), 'be', byteLength(n));\n}\n\nasync function webSign(hashName, data, n, e, d, p, q, u) {\n  /** OpenPGP keys require that p < q, and Safari Web Crypto requires that p > q.\n   * We swap them in privateToJWK, so it usually works out, but nevertheless,\n   * not all OpenPGP keys are compatible with this requirement.\n   * OpenPGP.js used to generate RSA keys the wrong way around (p > q), and still\n   * does if the underlying Web Crypto does so (though the tested implementations\n   * don't do so).\n   */\n  const jwk = await privateToJWK(n, e, d, p, q, u);\n  const algo = {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: { name: hashName }\n  };\n  const key = await webCrypto.importKey('jwk', jwk, algo, false, ['sign']);\n  return new Uint8Array(await webCrypto.sign('RSASSA-PKCS1-v1_5', key, data));\n}\n\nasync function nodeSign(hashAlgo, data, n, e, d, p, q, u) {\n  const sign = nodeCrypto.createSign(enums.read(enums.hash, hashAlgo));\n  sign.write(data);\n  sign.end();\n\n  const jwk = await privateToJWK(n, e, d, p, q, u);\n  return new Uint8Array(sign.sign({ key: jwk, format: 'jwk', type: 'pkcs1' }));\n}\n\nasync function bnVerify(hashAlgo, s, n, e, hashed) {\n  n = uint8ArrayToBigInt(n);\n  s = uint8ArrayToBigInt(s);\n  e = uint8ArrayToBigInt(e);\n  if (s >= n) {\n    throw new Error('Signature size cannot exceed modulus size');\n  }\n  const EM1 = bigIntToUint8Array(modExp(s, e, n), 'be', byteLength(n));\n  const EM2 = emsaEncode(hashAlgo, hashed, byteLength(n));\n  return util.equalsUint8Array(EM1, EM2);\n}\n\nasync function webVerify(hashName, data, s, n, e) {\n  const jwk = publicToJWK(n, e);\n  const key = await webCrypto.importKey('jwk', jwk, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: { name:  hashName }\n  }, false, ['verify']);\n  return webCrypto.verify('RSASSA-PKCS1-v1_5', key, s, data);\n}\n\nasync function nodeVerify(hashAlgo, data, s, n, e) {\n  const jwk = publicToJWK(n, e);\n  const key = { key: jwk, format: 'jwk', type: 'pkcs1' };\n\n  const verify = nodeCrypto.createVerify(enums.read(enums.hash, hashAlgo));\n  verify.write(data);\n  verify.end();\n\n  try {\n    return verify.verify(key, s);\n  } catch (err) {\n    return false;\n  }\n}\n\nasync function nodeEncrypt(data, n, e) {\n  const jwk = publicToJWK(n, e);\n  const key = { key: jwk, format: 'jwk', type: 'pkcs1', padding: nodeCrypto.constants.RSA_PKCS1_PADDING };\n\n  return new Uint8Array(nodeCrypto.publicEncrypt(key, data));\n}\n\nasync function bnEncrypt(data, n, e) {\n  n = uint8ArrayToBigInt(n);\n  data = uint8ArrayToBigInt(emeEncode(data, byteLength(n)));\n  e = uint8ArrayToBigInt(e);\n  if (data >= n) {\n    throw new Error('Message size cannot exceed modulus size');\n  }\n  return bigIntToUint8Array(modExp(data, e, n), 'be', byteLength(n));\n}\n\nasync function nodeDecrypt(data, n, e, d, p, q, u) {\n  const jwk = await privateToJWK(n, e, d, p, q, u);\n  const key = { key: jwk, format: 'jwk' , type: 'pkcs1', padding: nodeCrypto.constants.RSA_PKCS1_PADDING };\n\n  try {\n    return new Uint8Array(nodeCrypto.privateDecrypt(key, data));\n  } catch (err) {\n    throw new Error('Decryption error');\n  }\n}\n\nasync function bnDecrypt(data, n, e, d, p, q, u, randomPayload) {\n  data = uint8ArrayToBigInt(data);\n  n = uint8ArrayToBigInt(n);\n  e = uint8ArrayToBigInt(e);\n  d = uint8ArrayToBigInt(d);\n  p = uint8ArrayToBigInt(p);\n  q = uint8ArrayToBigInt(q);\n  u = uint8ArrayToBigInt(u);\n  if (data >= n) {\n    throw new Error('Data too large.');\n  }\n  const dq = mod(d, q - _1n); // d mod (q-1)\n  const dp = mod(d, p - _1n); // d mod (p-1)\n\n  const unblinder = getRandomBigInteger(BigInt(2), n);\n  const blinder = modExp(modInv(unblinder, n), e, n);\n  data = mod(data * blinder, n);\n\n  const mp = modExp(data, dp, p); // data**{d mod (q-1)} mod p\n  const mq = modExp(data, dq, q); // data**{d mod (p-1)} mod q\n  const h = mod(u * (mq - mp), q); // u * (mq-mp) mod q (operands already < q)\n\n  let result = h * p + mp; // result < n due to relations above\n\n  result = mod(result * unblinder, n);\n\n  return emeDecode(bigIntToUint8Array(result, 'be', byteLength(n)), randomPayload);\n}\n\n/** Convert Openpgp private key params to jwk key according to\n * @link https://tools.ietf.org/html/rfc7517\n * @param {String} hashAlgo\n * @param {Uint8Array} n\n * @param {Uint8Array} e\n * @param {Uint8Array} d\n * @param {Uint8Array} p\n * @param {Uint8Array} q\n * @param {Uint8Array} u\n */\nasync function privateToJWK(n, e, d, p, q, u) {\n  const pNum = uint8ArrayToBigInt(p);\n  const qNum = uint8ArrayToBigInt(q);\n  const dNum = uint8ArrayToBigInt(d);\n\n  let dq = mod(dNum, qNum - _1n); // d mod (q-1)\n  let dp = mod(dNum, pNum - _1n); // d mod (p-1)\n  dp = bigIntToUint8Array(dp);\n  dq = bigIntToUint8Array(dq);\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToB64(n, true),\n    e: uint8ArrayToB64(e, true),\n    d: uint8ArrayToB64(d, true),\n    // switch p and q\n    p: uint8ArrayToB64(q, true),\n    q: uint8ArrayToB64(p, true),\n    // switch dp and dq\n    dp: uint8ArrayToB64(dq, true),\n    dq: uint8ArrayToB64(dp, true),\n    qi: uint8ArrayToB64(u, true),\n    ext: true\n  };\n}\n\n/** Convert Openpgp key public params to jwk key according to\n * @link https://tools.ietf.org/html/rfc7517\n * @param {String} hashAlgo\n * @param {Uint8Array} n\n * @param {Uint8Array} e\n */\nfunction publicToJWK(n, e) {\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToB64(n, true),\n    e: uint8ArrayToB64(e, true),\n    ext: true\n  };\n}\n\n/** Convert JWK private key to OpenPGP private key params */\nfunction jwkToPrivate(jwk, e) {\n  return {\n    n: b64ToUint8Array(jwk.n),\n    e: bigIntToUint8Array(e),\n    d: b64ToUint8Array(jwk.d),\n    // switch p and q\n    p: b64ToUint8Array(jwk.q),\n    q: b64ToUint8Array(jwk.p),\n    // Since p and q are switched in places, u is the inverse of jwk.q\n    u: b64ToUint8Array(jwk.qi)\n  };\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview ElGamal implementation\n * @module crypto/public_key/elgamal\n */\nimport { getRandomBigInteger } from '../random';\nimport { emeEncode, emeDecode } from '../pkcs1';\nimport { bigIntToUint8Array, bitLength, byteLength, mod, modExp, modInv, uint8ArrayToBigInt } from '../biginteger';\n\nconst _1n = BigInt(1);\n\n/**\n * ElGamal Encryption function\n * Note that in OpenPGP, the message needs to be padded with PKCS#1 (same as RSA)\n * @param {Uint8Array} data - To be padded and encrypted\n * @param {Uint8Array} p\n * @param {Uint8Array} g\n * @param {Uint8Array} y\n * @returns {Promise<{ c1: Uint8Array, c2: Uint8Array }>}\n * @async\n */\nexport async function encrypt(data, p, g, y) {\n  p = uint8ArrayToBigInt(p);\n  g = uint8ArrayToBigInt(g);\n  y = uint8ArrayToBigInt(y);\n\n  const padded = emeEncode(data, byteLength(p));\n  const m = uint8ArrayToBigInt(padded);\n\n  // OpenPGP uses a \"special\" version of ElGamal where g is generator of the full group Z/pZ*\n  // hence g has order p-1, and to avoid that k = 0 mod p-1, we need to pick k in [1, p-2]\n  const k = getRandomBigInteger(_1n, p - _1n);\n  return {\n    c1: bigIntToUint8Array(modExp(g, k, p)),\n    c2: bigIntToUint8Array(mod(modExp(y, k, p) * m, p))\n  };\n}\n\n/**\n * ElGamal Encryption function\n * @param {Uint8Array} c1\n * @param {Uint8Array} c2\n * @param {Uint8Array} p\n * @param {Uint8Array} x\n * @param {Uint8Array} randomPayload - Data to return on unpadding error, instead of throwing\n *                                     (needed for constant-time processing)\n * @returns {Promise<Uint8Array>} Unpadded message.\n * @throws {Error} on decryption error, unless `randomPayload` is given\n * @async\n */\nexport async function decrypt(c1, c2, p, x, randomPayload) {\n  c1 = uint8ArrayToBigInt(c1);\n  c2 = uint8ArrayToBigInt(c2);\n  p = uint8ArrayToBigInt(p);\n  x = uint8ArrayToBigInt(x);\n\n  const padded = mod(modInv(modExp(c1, x, p), p) * c2, p);\n  return emeDecode(bigIntToUint8Array(padded, 'be', byteLength(p)), randomPayload);\n}\n\n/**\n * Validate ElGamal parameters\n * @param {Uint8Array} p - ElGamal prime\n * @param {Uint8Array} g - ElGamal group generator\n * @param {Uint8Array} y - ElGamal public key\n * @param {Uint8Array} x - ElGamal private exponent\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(p, g, y, x) {\n  p = uint8ArrayToBigInt(p);\n  g = uint8ArrayToBigInt(g);\n  y = uint8ArrayToBigInt(y);\n\n  // Check that 1 < g < p\n  if (g <= _1n || g >= p) {\n    return false;\n  }\n\n  // Expect p-1 to be large\n  const pSize = BigInt(bitLength(p));\n  const _1023n = BigInt(1023);\n  if (pSize < _1023n) {\n    return false;\n  }\n\n  /**\n   * g should have order p-1\n   * Check that g ** (p-1) = 1 mod p\n   */\n  if (modExp(g, p - _1n, p) !== _1n) {\n    return false;\n  }\n\n  /**\n   * Since p-1 is not prime, g might have a smaller order that divides p-1\n   * We want to make sure that the order is large enough to hinder a small subgroup attack\n   *\n   * We just check g**i != 1 for all i up to a threshold\n   */\n  let res = g;\n  let i = BigInt(1);\n  const _2n = BigInt(2);\n  const threshold = _2n << BigInt(17); // we want order > threshold\n  while (i < threshold) {\n    res = mod(res * g, p);\n    if (res === _1n) {\n      return false;\n    }\n    i++;\n  }\n\n  /**\n   * Re-derive public key y' = g ** x mod p\n   * Expect y == y'\n   *\n   * Blinded exponentiation computes g**{r(p-1) + x} to compare to y\n   */\n  x = uint8ArrayToBigInt(x);\n  const r = getRandomBigInteger(_2n << (pSize - _1n), _2n << pSize); // draw r of same size as p-1\n  const rqx = (p - _1n) * r + x;\n  if (y !== modExp(g, rqx, p)) {\n    return false;\n  }\n\n  return true;\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * Wrapper to an OID value\n *\n * {@link https://tools.ietf.org/html/rfc6637#section-11|RFC6637, section 11}:\n * The sequence of octets in the third column is the result of applying\n * the Distinguished Encoding Rules (DER) to the ASN.1 Object Identifier\n * with subsequent truncation.  The truncation removes the two fields of\n * encoded Object Identifier.  The first omitted field is one octet\n * representing the Object Identifier tag, and the second omitted field\n * is the length of the Object Identifier body.  For example, the\n * complete ASN.1 DER encoding for the NIST P-256 curve OID is \"06 08 2A\n * 86 48 CE 3D 03 01 07\", from which the first entry in the table above\n * is constructed by omitting the first two octets.  Only the truncated\n * sequence of octets is the valid representation of a curve OID.\n * @module type/oid\n */\n\nimport util from '../util';\nimport enums from '../enums';\n\nconst knownOIDs = {\n  '2a8648ce3d030107': enums.curve.nistP256,\n  '2b81040022': enums.curve.nistP384,\n  '2b81040023': enums.curve.nistP521,\n  '2b8104000a': enums.curve.secp256k1,\n  '2b06010401da470f01': enums.curve.ed25519Legacy,\n  '2b060104019755010501': enums.curve.curve25519Legacy,\n  '2b2403030208010107': enums.curve.brainpoolP256r1,\n  '2b240303020801010b': enums.curve.brainpoolP384r1,\n  '2b240303020801010d': enums.curve.brainpoolP512r1\n};\n\nclass OID {\n  constructor(oid) {\n    if (oid instanceof OID) {\n      this.oid = oid.oid;\n    } else if (util.isArray(oid) ||\n               util.isUint8Array(oid)) {\n      oid = new Uint8Array(oid);\n      if (oid[0] === 0x06) { // DER encoded oid byte array\n        if (oid[1] !== oid.length - 2) {\n          throw new Error('Length mismatch in DER encoded oid');\n        }\n        oid = oid.subarray(2);\n      }\n      this.oid = oid;\n    } else {\n      this.oid = '';\n    }\n  }\n\n  /**\n   * Method to read an OID object\n   * @param {Uint8Array} input - Where to read the OID from\n   * @returns {Number} Number of read bytes.\n   */\n  read(input) {\n    if (input.length >= 1) {\n      const length = input[0];\n      if (input.length >= 1 + length) {\n        this.oid = input.subarray(1, 1 + length);\n        return 1 + this.oid.length;\n      }\n    }\n    throw new Error('Invalid oid');\n  }\n\n  /**\n   * Serialize an OID object\n   * @returns {Uint8Array} Array with the serialized value the OID.\n   */\n  write() {\n    return util.concatUint8Array([new Uint8Array([this.oid.length]), this.oid]);\n  }\n\n  /**\n   * Serialize an OID object as a hex string\n   * @returns {string} String with the hex value of the OID.\n   */\n  toHex() {\n    return util.uint8ArrayToHex(this.oid);\n  }\n\n  /**\n   * If a known curve object identifier, return the canonical name of the curve\n   * @returns {enums.curve} String with the canonical name of the curve\n   * @throws if unknown\n   */\n  getName() {\n    const name = knownOIDs[this.toHex()];\n    if (!name) {\n      throw new Error('Unknown curve object identifier.');\n    }\n\n    return name;\n  }\n}\n\nexport default OID;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Functions for reading and writing packets\n * @module packet/packet\n */\n\nimport { ArrayStream, getWriter as streamGetWriter } from '@openpgp/web-stream-tools';\nimport enums from '../enums';\nimport util from '../util';\n\nexport function readSimpleLength(bytes) {\n  let len = 0;\n  let offset;\n  const type = bytes[0];\n\n\n  if (type < 192) {\n    [len] = bytes;\n    offset = 1;\n  } else if (type < 255) {\n    len = ((bytes[0] - 192) << 8) + (bytes[1]) + 192;\n    offset = 2;\n  } else if (type === 255) {\n    len = util.readNumber(bytes.subarray(1, 1 + 4));\n    offset = 5;\n  }\n\n  return {\n    len: len,\n    offset: offset\n  };\n}\n\n/**\n * Encodes a given integer of length to the openpgp length specifier to a\n * string\n *\n * @param {Integer} length - The length to encode\n * @returns {Uint8Array} String with openpgp length representation.\n */\nexport function writeSimpleLength(length) {\n  if (length < 192) {\n    return new Uint8Array([length]);\n  } else if (length > 191 && length < 8384) {\n    /*\n      * let a = (total data packet length) - 192 let bc = two octet\n      * representation of a let d = b + 192\n      */\n    return new Uint8Array([((length - 192) >> 8) + 192, (length - 192) & 0xFF]);\n  }\n  return util.concatUint8Array([new Uint8Array([255]), util.writeNumber(length, 4)]);\n}\n\nexport function writePartialLength(power) {\n  if (power < 0 || power > 30) {\n    throw new Error('Partial Length power must be between 1 and 30');\n  }\n  return new Uint8Array([224 + power]);\n}\n\nexport function writeTag(tag_type) {\n  /* we're only generating v4 packet headers here */\n  return new Uint8Array([0xC0 | tag_type]);\n}\n\n/**\n * Writes a packet header version 4 with the given tag_type and length to a\n * string\n *\n * @param {Integer} tag_type - Tag type\n * @param {Integer} length - Length of the payload\n * @returns {String} String of the header.\n */\nexport function writeHeader(tag_type, length) {\n  /* we're only generating v4 packet headers here */\n  return util.concatUint8Array([writeTag(tag_type), writeSimpleLength(length)]);\n}\n\n/**\n * Whether the packet type supports partial lengths per RFC4880\n * @param {Integer} tag - Tag type\n * @returns {Boolean} String of the header.\n */\nexport function supportsStreaming(tag) {\n  return [\n    enums.packet.literalData,\n    enums.packet.compressedData,\n    enums.packet.symmetricallyEncryptedData,\n    enums.packet.symEncryptedIntegrityProtectedData,\n    enums.packet.aeadEncryptedData\n  ].includes(tag);\n}\n\n/**\n * Generic static Packet Parser function\n *\n * @param {Uint8Array | ReadableStream<Uint8Array>} input - Input stream as string\n * @param {Function} callback - Function to call with the parsed packet\n * @returns {Boolean} Returns false if the stream was empty and parsing is done, and true otherwise.\n */\nexport async function readPacket(reader, useStreamType, callback) {\n  let writer;\n  let callbackReturned;\n  try {\n    const peekedBytes = await reader.peekBytes(2);\n    // some sanity checks\n    if (!peekedBytes || peekedBytes.length < 2 || (peekedBytes[0] & 0x80) === 0) {\n      throw new Error('Error during parsing. This message / key probably does not conform to a valid OpenPGP format.');\n    }\n    const headerByte = await reader.readByte();\n    let tag = -1;\n    let format = -1;\n    let packetLength;\n\n    format = 0; // 0 = old format; 1 = new format\n    if ((headerByte & 0x40) !== 0) {\n      format = 1;\n    }\n\n    let packetLengthType;\n    if (format) {\n      // new format header\n      tag = headerByte & 0x3F; // bit 5-0\n    } else {\n      // old format header\n      tag = (headerByte & 0x3F) >> 2; // bit 5-2\n      packetLengthType = headerByte & 0x03; // bit 1-0\n    }\n\n    const packetSupportsStreaming = supportsStreaming(tag);\n    let packet = null;\n    if (useStreamType && packetSupportsStreaming) {\n      if (useStreamType === 'array') {\n        const arrayStream = new ArrayStream();\n        writer = streamGetWriter(arrayStream);\n        packet = arrayStream;\n      } else {\n        const transform = new TransformStream();\n        writer = streamGetWriter(transform.writable);\n        packet = transform.readable;\n      }\n      // eslint-disable-next-line callback-return\n      callbackReturned = callback({ tag, packet });\n    } else {\n      packet = [];\n    }\n\n    let wasPartialLength;\n    do {\n      if (!format) {\n        // 4.2.1. Old Format Packet Lengths\n        switch (packetLengthType) {\n          case 0:\n            // The packet has a one-octet length. The header is 2 octets\n            // long.\n            packetLength = await reader.readByte();\n            break;\n          case 1:\n            // The packet has a two-octet length. The header is 3 octets\n            // long.\n            packetLength = (await reader.readByte() << 8) | await reader.readByte();\n            break;\n          case 2:\n            // The packet has a four-octet length. The header is 5\n            // octets long.\n            packetLength = (await reader.readByte() << 24) | (await reader.readByte() << 16) | (await reader.readByte() <<\n              8) | await reader.readByte();\n            break;\n          default:\n            // 3 - The packet is of indeterminate length. The header is 1\n            // octet long, and the implementation must determine how long\n            // the packet is. If the packet is in a file, this means that\n            // the packet extends until the end of the file. In general,\n            // an implementation SHOULD NOT use indeterminate-length\n            // packets except where the end of the data will be clear\n            // from the context, and even then it is better to use a\n            // definite length, or a new format header. The new format\n            // headers described below have a mechanism for precisely\n            // encoding data of indeterminate length.\n            packetLength = Infinity;\n            break;\n        }\n      } else { // 4.2.2. New Format Packet Lengths\n        // 4.2.2.1. One-Octet Lengths\n        const lengthByte = await reader.readByte();\n        wasPartialLength = false;\n        if (lengthByte < 192) {\n          packetLength = lengthByte;\n          // 4.2.2.2. Two-Octet Lengths\n        } else if (lengthByte >= 192 && lengthByte < 224) {\n          packetLength = ((lengthByte - 192) << 8) + (await reader.readByte()) + 192;\n          // 4.2.2.4. Partial Body Lengths\n        } else if (lengthByte > 223 && lengthByte < 255) {\n          packetLength = 1 << (lengthByte & 0x1F);\n          wasPartialLength = true;\n          if (!packetSupportsStreaming) {\n            throw new TypeError('This packet type does not support partial lengths.');\n          }\n          // 4.2.2.3. Five-Octet Lengths\n        } else {\n          packetLength = (await reader.readByte() << 24) | (await reader.readByte() << 16) | (await reader.readByte() <<\n            8) | await reader.readByte();\n        }\n      }\n      if (packetLength > 0) {\n        let bytesRead = 0;\n        while (true) {\n          if (writer) await writer.ready;\n          const { done, value } = await reader.read();\n          if (done) {\n            if (packetLength === Infinity) break;\n            throw new Error('Unexpected end of packet');\n          }\n          const chunk = packetLength === Infinity ? value : value.subarray(0, packetLength - bytesRead);\n          if (writer) await writer.write(chunk);\n          else packet.push(chunk);\n          bytesRead += value.length;\n          if (bytesRead >= packetLength) {\n            reader.unshift(value.subarray(packetLength - bytesRead + value.length));\n            break;\n          }\n        }\n      }\n    } while (wasPartialLength);\n\n    if (writer) {\n      await writer.ready;\n      await writer.close();\n    } else {\n      packet = util.concatUint8Array(packet);\n      // eslint-disable-next-line callback-return\n      await callback({ tag, packet });\n    }\n  } catch (e) {\n    if (writer) {\n      await writer.abort(e);\n      return true;\n    } else {\n      throw e;\n    }\n  } finally {\n    if (writer) {\n      await callbackReturned;\n    }\n  }\n}\n\nexport class UnsupportedError extends Error {\n  constructor(...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnsupportedError);\n    }\n\n    this.name = 'UnsupportedError';\n  }\n}\n\n// unknown packet types are handled differently depending on the packet criticality\nexport class UnknownPacketError extends UnsupportedError {\n  constructor(...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnsupportedError);\n    }\n\n    this.name = 'UnknownPacketError';\n  }\n}\n\nexport class MalformedPacketError extends UnsupportedError {\n  constructor(...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnsupportedError);\n    }\n\n    this.name = 'MalformedPacketError';\n  }\n}\n\nexport class UnparseablePacket {\n  constructor(tag, rawContent) {\n    this.tag = tag;\n    this.rawContent = rawContent;\n  }\n\n  write() {\n    return this.rawContent;\n  }\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2018 Proton Technologies AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Implementation of EdDSA following RFC4880bis-03 for OpenPGP\n * @module crypto/public_key/elliptic/eddsa\n */\n\nimport util from '../../../util';\nimport enums from '../../../enums';\nimport { getHashByteLength } from '../../hash';\nimport { getRandomBytes } from '../../random';\nimport { b64ToUint8Array, uint8ArrayToB64 } from '../../../encoding/base64';\n\n\n/**\n * Generate (non-legacy) EdDSA key\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @returns {Promise<{ A: Uint8Array, seed: Uint8Array }>}\n */\nexport async function generate(algo) {\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const webCryptoKey = await webCrypto.generateKey('Ed25519', true, ['sign', 'verify'])\n          .catch(err => {\n            if (err.name === 'OperationError') { // Temporary (hopefully) fix for WebKit on Linux\n              const newErr = new Error('Unexpected key generation issue');\n              newErr.name = 'NotSupportedError';\n              throw newErr;\n            }\n            throw err;\n          });\n\n        const privateKey = await webCrypto.exportKey('jwk', webCryptoKey.privateKey);\n        const publicKey = await webCrypto.exportKey('jwk', webCryptoKey.publicKey);\n\n        return {\n          A: new Uint8Array(b64ToUint8Array(publicKey.x)),\n          seed: b64ToUint8Array(privateKey.d, true)\n        };\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: ed25519 } = await import('@openpgp/tweetnacl');\n        const seed = getRandomBytes(getPayloadSize(algo));\n        // not using `ed25519.sign.keyPair` since it returns the expanded secret, so using `fromSeed` instead is more straightforward\n        const { publicKey: A } = ed25519.sign.keyPair.fromSeed(seed);\n        return { A, seed };\n      }\n\n    case enums.publicKey.ed448: {\n      const ed448 = await util.getNobleCurve(enums.publicKey.ed448);\n      const { secretKey: seed, publicKey: A } = ed448.keygen();\n      return { A, seed };\n    }\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n}\n\n/**\n * Sign a message using the provided key\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used to sign (must be sha256 or stronger)\n * @param {Uint8Array} message - Message to sign\n * @param {Uint8Array} publicKey - Public key\n * @param {Uint8Array} privateKey - Private key used to sign the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Promise<{\n *   RS: Uint8Array\n * }>} Signature of the message\n * @async\n */\nexport async function sign(algo, hashAlgo, message, publicKey, privateKey, hashed) {\n  if (getHashByteLength(hashAlgo) < getHashByteLength(getPreferredHashAlgo(algo))) {\n    // Enforce digest sizes:\n    // - Ed25519: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.4-4\n    // - Ed448: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.5-4\n    throw new Error('Hash algorithm too weak for EdDSA.');\n  }\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const jwk = privateKeyToJWK(algo, publicKey, privateKey);\n        const key = await webCrypto.importKey('jwk', jwk, 'Ed25519', false, ['sign']);\n\n        const signature = new Uint8Array(\n          await webCrypto.sign('Ed25519', key, hashed)\n        );\n\n        return { RS: signature };\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: ed25519 } = await import('@openpgp/tweetnacl');\n        const secretKey = util.concatUint8Array([privateKey, publicKey]);\n        const signature = ed25519.sign.detached(hashed, secretKey);\n        return { RS: signature };\n      }\n\n    case enums.publicKey.ed448: {\n      const ed448 = await util.getNobleCurve(enums.publicKey.ed448);\n      const signature = ed448.sign(hashed, privateKey);\n      return { RS: signature };\n    }\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n\n}\n\n/**\n * Verifies if a signature is valid for a message\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used in the signature\n * @param  {{ RS: Uint8Array }} signature Signature to verify the message\n * @param {Uint8Array} m - Message to verify\n * @param {Uint8Array} publicKey - Public key used to verify the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Boolean}\n * @async\n */\nexport async function verify(algo, hashAlgo, { RS }, m, publicKey, hashed) {\n  if (getHashByteLength(hashAlgo) < getHashByteLength(getPreferredHashAlgo(algo))) {\n    // Enforce digest sizes:\n    // - Ed25519: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.4-4\n    // - Ed448: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.5-4\n    throw new Error('Hash algorithm too weak for EdDSA.');\n  }\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const jwk = publicKeyToJWK(algo, publicKey);\n        const key = await webCrypto.importKey('jwk', jwk, 'Ed25519', false, ['verify']);\n        const verified = await webCrypto.verify('Ed25519', key, RS, hashed);\n        return verified;\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: ed25519 } = await import('@openpgp/tweetnacl');\n        return ed25519.sign.detached.verify(hashed, RS, publicKey);\n      }\n\n    case enums.publicKey.ed448: {\n      const ed448 = await util.getNobleCurve(enums.publicKey.ed448);\n      return ed448.verify(RS, hashed, publicKey);\n    }\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n}\n/**\n * Validate (non-legacy) EdDSA parameters\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @param {Uint8Array} A - EdDSA public point\n * @param {Uint8Array} seed - EdDSA secret seed\n * @param {Uint8Array} oid - (legacy only) EdDSA OID\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(algo, A, seed) {\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      // If webcrypto support is available, we sign-verify random data, as the import-export\n      // functions might not implement validity checks.\n      // If we need to fallback to JS, we instead only re-derive the public key,\n      // as this is much faster than sign-verify.\n      try {\n        const webCrypto = util.getWebCrypto();\n        const jwkPrivate = privateKeyToJWK(algo, A, seed);\n        const jwkPublic = publicKeyToJWK(algo, A);\n\n        const privateCryptoKey = await webCrypto.importKey('jwk', jwkPrivate, 'Ed25519', false, ['sign']);\n        const publicCryptoKey = await webCrypto.importKey('jwk', jwkPublic, 'Ed25519', false, ['verify']);\n\n        const randomData = getRandomBytes(8);\n        const signature = new Uint8Array(\n          await webCrypto.sign('Ed25519', privateCryptoKey, randomData)\n        );\n\n        const verified = await webCrypto.verify('Ed25519', publicCryptoKey, signature, randomData);\n        return verified;\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          return false;\n        }\n        const { default: ed25519 } = await import('@openpgp/tweetnacl');\n        const { publicKey } = ed25519.sign.keyPair.fromSeed(seed);\n        return util.equalsUint8Array(A, publicKey);\n      }\n\n    case enums.publicKey.ed448: {\n      const ed448 = await util.getNobleCurve(enums.publicKey.ed448);\n\n      const publicKey = ed448.getPublicKey(seed);\n      return util.equalsUint8Array(A, publicKey);\n    }\n    default:\n      return false;\n  }\n}\n\nexport function getPayloadSize(algo) {\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      return 32;\n\n    case enums.publicKey.ed448:\n      return 57;\n\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n}\n\nexport function getPreferredHashAlgo(algo) {\n  switch (algo) {\n    case enums.publicKey.ed25519:\n      return enums.hash.sha256;\n    case enums.publicKey.ed448:\n      return enums.hash.sha512;\n    default:\n      throw new Error('Unknown EdDSA algo');\n  }\n}\n\nconst publicKeyToJWK = (algo, publicKey) => {\n  switch (algo) {\n    case enums.publicKey.ed25519: {\n      const jwk = {\n        kty: 'OKP',\n        crv: 'Ed25519',\n        x: uint8ArrayToB64(publicKey, true),\n        ext: true\n      };\n      return jwk;\n    }\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n};\n\nconst privateKeyToJWK = (algo, publicKey, privateKey) => {\n  switch (algo) {\n    case enums.publicKey.ed25519: {\n      const jwk = publicKeyToJWK(algo, publicKey);\n      jwk.d = uint8ArrayToB64(privateKey, true);\n      return jwk;\n    }\n    default:\n      throw new Error('Unsupported EdDSA algorithm');\n  }\n};\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is boolean. */\nexport function abool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// Used in micro\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\n// Used in micro, ff1\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = copyBytes(data);\n    else\n        throw new Error('Uint8Array expected, got ' + typeof data);\n    return data;\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a, b) {\n    return (a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n    );\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input, output) {\n    // This is very cursed. It works somehow, but I'm completely unsure,\n    // reasoning about overlapping aligned windows is very hard.\n    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n        throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport class Hash {\n}\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = (params, constructor) => {\n    function wrappedCipher(key, ...args) {\n        // Validate key\n        abytes(key);\n        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n        if (!isLE)\n            throw new Error('Non little-endian hardware is not yet supported');\n        // Validate nonce if nonceLength is present\n        if (params.nonceLength !== undefined) {\n            const nonce = args[0];\n            if (!nonce)\n                throw new Error('nonce / iv required');\n            if (params.varSizeNonce)\n                abytes(nonce);\n            else\n                abytes(nonce, params.nonceLength);\n        }\n        // Validate AAD if tagLength present\n        const tagl = params.tagLength;\n        if (tagl && args[1] !== undefined) {\n            abytes(args[1]);\n        }\n        const cipher = constructor(key, ...args);\n        const checkOutput = (fnLength, output) => {\n            if (output !== undefined) {\n                if (fnLength !== 2)\n                    throw new Error('cipher output not supported');\n                abytes(output);\n            }\n        };\n        // Create wrapped cipher with validation and single-use encryption\n        let called = false;\n        const wrCipher = {\n            encrypt(data, output) {\n                if (called)\n                    throw new Error('cannot encrypt() twice with same key + nonce');\n                called = true;\n                abytes(data);\n                checkOutput(cipher.encrypt.length, output);\n                return cipher.encrypt(data, output);\n            },\n            decrypt(data, output) {\n                abytes(data);\n                if (tagl && data.length < tagl)\n                    throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n                checkOutput(cipher.decrypt.length, output);\n                return cipher.decrypt(data, output);\n            },\n        };\n        return wrCipher;\n    }\n    Object.assign(wrappedCipher, params);\n    return wrappedCipher;\n};\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(expectedLength, out, onlyAligned = true) {\n    if (out === undefined)\n        return new Uint8Array(expectedLength);\n    if (out.length !== expectedLength)\n        throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n    if (onlyAligned && !isAligned32(out))\n        throw new Error('invalid output, must be aligned');\n    return out;\n}\n/** Polyfill for Safari 14. */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(dataLength, aadLength, isLE) {\n    abool(isLE);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(aadLength), isLE);\n    setBigUint64(view, 8, BigInt(dataLength), isLE);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n//# sourceMappingURL=utils.js.map","/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport { abytes, aexists, aoutput, clean, copyBytes, createView, Hash, toBytes, u32, } from \"./utils.js\";\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = toBytes(key);\n        abytes(key, 16);\n        const kView = createView(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const b32 = u32(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            clean(ZEROS32); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = toBytes(key);\n        abytes(key);\n        const ghKey = _toGHASHKey(copyBytes(key));\n        super(ghKey, expectedLength);\n        clean(ghKey);\n    }\n    update(data) {\n        data = toBytes(data);\n        aexists(this);\n        const b32 = u32(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            clean(ZEROS32);\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\n/** GHash MAC for AES-GCM. */\nexport const ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\n/** Polyval MAC for AES-SIV. */\nexport const polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n//# sourceMappingURL=_polyval.js.map","/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from \"./_polyval.js\";\n// prettier-ignore\nimport { abytes, clean, complexOverlapBytes, concatBytes, copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes, setBigUint64, u32, u64Lengths, u8, wrapCipher, } from \"./utils.js\";\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n    const t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const box = new Uint8Array(256);\n    box[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    clean(t);\n    return box;\n})();\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst xPowers = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key) {\n    abytes(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n    const { sbox2 } = tableEncoding;\n    const toClean = [];\n    if (!isAligned32(key))\n        toClean.push((key = copyBytes(key)));\n    const k32 = u32(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    clean(...toClean);\n    return xk;\n}\nfunction expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = tableEncoding;\n    const { T0, T1, T2, T3 } = tableDecoding;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    clean(encKey);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableEncoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableDecoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    abytes(nonce, BLOCK_SIZE);\n    abytes(src);\n    const srcLen = src.length;\n    dst = getOutput(srcLen, dst);\n    complexOverlapBytes(src, dst);\n    const ctr = nonce;\n    const c32 = u32(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n        clean(b32);\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    abytes(nonce, BLOCK_SIZE);\n    abytes(src);\n    dst = getOutput(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = u32(ctr);\n    const view = createView(ctr);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n        clean(b32);\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {\n    function processCtr(buf, dst) {\n        abytes(buf);\n        if (dst !== undefined) {\n            abytes(dst);\n            if (!isAligned32(dst))\n                throw new Error('unaligned destination');\n        }\n        const xk = expandKeyLE(key);\n        const n = copyBytes(nonce); // align + avoid changing\n        const toClean = [xk, n];\n        if (!isAligned32(buf))\n            toClean.push((buf = copyBytes(buf)));\n        const out = ctrCounter(xk, n, buf, dst);\n        clean(...toClean);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    abytes(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error('aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    abytes(plaintext);\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    if (!isAligned32(plaintext))\n        plaintext = copyBytes(plaintext);\n    const b = u32(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    dst = getOutput(outLen, dst);\n    complexOverlapBytes(plaintext, dst);\n    const o = u32(dst);\n    return { b, o, out: dst };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error('aes/pcks5: empty ciphertext not allowed');\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error('aes/pcks5: wrong padding');\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error('aes/pcks5: wrong padding');\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = u32(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb = /* @__PURE__ */ wrapCipher({ blockSize: 16 }, function aesecb(key, opts = {}) {\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt(plaintext, dst) {\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            clean(xk);\n            return _out;\n        },\n        decrypt(ciphertext, dst) {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            dst = getOutput(ciphertext.length, dst);\n            const toClean = [xk];\n            if (!isAligned32(ciphertext))\n                toClean.push((ciphertext = copyBytes(ciphertext)));\n            complexOverlapBytes(ciphertext, dst);\n            const b = u32(ciphertext);\n            const o = u32(dst);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            clean(...toClean);\n            return validatePCKS(dst, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous rounds block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt(plaintext, dst) {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            let _iv = iv;\n            const toClean = [xk];\n            if (!isAligned32(_iv))\n                toClean.push((_iv = copyBytes(_iv)));\n            const n32 = u32(_iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            clean(...toClean);\n            return _out;\n        },\n        decrypt(ciphertext, dst) {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            let _iv = iv;\n            const toClean = [xk];\n            if (!isAligned32(_iv))\n                toClean.push((_iv = copyBytes(_iv)));\n            const n32 = u32(_iv);\n            dst = getOutput(ciphertext.length, dst);\n            if (!isAligned32(ciphertext))\n                toClean.push((ciphertext = copyBytes(ciphertext)));\n            complexOverlapBytes(ciphertext, dst);\n            const b = u32(ciphertext);\n            const o = u32(dst);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            clean(...toClean);\n            return validatePCKS(dst, pcks5);\n        },\n    };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescfb(key, iv) {\n    function processCfb(src, isEncrypt, dst) {\n        abytes(src);\n        const srcLen = src.length;\n        dst = getOutput(srcLen, dst);\n        if (overlapBytes(src, dst))\n            throw new Error('overlapping src and dst not supported.');\n        const xk = expandKeyLE(key);\n        let _iv = iv;\n        const toClean = [xk];\n        if (!isAligned32(_iv))\n            toClean.push((_iv = copyBytes(_iv)));\n        if (!isAligned32(src))\n            toClean.push((src = copyBytes(src)));\n        const src32 = u32(src);\n        const dst32 = u32(dst);\n        const next32 = isEncrypt ? dst32 : src32;\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= src32.length;) {\n            const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n            dst32[i + 0] = src32[i + 0] ^ e0;\n            dst32[i + 1] = src32[i + 1] ^ e1;\n            dst32[i + 2] = src32[i + 2] ^ e2;\n            dst32[i + 3] = src32[i + 3] ^ e3;\n            (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n        }\n        // leftovers (less than block)\n        const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n        if (start < srcLen) {\n            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n            const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n            for (let i = start, pos = 0; i < srcLen; i++, pos++)\n                dst[i] = src[i] ^ buf[pos];\n            clean(buf);\n        }\n        clean(...toClean);\n        return dst;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n        decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst),\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const aadLength = AAD ? AAD.length : 0;\n    const h = fn.create(key, data.length + aadLength);\n    if (AAD)\n        h.update(AAD);\n    const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n    h.update(data);\n    h.update(num);\n    const res = h.digest();\n    clean(num);\n    return res;\n}\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8)\n        throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = createView(nonceLen);\n            setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            const g = ghash.create(authKey).update(nonce).update(nonceLen);\n            g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n            g.destroy();\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt(plaintext) {\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            const toClean = [xk, authKey, counter, tagMask];\n            if (!isAligned32(plaintext))\n                toClean.push((plaintext = copyBytes(plaintext)));\n            ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            toClean.push(tag);\n            out.set(tag, plaintext.length);\n            clean(...toClean);\n            return out;\n        },\n        decrypt(ciphertext) {\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const toClean = [xk, authKey, tagMask, counter];\n            if (!isAligned32(ciphertext))\n                toClean.push((ciphertext = copyBytes(ciphertext)));\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            toClean.push(tag);\n            if (!equalBytes(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            clean(...toClean);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max) {\n        const minmax = '[' + min + '..' + max + ']';\n        throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n    }\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aessiv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined)\n        AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(key.length);\n        const authKey = new Uint8Array(16);\n        const toClean = [xk, encKey];\n        let _nonce = nonce;\n        if (!isAligned32(_nonce))\n            toClean.push((_nonce = copyBytes(_nonce)));\n        const n32 = u32(_nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(u32)) {\n            const d32 = u32(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        const res = { authKey, encKey: expandKeyLE(encKey) };\n        // Cleanup\n        clean(...toClean);\n        return res;\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = u32(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = copyBytes(tag);\n        block[15] |= 0x80; // Force highest bit\n        const res = ctr32(encKey, true, block, input);\n        // Cleanup\n        clean(block);\n        return res;\n    }\n    return {\n        encrypt(plaintext) {\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const toClean = [encKey, authKey, tag];\n            if (!isAligned32(plaintext))\n                toClean.push((plaintext = copyBytes(plaintext)));\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            // Cleanup\n            clean(...toClean);\n            return out;\n        },\n        decrypt(ciphertext) {\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const toClean = [encKey, authKey];\n            if (!isAligned32(ciphertext))\n                toClean.push((ciphertext = copyBytes(ciphertext)));\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            toClean.push(expectedTag);\n            if (!equalBytes(tag, expectedTag)) {\n                clean(...toClean);\n                throw new Error('invalid polyval tag');\n            }\n            // Cleanup\n            clean(...toClean);\n            return plaintext;\n        },\n    };\n});\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv = gcmsiv;\nfunction isBytes32(a) {\n    return (a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    abytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    abytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n    /*\n    High-level pseudocode:\n    ```\n    A: u64 = IV\n    out = []\n    for (let i=0, ctr = 0; i<6; i++) {\n      for (const chunk of chunks(plaintext, 8)) {\n        A ^= swapEndianess(ctr++)\n        [A, res] = chunks(encrypt(A || chunk), 8);\n        out ||= res\n      }\n    }\n    out = A || out\n    ```\n    Decrypt is the same, but reversed.\n    */\n    encrypt(kek, out) {\n        // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n        // If you need it larger, open an issue.\n        if (out.length >= 2 ** 32)\n            throw new Error('plaintext should be less than 4gb');\n        const xk = expandKeyLE(kek);\n        if (out.length === 16)\n            encryptBlock(xk, out);\n        else {\n            const o32 = u32(out);\n            // prettier-ignore\n            let a0 = o32[0], a1 = o32[1]; // A\n            for (let j = 0, ctr = 1; j < 6; j++) {\n                for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n                    const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n                    // A = MSB(64, B) ^ t where t = (n*j)+i\n                    (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n                }\n            }\n            (o32[0] = a0), (o32[1] = a1); // out = A || out\n        }\n        xk.fill(0);\n    },\n    decrypt(kek, out) {\n        if (out.length - 8 >= 2 ** 32)\n            throw new Error('ciphertext should be less than 4gb');\n        const xk = expandKeyDecLE(kek);\n        const chunks = out.length / 8 - 1; // first chunk is IV\n        if (chunks === 1)\n            decryptBlock(xk, out);\n        else {\n            const o32 = u32(out);\n            // prettier-ignore\n            let a0 = o32[0], a1 = o32[1]; // A\n            for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n                for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n                    a1 ^= byteSwap(ctr);\n                    const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n                    (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n                }\n            }\n            (o32[0] = a0), (o32[1] = a1);\n        }\n        xk.fill(0);\n    },\n};\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw = /* @__PURE__ */ wrapCipher({ blockSize: 8 }, (kek) => ({\n    encrypt(plaintext) {\n        if (!plaintext.length || plaintext.length % 8 !== 0)\n            throw new Error('invalid plaintext length');\n        if (plaintext.length === 8)\n            throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n        const out = concatBytes(AESKW_IV, plaintext);\n        AESW.encrypt(kek, out);\n        return out;\n    },\n    decrypt(ciphertext) {\n        // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n        // 24 because should have at least two block (1 iv + 2).\n        // Replace with 16 to enable '8-byte keys'\n        if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n            throw new Error('invalid ciphertext length');\n        const out = copyBytes(ciphertext);\n        AESW.decrypt(kek, out);\n        if (!equalBytes(out.subarray(0, 8), AESKW_IV))\n            throw new Error('integrity check failed');\n        out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n        return out.subarray(8);\n    },\n}));\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp = /* @__PURE__ */ wrapCipher({ blockSize: 8 }, (kek) => ({\n    encrypt(plaintext) {\n        if (!plaintext.length)\n            throw new Error('invalid plaintext length');\n        const padded = Math.ceil(plaintext.length / 8) * 8;\n        const out = new Uint8Array(8 + padded);\n        out.set(plaintext, 8);\n        const out32 = u32(out);\n        out32[0] = AESKWP_IV;\n        out32[1] = byteSwap(plaintext.length);\n        AESW.encrypt(kek, out);\n        return out;\n    },\n    decrypt(ciphertext) {\n        // 16 because should have at least one block\n        if (ciphertext.length < 16)\n            throw new Error('invalid ciphertext length');\n        const out = copyBytes(ciphertext);\n        const o32 = u32(out);\n        AESW.decrypt(kek, out);\n        const len = byteSwap(o32[1]) >>> 0;\n        const padded = Math.ceil(len / 8) * 8;\n        if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n            throw new Error('integrity check failed');\n        for (let i = len; i < padded; i++)\n            if (out[8 + i] !== 0)\n                throw new Error('integrity check failed');\n        out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n        return out.subarray(8, 8 + len);\n    },\n}));\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n//# sourceMappingURL=aes.js.map","import enums from '../../enums';\n\nexport async function getLegacyCipher(algo) {\n  switch (algo) {\n    case enums.symmetric.aes128:\n    case enums.symmetric.aes192:\n    case enums.symmetric.aes256:\n      throw new Error('Not a legacy cipher');\n    case enums.symmetric.cast5:\n    case enums.symmetric.blowfish:\n    case enums.symmetric.twofish:\n    case enums.symmetric.tripledes: {\n      const { legacyCiphers } = await import('./legacy_ciphers');\n      const algoName = enums.read(enums.symmetric, algo);\n      const cipher = legacyCiphers.get(algoName);\n      if (!cipher) {\n        throw new Error('Unsupported cipher algorithm');\n      }\n      return cipher;\n    }\n    default:\n      throw new Error('Unsupported cipher algorithm');\n  }\n}\n\n/**\n * Get block size for given cipher algo\n * @param {module:enums.symmetric} algo - alrogithm identifier\n */\nfunction getCipherBlockSize(algo) {\n  switch (algo) {\n    case enums.symmetric.aes128:\n    case enums.symmetric.aes192:\n    case enums.symmetric.aes256:\n    case enums.symmetric.twofish:\n      return 16;\n    case enums.symmetric.blowfish:\n    case enums.symmetric.cast5:\n    case enums.symmetric.tripledes:\n      return 8;\n    default:\n      throw new Error('Unsupported cipher');\n  }\n}\n\n/**\n * Get key size for given cipher algo\n * @param {module:enums.symmetric} algo - alrogithm identifier\n */\nfunction getCipherKeySize(algo) {\n  switch (algo) {\n    case enums.symmetric.aes128:\n    case enums.symmetric.blowfish:\n    case enums.symmetric.cast5:\n      return 16;\n    case enums.symmetric.aes192:\n    case enums.symmetric.tripledes:\n      return 24;\n    case enums.symmetric.aes256:\n    case enums.symmetric.twofish:\n      return 32;\n    default:\n      throw new Error('Unsupported cipher');\n  }\n}\n\n/**\n * Get block and key size for given cipher algo\n * @param {module:enums.symmetric} algo - alrogithm identifier\n */\nexport function getCipherParams(algo) {\n  return { keySize: getCipherKeySize(algo), blockSize: getCipherBlockSize(algo) };\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Implementation of RFC 3394 AES Key Wrap & Key Unwrap funcions\n * @see module:crypto/public_key/elliptic/ecdh\n * @module crypto/aes_kw\n */\n\nimport { aeskw as nobleAesKW } from '@noble/ciphers/aes';\nimport { getCipherParams } from './cipher';\nimport util from '../util';\n\nconst webCrypto = util.getWebCrypto();\n/**\n * AES key wrap\n * @param {enums.symmetric.aes128|enums.symmetric.aes256|enums.symmetric.aes192} algo - AES algo\n * @param {Uint8Array} key - wrapping key\n * @param {Uint8Array} dataToWrap\n * @returns {Uint8Array} wrapped key\n */\nexport async function wrap(algo, key, dataToWrap) {\n  const { keySize } = getCipherParams(algo);\n  // sanity checks, since WebCrypto does not use the `algo` input\n  if (!util.isAES(algo) || key.length !== keySize) {\n    throw new Error('Unexpected algorithm or key size');\n  }\n\n  try {\n    const wrappingKey = await webCrypto.importKey('raw', key, { name: 'AES-KW' }, false, ['wrapKey']);\n    // Import data as HMAC key, as it has no key length requirements\n    const keyToWrap = await webCrypto.importKey('raw', dataToWrap, { name: 'HMAC', hash: 'SHA-256' }, true, ['sign']);\n    const wrapped = await webCrypto.wrapKey('raw', keyToWrap, wrappingKey, { name: 'AES-KW' });\n    return new Uint8Array(wrapped);\n  } catch (err) {\n    // no 192 bit support in Chromium, which throws `OperationError`, see: https://www.chromium.org/blink/webcrypto#TOC-AES-support\n    if (err.name !== 'NotSupportedError' &&\n      !(key.length === 24 && err.name === 'OperationError')) {\n      throw err;\n    }\n    util.printDebugError('Browser did not support operation: ' + err.message);\n  }\n\n  return nobleAesKW(key).encrypt(dataToWrap);\n}\n\n/**\n * AES key unwrap\n * @param {enums.symmetric.aes128|enums.symmetric.aes256|enums.symmetric.aes192} algo - AES algo\n * @param {Uint8Array} key - wrapping key\n * @param {Uint8Array} wrappedData\n * @returns {Uint8Array} unwrapped data\n */\nexport async function unwrap(algo, key, wrappedData) {\n  const { keySize } = getCipherParams(algo);\n  // sanity checks, since WebCrypto does not use the `algo` input\n  if (!util.isAES(algo) || key.length !== keySize) {\n    throw new Error('Unexpected algorithm or key size');\n  }\n\n  let wrappingKey;\n  try {\n    wrappingKey = await webCrypto.importKey('raw', key, { name: 'AES-KW' }, false, ['unwrapKey']);\n  } catch (err) {\n    // no 192 bit support in Chromium, which throws `OperationError`, see: https://www.chromium.org/blink/webcrypto#TOC-AES-support\n    if (err.name !== 'NotSupportedError' &&\n      !(key.length === 24 && err.name === 'OperationError')) {\n      throw err;\n    }\n    util.printDebugError('Browser did not support operation: ' + err.message);\n    return nobleAesKW(key).decrypt(wrappedData);\n  }\n\n  try {\n    const unwrapped = await webCrypto.unwrapKey('raw', wrappedData, wrappingKey, { name: 'AES-KW' }, { name: 'HMAC', hash: 'SHA-256' }, true, ['sign']);\n    return new Uint8Array(await webCrypto.exportKey('raw', unwrapped));\n  } catch (err) {\n    if (err.name === 'OperationError') {\n      throw new Error('Key Data Integrity failed');\n    }\n    throw err;\n  }\n}\n","/**\n * @fileoverview This module implements HKDF using either the WebCrypto API or Node.js' crypto API.\n * @module crypto/hkdf\n */\n\nimport enums from '../enums';\nimport util from '../util';\n\nexport default async function computeHKDF(hashAlgo, inputKey, salt, info, outLen) {\n  const webCrypto = util.getWebCrypto();\n  const hash = enums.read(enums.webHash, hashAlgo);\n  if (!hash) throw new Error('Hash algo not supported with HKDF');\n\n  const importedKey = await webCrypto.importKey('raw', inputKey, 'HKDF', false, ['deriveBits']);\n  const bits = await webCrypto.deriveBits({ name: 'HKDF', hash, salt, info }, importedKey, outLen * 8);\n  return new Uint8Array(bits);\n}\n","/**\n * @fileoverview Key encryption and decryption for RFC 6637 ECDH\n * @module crypto/public_key/elliptic/ecdh\n */\n\nimport * as aesKW from '../../aes_kw';\n\nimport enums from '../../../enums';\nimport util from '../../../util';\nimport computeHKDF from '../../hkdf';\nimport { getCipherParams } from '../../cipher';\nimport { b64ToUint8Array, uint8ArrayToB64 } from '../../../encoding/base64';\n\nconst HKDF_INFO = {\n  x25519: util.encodeUTF8('OpenPGP X25519'),\n  x448: util.encodeUTF8('OpenPGP X448')\n};\n\n/**\n * Generate ECDH key for Montgomery curves\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @returns {Promise<{ A: Uint8Array, k: Uint8Array }>}\n */\nexport async function generate(algo) {\n  switch (algo) {\n    case enums.publicKey.x25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const webCryptoKey = await webCrypto.generateKey('X25519', true, ['deriveKey', 'deriveBits'])\n          .catch(err => {\n            if (err.name === 'OperationError') { // Temporary (hopefully) fix for WebKit on Linux\n              const newErr = new Error('Unexpected key generation issue');\n              newErr.name = 'NotSupportedError';\n              throw newErr;\n            }\n            throw err;\n          });\n\n        const privateKey = await webCrypto.exportKey('jwk', webCryptoKey.privateKey);\n        const publicKey = await webCrypto.exportKey('jwk', webCryptoKey.publicKey);\n\n        if (privateKey.x !== publicKey.x) { // Weird issue with Webkit on Linux: https://bugs.webkit.org/show_bug.cgi?id=289693\n          const err = new Error('Unexpected mismatching public point');\n          err.name = 'NotSupportedError';\n          throw err;\n        }\n\n        return {\n          A: new Uint8Array(b64ToUint8Array(publicKey.x)),\n          k: b64ToUint8Array(privateKey.d)\n        };\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: x25519 } = await import('@openpgp/tweetnacl');\n        // k stays in little-endian, unlike legacy ECDH over curve25519\n        const { secretKey: k, publicKey: A } = x25519.box.keyPair();\n        return { A, k };\n      }\n\n    case enums.publicKey.x448: {\n      const x448 = await util.getNobleCurve(enums.publicKey.x448);\n      const { secretKey: k, publicKey: A } = x448.keygen();\n      return { A, k };\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\n/**\n* Validate ECDH parameters\n* @param {module:enums.publicKey} algo - Algorithm identifier\n* @param {Uint8Array} A - ECDH public point\n* @param {Uint8Array} k - ECDH secret scalar\n* @returns {Promise<Boolean>} Whether params are valid.\n* @async\n*/\nexport async function validateParams(algo, A, k) {\n  switch (algo) {\n    case enums.publicKey.x25519:\n      // Validation is typically not run for ECDH, since encryption subkeys are only validated\n      // for gnu-dummy keys.\n      // So, for simplicity, we do an encrypt-decrypt round even if WebCrypto support is not available\n      try {\n        const { ephemeralPublicKey, sharedSecret } = await generateEphemeralEncryptionMaterial(algo, A);\n        const recomputedSharedSecret = await recomputeSharedSecret(algo, ephemeralPublicKey, A, k);\n\n        return util.equalsUint8Array(sharedSecret, recomputedSharedSecret);\n      } catch (_) {\n        return false;\n      }\n\n    case enums.publicKey.x448: {\n      const x448 = await util.getNobleCurve(enums.publicKey.x448);\n      /**\n       * Derive public point A' from private key\n       * and expect A == A'\n       */\n      const publicKey = x448.getPublicKey(k);\n      return util.equalsUint8Array(A, publicKey);\n    }\n\n    default:\n      return false;\n  }\n}\n\n/**\n * Wrap and encrypt a session key\n *\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @param {Uint8Array} data - session key data to be encrypted\n * @param {Uint8Array} recipientA - Recipient public key (K_B)\n * @returns {Promise<{\n *  ephemeralPublicKey: Uint8Array,\n * wrappedKey: Uint8Array\n * }>} ephemeral public key (K_A) and encrypted key\n * @async\n */\nexport async function encrypt(algo, data, recipientA) {\n  const { ephemeralPublicKey, sharedSecret } = await generateEphemeralEncryptionMaterial(algo, recipientA);\n  const hkdfInput = util.concatUint8Array([\n    ephemeralPublicKey,\n    recipientA,\n    sharedSecret\n  ]);\n  switch (algo) {\n    case enums.publicKey.x25519: {\n      const cipherAlgo = enums.symmetric.aes128;\n      const { keySize } = getCipherParams(cipherAlgo);\n      const encryptionKey = await computeHKDF(enums.hash.sha256, hkdfInput, new Uint8Array(), HKDF_INFO.x25519, keySize);\n      const wrappedKey = await aesKW.wrap(cipherAlgo, encryptionKey, data);\n      return { ephemeralPublicKey, wrappedKey };\n    }\n    case enums.publicKey.x448: {\n      const cipherAlgo = enums.symmetric.aes256;\n      const { keySize } = getCipherParams(enums.symmetric.aes256);\n      const encryptionKey = await computeHKDF(enums.hash.sha512, hkdfInput, new Uint8Array(), HKDF_INFO.x448, keySize);\n      const wrappedKey = await aesKW.wrap(cipherAlgo, encryptionKey, data);\n      return { ephemeralPublicKey, wrappedKey };\n    }\n\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\n/**\n * Decrypt and unwrap the session key\n *\n * @param {module:enums.publicKey} algo - Algorithm identifier\n * @param {Uint8Array} ephemeralPublicKey - (K_A)\n * @param {Uint8Array} wrappedKey,\n * @param {Uint8Array} A - Recipient public key (K_b), needed for KDF\n * @param {Uint8Array} k - Recipient secret key (b)\n * @returns {Promise<Uint8Array>} decrypted session key data\n * @async\n */\nexport async function decrypt(algo, ephemeralPublicKey, wrappedKey, A, k) {\n  const sharedSecret = await recomputeSharedSecret(algo, ephemeralPublicKey, A, k);\n  const hkdfInput = util.concatUint8Array([\n    ephemeralPublicKey,\n    A,\n    sharedSecret\n  ]);\n  switch (algo) {\n    case enums.publicKey.x25519: {\n      const cipherAlgo = enums.symmetric.aes128;\n      const { keySize } = getCipherParams(cipherAlgo);\n      const encryptionKey = await computeHKDF(enums.hash.sha256, hkdfInput, new Uint8Array(), HKDF_INFO.x25519, keySize);\n      return aesKW.unwrap(cipherAlgo, encryptionKey, wrappedKey);\n    }\n    case enums.publicKey.x448: {\n      const cipherAlgo = enums.symmetric.aes256;\n      const { keySize } = getCipherParams(enums.symmetric.aes256);\n      const encryptionKey = await computeHKDF(enums.hash.sha512, hkdfInput, new Uint8Array(), HKDF_INFO.x448, keySize);\n      return aesKW.unwrap(cipherAlgo, encryptionKey, wrappedKey);\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\nexport function getPayloadSize(algo) {\n  switch (algo) {\n    case enums.publicKey.x25519:\n      return 32;\n\n    case enums.publicKey.x448:\n      return 56;\n\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\n/**\n * Generate shared secret and ephemeral public key for encryption\n * @returns {Promise<{ ephemeralPublicKey: Uint8Array, sharedSecret: Uint8Array }>} ephemeral public key (K_A) and shared secret\n * @async\n */\nexport async function generateEphemeralEncryptionMaterial(algo, recipientA) {\n  switch (algo) {\n    case enums.publicKey.x25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const ephemeralKeyPair = await webCrypto.generateKey('X25519', true, ['deriveKey', 'deriveBits'])\n          .catch(err => {\n            if (err.name === 'OperationError') { // Temporary (hopefully) fix for WebKit on Linux\n              const newErr = new Error('Unexpected key generation issue');\n              newErr.name = 'NotSupportedError';\n              throw newErr;\n            }\n            throw err;\n          });\n        const ephemeralPublicKeyJwt = await webCrypto.exportKey('jwk', ephemeralKeyPair.publicKey);\n        const ephemeralPrivateKeyJwt = await webCrypto.exportKey('jwk', ephemeralKeyPair.privateKey);\n        if (ephemeralPrivateKeyJwt.x !== ephemeralPublicKeyJwt.x) { // Weird issue with Webkit on Linux: https://bugs.webkit.org/show_bug.cgi?id=289693\n          const err = new Error('Unexpected mismatching public point');\n          err.name = 'NotSupportedError';\n          throw err;\n        }\n        const jwk = publicKeyToJWK(algo, recipientA);\n        const recipientPublicKey = await webCrypto.importKey('jwk', jwk, 'X25519', false, []);\n        const sharedSecretBuffer = await webCrypto.deriveBits(\n          { name: 'X25519', public: recipientPublicKey },\n          ephemeralKeyPair.privateKey,\n          getPayloadSize(algo) * 8 // in bits\n        );\n        return {\n          sharedSecret: new Uint8Array(sharedSecretBuffer),\n          ephemeralPublicKey: new Uint8Array(b64ToUint8Array(ephemeralPublicKeyJwt.x))\n        };\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: x25519 } = await import('@openpgp/tweetnacl');\n        const { secretKey: ephemeralSecretKey, publicKey: ephemeralPublicKey } = x25519.box.keyPair();\n        const sharedSecret = x25519.scalarMult(ephemeralSecretKey, recipientA);\n        assertNonZeroArray(sharedSecret);\n        return { ephemeralPublicKey, sharedSecret };\n      }\n    case enums.publicKey.x448: {\n      const x448 = await util.getNobleCurve(enums.publicKey.x448);\n      const { secretKey: ephemeralSecretKey, publicKey: ephemeralPublicKey } = x448.keygen();\n      const sharedSecret = x448.getSharedSecret(ephemeralSecretKey, recipientA);\n      assertNonZeroArray(sharedSecret);\n      return { ephemeralPublicKey, sharedSecret };\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\nexport async function recomputeSharedSecret(algo, ephemeralPublicKey, A, k) {\n  switch (algo) {\n    case enums.publicKey.x25519:\n      try {\n        const webCrypto = util.getWebCrypto();\n        const privateKeyJWK = privateKeyToJWK(algo, A, k);\n        const ephemeralPublicKeyJWK = publicKeyToJWK(algo, ephemeralPublicKey);\n        const privateKey = await webCrypto.importKey('jwk', privateKeyJWK, 'X25519', false, ['deriveKey', 'deriveBits']);\n        const ephemeralPublicKeyReference = await webCrypto.importKey('jwk', ephemeralPublicKeyJWK, 'X25519', false, []);\n        const sharedSecretBuffer = await webCrypto.deriveBits(\n          { name: 'X25519', public: ephemeralPublicKeyReference },\n          privateKey,\n          getPayloadSize(algo) * 8 // in bits\n        );\n        return new Uint8Array(sharedSecretBuffer);\n      } catch (err) {\n        if (err.name !== 'NotSupportedError') {\n          throw err;\n        }\n        const { default: x25519 } = await import('@openpgp/tweetnacl');\n        const sharedSecret = x25519.scalarMult(k, ephemeralPublicKey);\n        assertNonZeroArray(sharedSecret);\n        return sharedSecret;\n      }\n    case enums.publicKey.x448: {\n      const x448 = await util.getNobleCurve(enums.publicKey.x448);\n      const sharedSecret = x448.getSharedSecret(k, ephemeralPublicKey);\n      assertNonZeroArray(sharedSecret);\n      return sharedSecret;\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\n/**\n * x25519 and x448 produce an all-zero value when given as input a point with small order.\n * This does not lead to a security issue in the context of ECDH, but it is still unexpected,\n * hence we throw.\n * @param {Uint8Array} sharedSecret\n */\nfunction assertNonZeroArray(sharedSecret) {\n  let acc = 0;\n  for (let i = 0; i < sharedSecret.length; i++) {\n    acc |= sharedSecret[i];\n  }\n  if (acc === 0) {\n    throw new Error('Unexpected low order point');\n  }\n}\n\n\nfunction publicKeyToJWK(algo, publicKey) {\n  switch (algo) {\n    case enums.publicKey.x25519: {\n      const jwk = {\n        kty: 'OKP',\n        crv: 'X25519',\n        x: uint8ArrayToB64(publicKey, true),\n        ext: true\n      };\n      return jwk;\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n\nfunction privateKeyToJWK(algo, publicKey, privateKey) {\n  switch (algo) {\n    case enums.publicKey.x25519: {\n      const jwk = publicKeyToJWK(algo, publicKey);\n      jwk.d = uint8ArrayToB64(privateKey, true);\n      return jwk;\n    }\n    default:\n      throw new Error('Unsupported ECDH algorithm');\n  }\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Wrapper of an instance of an Elliptic Curve\n * @module crypto/public_key/elliptic/curve\n */\nimport enums from '../../../enums';\nimport util from '../../../util';\nimport { uint8ArrayToB64, b64ToUint8Array } from '../../../encoding/base64';\nimport OID from '../../../type/oid';\nimport { UnsupportedError } from '../../../packet/packet';\nimport { generate as eddsaGenerate } from './eddsa';\nimport { generate as ecdhXGenerate, validateParams as ecdhXValidateParams } from './ecdh_x';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\n\nconst webCurves = {\n  [enums.curve.nistP256]: 'P-256',\n  [enums.curve.nistP384]: 'P-384',\n  [enums.curve.nistP521]: 'P-521'\n};\nconst knownCurves = nodeCrypto ? nodeCrypto.getCurves() : [];\nconst nodeCurves = nodeCrypto ? {\n  [enums.curve.secp256k1]: knownCurves.includes('secp256k1') ? 'secp256k1' : undefined,\n  [enums.curve.nistP256]: knownCurves.includes('prime256v1') ? 'prime256v1' : undefined,\n  [enums.curve.nistP384]: knownCurves.includes('secp384r1') ? 'secp384r1' : undefined,\n  [enums.curve.nistP521]: knownCurves.includes('secp521r1') ? 'secp521r1' : undefined,\n  [enums.curve.ed25519Legacy]: knownCurves.includes('ED25519') ? 'ED25519' : undefined,\n  [enums.curve.curve25519Legacy]: knownCurves.includes('X25519') ? 'X25519' : undefined,\n  [enums.curve.brainpoolP256r1]: knownCurves.includes('brainpoolP256r1') ? 'brainpoolP256r1' : undefined,\n  [enums.curve.brainpoolP384r1]: knownCurves.includes('brainpoolP384r1') ? 'brainpoolP384r1' : undefined,\n  [enums.curve.brainpoolP512r1]: knownCurves.includes('brainpoolP512r1') ? 'brainpoolP512r1' : undefined\n} : {};\n\nconst curves = {\n  [enums.curve.nistP256]: {\n    oid: [0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha256,\n    cipher: enums.symmetric.aes128,\n    node: nodeCurves[enums.curve.nistP256],\n    web: webCurves[enums.curve.nistP256],\n    payloadSize: 32,\n    sharedSize: 256,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.nistP384]: {\n    oid: [0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha384,\n    cipher: enums.symmetric.aes192,\n    node: nodeCurves[enums.curve.nistP384],\n    web: webCurves[enums.curve.nistP384],\n    payloadSize: 48,\n    sharedSize: 384,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.nistP521]: {\n    oid: [0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha512,\n    cipher: enums.symmetric.aes256,\n    node: nodeCurves[enums.curve.nistP521],\n    web: webCurves[enums.curve.nistP521],\n    payloadSize: 66,\n    sharedSize: 528,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.secp256k1]: {\n    oid: [0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x0A],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha256,\n    cipher: enums.symmetric.aes128,\n    node: nodeCurves[enums.curve.secp256k1],\n    payloadSize: 32,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.ed25519Legacy]: {\n    oid: [0x06, 0x09, 0x2B, 0x06, 0x01, 0x04, 0x01, 0xDA, 0x47, 0x0F, 0x01],\n    keyType: enums.publicKey.eddsaLegacy,\n    hash: enums.hash.sha512,\n    node: false, // nodeCurves.ed25519 TODO\n    payloadSize: 32,\n    wireFormatLeadingByte: 0x40\n  },\n  [enums.curve.curve25519Legacy]: {\n    oid: [0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x97, 0x55, 0x01, 0x05, 0x01],\n    keyType: enums.publicKey.ecdh,\n    hash: enums.hash.sha256,\n    cipher: enums.symmetric.aes128,\n    node: false, // nodeCurves.curve25519 TODO\n    payloadSize: 32,\n    wireFormatLeadingByte: 0x40\n  },\n  [enums.curve.brainpoolP256r1]: {\n    oid: [0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha256,\n    cipher: enums.symmetric.aes128,\n    node: nodeCurves[enums.curve.brainpoolP256r1],\n    payloadSize: 32,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.brainpoolP384r1]: {\n    oid: [0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha384,\n    cipher: enums.symmetric.aes192,\n    node: nodeCurves[enums.curve.brainpoolP384r1],\n    payloadSize: 48,\n    wireFormatLeadingByte: 0x04\n  },\n  [enums.curve.brainpoolP512r1]: {\n    oid: [0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D],\n    keyType: enums.publicKey.ecdsa,\n    hash: enums.hash.sha512,\n    cipher: enums.symmetric.aes256,\n    node: nodeCurves[enums.curve.brainpoolP512r1],\n    payloadSize: 64,\n    wireFormatLeadingByte: 0x04\n  }\n};\n\nclass CurveWithOID {\n  constructor(oidOrName) {\n    try {\n      this.name = oidOrName instanceof OID ?\n        oidOrName.getName() :\n        enums.write(enums.curve,oidOrName);\n    } catch (err) {\n      throw new UnsupportedError('Unknown curve');\n    }\n    const params = curves[this.name];\n\n    this.keyType = params.keyType;\n\n    this.oid = params.oid;\n    this.hash = params.hash;\n    this.cipher = params.cipher;\n    this.node = params.node;\n    this.web = params.web;\n    this.payloadSize = params.payloadSize;\n    this.sharedSize = params.sharedSize;\n    this.wireFormatLeadingByte = params.wireFormatLeadingByte;\n    if (this.web && util.getWebCrypto()) {\n      this.type = 'web';\n    } else if (this.node && util.getNodeCrypto()) {\n      this.type = 'node';\n    } else if (this.name === enums.curve.curve25519Legacy) {\n      this.type = 'curve25519Legacy';\n    } else if (this.name === enums.curve.ed25519Legacy) {\n      this.type = 'ed25519Legacy';\n    }\n  }\n\n  async genKeyPair() {\n    switch (this.type) {\n      case 'web':\n        try {\n          return await webGenKeyPair(this.name, this.wireFormatLeadingByte);\n        } catch (err) {\n          util.printDebugError('Browser did not support generating ec key ' + err.message);\n          return jsGenKeyPair(this.name);\n        }\n      case 'node':\n        return nodeGenKeyPair(this.name);\n      case 'curve25519Legacy': {\n        // the private key must be stored in big endian and already clamped: https://www.ietf.org/archive/id/draft-ietf-openpgp-crypto-refresh-13.html#section-5.5.5.6.1.1-3\n        const { k, A } = await ecdhXGenerate(enums.publicKey.x25519);\n        const privateKey = k.slice().reverse();\n        privateKey[0] = (privateKey[0] & 127) | 64;\n        privateKey[31] &= 248;\n        const publicKey = util.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]), A]);\n        return { publicKey, privateKey };\n      }\n      case 'ed25519Legacy': {\n        const { seed: privateKey, A } = await eddsaGenerate(enums.publicKey.ed25519);\n        const publicKey = util.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]), A]);\n        return { publicKey, privateKey };\n      }\n      default:\n        return jsGenKeyPair(this.name);\n    }\n  }\n}\n\nasync function generate(curveName) {\n  const curve = new CurveWithOID(curveName);\n  const { oid, hash, cipher } = curve;\n  const keyPair = await curve.genKeyPair();\n  return {\n    oid,\n    Q: keyPair.publicKey,\n    secret: util.leftPad(keyPair.privateKey, curve.payloadSize),\n    hash,\n    cipher\n  };\n}\n\n/**\n * Get preferred hash algo to use with the given curve\n * @param {module:type/oid} oid - curve oid\n * @returns {enums.hash} hash algorithm\n */\nfunction getPreferredHashAlgo(oid) {\n  return curves[oid.getName()].hash;\n}\n\n/**\n * Validate ECDH and ECDSA parameters\n * Not suitable for EdDSA (different secret key format)\n * @param {module:enums.publicKey} algo - EC algorithm, to filter supported curves\n * @param {module:type/oid} oid - EC object identifier\n * @param {Uint8Array} Q - EC public point\n * @param {Uint8Array} d - EC secret scalar\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nasync function validateStandardParams(algo, oid, Q, d) {\n  const supportedCurves = {\n    [enums.curve.nistP256]: true,\n    [enums.curve.nistP384]: true,\n    [enums.curve.nistP521]: true,\n    [enums.curve.secp256k1]: true,\n    [enums.curve.curve25519Legacy]: algo === enums.publicKey.ecdh,\n    [enums.curve.brainpoolP256r1]: true,\n    [enums.curve.brainpoolP384r1]: true,\n    [enums.curve.brainpoolP512r1]: true\n  };\n\n  // Check whether the given curve is supported\n  const curveName = oid.getName();\n  if (!supportedCurves[curveName]) {\n    return false;\n  }\n\n  if (curveName === enums.curve.curve25519Legacy) {\n    const dLittleEndian = d.slice().reverse();\n    // First byte is relevant for encoding purposes only\n    if (Q.length < 1 || Q[0] !== 0x40) {\n      return false;\n    }\n    return ecdhXValidateParams(enums.publicKey.x25519, Q.subarray(1), dLittleEndian);\n  }\n\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdsa, curveName); // excluding curve25519Legacy, ecdh and ecdsa use the same curves\n  /*\n   * Re-derive public point Q' = dG from private key\n   * Expect Q == Q'\n   */\n  const dG = nobleCurve.getPublicKey(d, false);\n  if (!util.equalsUint8Array(dG, Q)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Check whether the public point has a valid encoding.\n * NB: this function does not check e.g. whether the point belongs to the curve.\n */\nfunction checkPublicPointEnconding(curve, V) {\n  const { payloadSize, wireFormatLeadingByte, name: curveName } = curve;\n\n  const pointSize = (curveName === enums.curve.curve25519Legacy || curveName === enums.curve.ed25519Legacy) ? payloadSize : payloadSize * 2;\n\n  if (V[0] !== wireFormatLeadingByte || V.length !== pointSize + 1) {\n    throw new Error('Invalid point encoding');\n  }\n}\n\nexport {\n  CurveWithOID, curves, webCurves, nodeCurves, generate, getPreferredHashAlgo, jwkToRawPublic, rawPublicToJWK, privateToJWK, validateStandardParams, checkPublicPointEnconding\n};\n\n//////////////////////////\n//                      //\n//   Helper functions   //\n//                      //\n//////////////////////////\nasync function jsGenKeyPair(name) {\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdsa, name); // excluding curve25519Legacy, ecdh and ecdsa use the same curves\n  const { secretKey: privateKey } = nobleCurve.keygen();\n  const publicKey = nobleCurve.getPublicKey(privateKey, false);\n  return { publicKey, privateKey };\n}\n\nasync function webGenKeyPair(name, wireFormatLeadingByte) {\n  // Note: keys generated with ECDSA and ECDH are structurally equivalent\n  const webCryptoKey = await webCrypto.generateKey({ name: 'ECDSA', namedCurve: webCurves[name] }, true, ['sign', 'verify']);\n\n  const privateKey = await webCrypto.exportKey('jwk', webCryptoKey.privateKey);\n  const publicKey = await webCrypto.exportKey('jwk', webCryptoKey.publicKey);\n\n  return {\n    publicKey: jwkToRawPublic(publicKey, wireFormatLeadingByte),\n    privateKey: b64ToUint8Array(privateKey.d, true)\n  };\n}\n\nasync function nodeGenKeyPair(name) {\n  // Note: ECDSA and ECDH key generation is structurally equivalent\n  const ecdh = nodeCrypto.createECDH(nodeCurves[name]);\n  await ecdh.generateKeys();\n  return {\n    publicKey: new Uint8Array(ecdh.getPublicKey()),\n    privateKey: new Uint8Array(ecdh.getPrivateKey())\n  };\n}\n\n//////////////////////////\n//                      //\n//   Helper functions   //\n//                      //\n//////////////////////////\n\n/**\n * @param {JsonWebKey} jwk - key for conversion\n *\n * @returns {Uint8Array} Raw public key.\n */\nfunction jwkToRawPublic(jwk, wireFormatLeadingByte) {\n  const bufX = b64ToUint8Array(jwk.x);\n  const bufY = b64ToUint8Array(jwk.y);\n  const publicKey = new Uint8Array(bufX.length + bufY.length + 1);\n  publicKey[0] = wireFormatLeadingByte;\n  publicKey.set(bufX, 1);\n  publicKey.set(bufY, bufX.length + 1);\n  return publicKey;\n}\n\n/**\n * @param {Integer} payloadSize - ec payload size\n * @param {String} name - curve name\n * @param {Uint8Array} publicKey - public key\n *\n * @returns {JsonWebKey} Public key in jwk format.\n */\nfunction rawPublicToJWK(payloadSize, name, publicKey) {\n  const len = payloadSize;\n  const bufX = publicKey.slice(1, len + 1);\n  const bufY = publicKey.slice(len + 1, len * 2 + 1);\n  // https://www.rfc-editor.org/rfc/rfc7518.txt\n  const jwk = {\n    kty: 'EC',\n    crv: name,\n    x: uint8ArrayToB64(bufX, true),\n    y: uint8ArrayToB64(bufY, true),\n    ext: true\n  };\n  return jwk;\n}\n\n/**\n * @param {Integer} payloadSize - ec payload size\n * @param {String} name - curve name\n * @param {Uint8Array} publicKey - public key\n * @param {Uint8Array} privateKey - private key\n *\n * @returns {JsonWebKey} Private key in jwk format.\n */\nfunction privateToJWK(payloadSize, name, publicKey, privateKey) {\n  const jwk = rawPublicToJWK(payloadSize, name, publicKey);\n  jwk.d = uint8ArrayToB64(privateKey, true);\n  return jwk;\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Implementation of ECDSA following RFC6637 for Openpgpjs\n * @module crypto/public_key/elliptic/ecdsa\n */\n\nimport enums from '../../../enums';\nimport util from '../../../util';\nimport { getRandomBytes } from '../../random';\nimport { computeDigest } from '../../hash';\nimport { CurveWithOID, webCurves, privateToJWK, rawPublicToJWK, validateStandardParams, nodeCurves, checkPublicPointEnconding } from './oid_curves';\nimport { bigIntToUint8Array } from '../../biginteger';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\n\n/**\n * Sign a message using the provided key\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used to sign\n * @param {Uint8Array} message - Message to sign\n * @param {Uint8Array} publicKey - Public key\n * @param {Uint8Array} privateKey - Private key used to sign the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Promise<{\n *   r: Uint8Array,\n *   s: Uint8Array\n * }>} Signature of the message\n * @async\n */\nexport async function sign(oid, hashAlgo, message, publicKey, privateKey, hashed) {\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, publicKey);\n  if (message && !util.isStream(message)) {\n    const keyPair = { publicKey, privateKey };\n    switch (curve.type) {\n      case 'web':\n        // If browser doesn't support a curve, we'll catch it\n        try {\n          // Need to await to make sure browser succeeds\n          return await webSign(curve, hashAlgo, message, keyPair);\n        } catch (err) {\n          // We do not fallback if the error is related to key integrity\n          // Unfortunaley Safari does not support nistP521 and throws a DataError when using it\n          // So we need to always fallback for that curve\n          if (curve.name !== 'nistP521' && (err.name === 'DataError' || err.name === 'OperationError')) {\n            throw err;\n          }\n          util.printDebugError('Browser did not support signing: ' + err.message);\n        }\n        break;\n      case 'node':\n        return nodeSign(curve, hashAlgo, message, privateKey);\n    }\n  }\n\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdsa, curve.name);\n  // lowS: non-canonical sig: https://stackoverflow.com/questions/74338846/ecdsa-signature-verification-mismatch\n  const signature = nobleCurve.sign(hashed, privateKey, { lowS: false });\n  return {\n    r: bigIntToUint8Array(signature.r, 'be', curve.payloadSize),\n    s: bigIntToUint8Array(signature.s, 'be', curve.payloadSize)\n  };\n}\n\n/**\n * Verifies if a signature is valid for a message\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used in the signature\n * @param  {{r: Uint8Array,\n             s: Uint8Array}}   signature Signature to verify\n * @param {Uint8Array} message - Message to verify\n * @param {Uint8Array} publicKey - Public key used to verify the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Boolean}\n * @async\n */\nexport async function verify(oid, hashAlgo, signature, message, publicKey, hashed) {\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, publicKey);\n  // See https://github.com/openpgpjs/openpgpjs/pull/948.\n  // NB: the impact was more likely limited to Brainpool curves, since thanks\n  // to WebCrypto availability, NIST curve should not have been affected.\n  // Similarly, secp256k1 should have been used rarely enough.\n  // However, we implement the fix for all curves, since it's only needed in case of\n  // verification failure, which is unexpected, hence a minor slowdown is acceptable.\n  const tryFallbackVerificationForOldBug = async () => (\n    hashed[0] === 0 ?\n      jsVerify(curve, signature, hashed.subarray(1), publicKey) :\n      false\n  );\n\n  if (message && !util.isStream(message)) {\n    switch (curve.type) {\n      case 'web':\n        try {\n          // Need to await to make sure browser succeeds\n          const verified = await webVerify(curve, hashAlgo, signature, message, publicKey);\n          return verified || tryFallbackVerificationForOldBug();\n        } catch (err) {\n          // We do not fallback if the error is related to key integrity\n          // Unfortunately Safari does not support nistP521 and throws a DataError when using it\n          // So we need to always fallback for that curve\n          if (curve.name !== 'nistP521' && (err.name === 'DataError' || err.name === 'OperationError')) {\n            throw err;\n          }\n          util.printDebugError('Browser did not support verifying: ' + err.message);\n        }\n        break;\n      case 'node': {\n        const verified = await nodeVerify(curve, hashAlgo, signature, message, publicKey);\n        return verified || tryFallbackVerificationForOldBug();\n      }\n    }\n  }\n\n  const verified = await jsVerify(curve, signature, hashed, publicKey);\n  return verified || tryFallbackVerificationForOldBug();\n}\n\n/**\n * Validate ECDSA parameters\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {Uint8Array} Q - ECDSA public point\n * @param {Uint8Array} d - ECDSA secret scalar\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(oid, Q, d) {\n  const curve = new CurveWithOID(oid);\n  // Reject curves x25519 and ed25519\n  if (curve.keyType !== enums.publicKey.ecdsa) {\n    return false;\n  }\n\n  // To speed up the validation, we try to use node- or webcrypto when available\n  // and sign + verify a random message\n  switch (curve.type) {\n    case 'web':\n    case 'node': {\n      const message = getRandomBytes(8);\n      const hashAlgo = enums.hash.sha256;\n      const hashed = await computeDigest(hashAlgo, message);\n      try {\n        const signature = await sign(oid, hashAlgo, message, Q, d, hashed);\n        // eslint-disable-next-line @typescript-eslint/return-await\n        return await verify(oid, hashAlgo, signature, message, Q, hashed);\n      } catch (err) {\n        return false;\n      }\n    }\n    default:\n      return validateStandardParams(enums.publicKey.ecdsa, oid, Q, d);\n  }\n}\n\n\n//////////////////////////\n//                      //\n//   Helper functions   //\n//                      //\n//////////////////////////\n\n/**\n * Fallback javascript implementation of ECDSA verification.\n * To be used if no native implementation is available for the given curve/operation.\n */\nasync function jsVerify(curve, signature, hashed, publicKey) {\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdsa, curve.name);\n  // lowS: non-canonical sig: https://stackoverflow.com/questions/74338846/ecdsa-signature-verification-mismatch\n  return nobleCurve.verify(util.concatUint8Array([signature.r, signature.s]), hashed, publicKey, { lowS: false });\n}\n\nasync function webSign(curve, hashAlgo, message, keyPair) {\n  const len = curve.payloadSize;\n  const jwk = privateToJWK(curve.payloadSize, webCurves[curve.name], keyPair.publicKey, keyPair.privateKey);\n  const key = await webCrypto.importKey(\n    'jwk',\n    jwk,\n    {\n      'name': 'ECDSA',\n      'namedCurve': webCurves[curve.name],\n      'hash': { name: enums.read(enums.webHash, curve.hash) }\n    },\n    false,\n    ['sign']\n  );\n\n  const signature = new Uint8Array(await webCrypto.sign(\n    {\n      'name': 'ECDSA',\n      'namedCurve': webCurves[curve.name],\n      'hash': { name: enums.read(enums.webHash, hashAlgo) }\n    },\n    key,\n    message\n  ));\n\n  return {\n    r: signature.slice(0, len),\n    s: signature.slice(len, len << 1)\n  };\n}\n\nasync function webVerify(curve, hashAlgo, { r, s }, message, publicKey) {\n  const jwk = rawPublicToJWK(curve.payloadSize, webCurves[curve.name], publicKey);\n  const key = await webCrypto.importKey(\n    'jwk',\n    jwk,\n    {\n      'name': 'ECDSA',\n      'namedCurve': webCurves[curve.name],\n      'hash': { name: enums.read(enums.webHash, curve.hash) }\n    },\n    false,\n    ['verify']\n  );\n\n  const signature = util.concatUint8Array([r, s]).buffer;\n\n  return webCrypto.verify(\n    {\n      'name': 'ECDSA',\n      'namedCurve': webCurves[curve.name],\n      'hash': { name: enums.read(enums.webHash, hashAlgo) }\n    },\n    key,\n    signature,\n    message\n  );\n}\n\nasync function nodeSign(curve, hashAlgo, message, privateKey) {\n  // JWT encoding cannot be used for now, as Brainpool curves are not supported\n  const ecKeyUtils = util.nodeRequire('eckey-utils');\n  const nodeBuffer = util.getNodeBuffer();\n  const { privateKey: derPrivateKey } = ecKeyUtils.generateDer({\n    curveName: nodeCurves[curve.name],\n    privateKey: nodeBuffer.from(privateKey)\n  });\n\n  const sign = nodeCrypto.createSign(enums.read(enums.hash, hashAlgo));\n  sign.write(message);\n  sign.end();\n\n  const signature = new Uint8Array(sign.sign({ key: derPrivateKey, format: 'der', type: 'sec1', dsaEncoding: 'ieee-p1363' }));\n  const len = curve.payloadSize;\n\n  return {\n    r: signature.subarray(0, len),\n    s: signature.subarray(len, len << 1)\n  };\n}\n\nasync function nodeVerify(curve, hashAlgo, { r, s }, message, publicKey) {\n  const ecKeyUtils = util.nodeRequire('eckey-utils');\n  const nodeBuffer = util.getNodeBuffer();\n  const { publicKey: derPublicKey } = ecKeyUtils.generateDer({\n    curveName: nodeCurves[curve.name],\n    publicKey: nodeBuffer.from(publicKey)\n  });\n\n  const verify = nodeCrypto.createVerify(enums.read(enums.hash, hashAlgo));\n  verify.write(message);\n  verify.end();\n\n  const signature = util.concatUint8Array([r, s]);\n\n  try {\n    return verify.verify({ key: derPublicKey, format: 'der', type: 'spki', dsaEncoding: 'ieee-p1363' }, signature);\n  } catch (err) {\n    return false;\n  }\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2018 Proton Technologies AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Implementation of legacy EdDSA following RFC4880bis-03 for OpenPGP.\n * This key type has been deprecated by the crypto-refresh RFC.\n * @module crypto/public_key/elliptic/eddsa_legacy\n */\n\nimport util from '../../../util';\nimport enums from '../../../enums';\nimport { getHashByteLength } from '../../hash';\nimport { CurveWithOID, checkPublicPointEnconding } from './oid_curves';\nimport { sign as eddsaSign, verify as eddsaVerify, validateParams as eddsaValidateParams } from './eddsa';\n\n/**\n * Sign a message using the provided legacy EdDSA key\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used to sign (must be sha256 or stronger)\n * @param {Uint8Array} message - Message to sign\n * @param {Uint8Array} publicKey - Public key\n * @param {Uint8Array} privateKey - Private key used to sign the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Promise<{\n *   r: Uint8Array,\n *   s: Uint8Array\n * }>} Signature of the message\n * @async\n */\nexport async function sign(oid, hashAlgo, message, publicKey, privateKey, hashed) {\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, publicKey);\n  if (getHashByteLength(hashAlgo) < getHashByteLength(enums.hash.sha256)) {\n    // Enforce digest sizes, since the constraint was already present in RFC4880bis:\n    // see https://tools.ietf.org/id/draft-ietf-openpgp-rfc4880bis-10.html#section-15-7.2\n    // and https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.3-3\n    throw new Error('Hash algorithm too weak for EdDSA.');\n  }\n  const { RS: signature } = await eddsaSign(enums.publicKey.ed25519, hashAlgo, message, publicKey.subarray(1), privateKey, hashed);\n  // EdDSA signature params are returned in little-endian format\n  return {\n    r: signature.subarray(0, 32),\n    s: signature.subarray(32)\n  };\n}\n\n/**\n * Verifies if a legacy EdDSA signature is valid for a message\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:enums.hash} hashAlgo - Hash algorithm used in the signature\n * @param  {{r: Uint8Array,\n             s: Uint8Array}}   signature Signature to verify the message\n * @param {Uint8Array} m - Message to verify\n * @param {Uint8Array} publicKey - Public key used to verify the message\n * @param {Uint8Array} hashed - The hashed message\n * @returns {Boolean}\n * @async\n */\nexport async function verify(oid, hashAlgo, { r, s }, m, publicKey, hashed) {\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, publicKey);\n  if (getHashByteLength(hashAlgo) < getHashByteLength(enums.hash.sha256)) {\n    // Enforce digest sizes, since the constraint was already present in RFC4880bis:\n    // see https://tools.ietf.org/id/draft-ietf-openpgp-rfc4880bis-10.html#section-15-7.2\n    // and https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.3-3\n    throw new Error('Hash algorithm too weak for EdDSA.');\n  }\n  const RS = util.concatUint8Array([r, s]);\n  return eddsaVerify(enums.publicKey.ed25519, hashAlgo, { RS }, m, publicKey.subarray(1), hashed);\n}\n/**\n * Validate legacy EdDSA parameters\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {Uint8Array} Q - EdDSA public point\n * @param {Uint8Array} k - EdDSA secret seed\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(oid, Q, k) {\n  // Check whether the given curve is supported\n  if (oid.getName() !== enums.curve.ed25519Legacy) {\n    return false;\n  }\n\n  // First byte is relevant for encoding purposes only\n  if (Q.length < 1 || Q[0] !== 0x40) {\n    return false;\n  }\n  return eddsaValidateParams(enums.publicKey.ed25519, Q.subarray(1), k);\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport util from '../util';\n\n/**\n * @fileoverview Functions to add and remove PKCS5 padding\n * @see PublicKeyEncryptedSessionKeyPacket\n * @module crypto/pkcs5\n * @private\n */\n\n/**\n * Add pkcs5 padding to a message\n * @param {Uint8Array} message - message to pad\n * @returns {Uint8Array} Padded message.\n */\nexport function encode(message) {\n  const c = 8 - (message.length % 8);\n  const padded = new Uint8Array(message.length + c).fill(c);\n  padded.set(message);\n  return padded;\n}\n\n/**\n * Remove pkcs5 padding from a message\n * @param {Uint8Array} message - message to remove padding from\n * @returns {Uint8Array} Message without padding.\n */\nexport function decode(message) {\n  const len = message.length;\n  if (len > 0) {\n    const c = message[len - 1];\n    if (c >= 1) {\n      const provided = message.subarray(len - c);\n      const computed = new Uint8Array(c).fill(c);\n      if (util.equalsUint8Array(provided, computed)) {\n        return message.subarray(0, len - c);\n      }\n    }\n  }\n  throw new Error('Invalid padding');\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview Key encryption and decryption for RFC 6637 ECDH\n * @module crypto/public_key/elliptic/ecdh\n */\n\nimport { CurveWithOID, jwkToRawPublic, rawPublicToJWK, privateToJWK, validateStandardParams, checkPublicPointEnconding } from './oid_curves';\nimport * as aesKW from '../../aes_kw';\nimport { computeDigest } from '../../hash';\nimport enums from '../../../enums';\nimport util from '../../../util';\nimport { b64ToUint8Array } from '../../../encoding/base64';\nimport * as pkcs5 from '../../pkcs5';\nimport { getCipherParams } from '../../cipher';\nimport { generateEphemeralEncryptionMaterial as ecdhXGenerateEphemeralEncryptionMaterial, recomputeSharedSecret as ecdhXRecomputeSharedSecret } from './ecdh_x';\n\n/**\n * Validate ECDH parameters\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {Uint8Array} Q - ECDH public point\n * @param {Uint8Array} d - ECDH secret scalar\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(oid, Q, d) {\n  return validateStandardParams(enums.publicKey.ecdh, oid, Q, d);\n}\n\n// Build Param for ECDH algorithm (RFC 6637)\nfunction buildEcdhParam(public_algo, oid, kdfParams, fingerprint) {\n  return util.concatUint8Array([\n    oid.write(),\n    new Uint8Array([public_algo]),\n    kdfParams.write(),\n    util.stringToUint8Array('Anonymous Sender    '),\n    fingerprint\n  ]);\n}\n\n// Key Derivation Function (RFC 6637)\nasync function kdf(hashAlgo, X, length, param, stripLeading = false, stripTrailing = false) {\n  // Note: X is little endian for Curve25519, big-endian for all others.\n  // This is not ideal, but the RFC's are unclear\n  // https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-02#appendix-B\n  let i;\n  if (stripLeading) {\n    // Work around old go crypto bug\n    for (i = 0; i < X.length && X[i] === 0; i++);\n    X = X.subarray(i);\n  }\n  if (stripTrailing) {\n    // Work around old OpenPGP.js bug\n    for (i = X.length - 1; i >= 0 && X[i] === 0; i--);\n    X = X.subarray(0, i + 1);\n  }\n  const digest = await computeDigest(hashAlgo, util.concatUint8Array([\n    new Uint8Array([0, 0, 0, 1]),\n    X,\n    param\n  ]));\n  return digest.subarray(0, length);\n}\n\n/**\n * Generate ECDHE ephemeral key and secret from public key\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} Q - Recipient public key\n * @returns {Promise<{publicKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function genPublicEphemeralKey(curve, Q) {\n  switch (curve.type) {\n    case 'curve25519Legacy': {\n      const { sharedSecret: sharedKey, ephemeralPublicKey } = await ecdhXGenerateEphemeralEncryptionMaterial(enums.publicKey.x25519, Q.subarray(1));\n      const publicKey = util.concatUint8Array([new Uint8Array([curve.wireFormatLeadingByte]), ephemeralPublicKey]);\n      return { publicKey, sharedKey }; // Note: sharedKey is little-endian here, unlike below\n    }\n    case 'web':\n      if (curve.web && util.getWebCrypto()) {\n        try {\n          return await webPublicEphemeralKey(curve, Q);\n        } catch (err) {\n          util.printDebugError(err);\n          return jsPublicEphemeralKey(curve, Q);\n        }\n      }\n      break;\n    case 'node':\n      return nodePublicEphemeralKey(curve, Q);\n    default:\n      return jsPublicEphemeralKey(curve, Q);\n\n  }\n}\n\n/**\n * Encrypt and wrap a session key\n *\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:type/kdf_params} kdfParams - KDF params including cipher and algorithm to use\n * @param {Uint8Array} data - Unpadded session key data\n * @param {Uint8Array} Q - Recipient public key\n * @param {Uint8Array} fingerprint - Recipient fingerprint, already truncated depending on the key version\n * @returns {Promise<{publicKey: Uint8Array, wrappedKey: Uint8Array}>}\n * @async\n */\nexport async function encrypt(oid, kdfParams, data, Q, fingerprint) {\n  const m = pkcs5.encode(data);\n\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, Q);\n  const { publicKey, sharedKey } = await genPublicEphemeralKey(curve, Q);\n  const param = buildEcdhParam(enums.publicKey.ecdh, oid, kdfParams, fingerprint);\n  const { keySize } = getCipherParams(kdfParams.cipher);\n  const Z = await kdf(kdfParams.hash, sharedKey, keySize, param);\n  const wrappedKey = await aesKW.wrap(kdfParams.cipher, Z, m);\n  return { publicKey, wrappedKey };\n}\n\n/**\n * Generate ECDHE secret from private key and public part of ephemeral key\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} V - Public part of ephemeral key\n * @param {Uint8Array} Q - Recipient public key\n * @param {Uint8Array} d - Recipient private key\n * @returns {Promise<{secretKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function genPrivateEphemeralKey(curve, V, Q, d) {\n  if (d.length !== curve.payloadSize) {\n    const privateKey = new Uint8Array(curve.payloadSize);\n    privateKey.set(d, curve.payloadSize - d.length);\n    d = privateKey;\n  }\n  switch (curve.type) {\n    case 'curve25519Legacy': {\n      const secretKey = d.slice().reverse();\n      const sharedKey = await ecdhXRecomputeSharedSecret(enums.publicKey.x25519, V.subarray(1), Q.subarray(1), secretKey);\n      return { secretKey, sharedKey }; // Note: sharedKey is little-endian here, unlike below\n    }\n    case 'web':\n      if (curve.web && util.getWebCrypto()) {\n        try {\n          return await webPrivateEphemeralKey(curve, V, Q, d);\n        } catch (err) {\n          util.printDebugError(err);\n          return jsPrivateEphemeralKey(curve, V, d);\n        }\n      }\n      break;\n    case 'node':\n      return nodePrivateEphemeralKey(curve, V, d);\n    default:\n      return jsPrivateEphemeralKey(curve, V, d);\n  }\n}\n\n/**\n * Decrypt and unwrap the value derived from session key\n *\n * @param {module:type/oid} oid - Elliptic curve object identifier\n * @param {module:type/kdf_params} kdfParams - KDF params including cipher and algorithm to use\n * @param {Uint8Array} V - Public part of ephemeral key\n * @param {Uint8Array} C - Encrypted and wrapped value derived from session key\n * @param {Uint8Array} Q - Recipient public key\n * @param {Uint8Array} d - Recipient private key\n * @param {Uint8Array} fingerprint - Recipient fingerprint, already truncated depending on the key version\n * @returns {Promise<Uint8Array>} Value derived from session key.\n * @async\n */\nexport async function decrypt(oid, kdfParams, V, C, Q, d, fingerprint) {\n  const curve = new CurveWithOID(oid);\n  checkPublicPointEnconding(curve, Q);\n  checkPublicPointEnconding(curve, V);\n  const { sharedKey } = await genPrivateEphemeralKey(curve, V, Q, d);\n  const param = buildEcdhParam(enums.publicKey.ecdh, oid, kdfParams, fingerprint);\n  const { keySize } = getCipherParams(kdfParams.cipher);\n  let err;\n  for (let i = 0; i < 3; i++) {\n    try {\n      // Work around old go crypto bug and old OpenPGP.js bug, respectively.\n      const Z = await kdf(kdfParams.hash, sharedKey, keySize, param, i === 1, i === 2);\n      return pkcs5.decode(await aesKW.unwrap(kdfParams.cipher, Z, C));\n    } catch (e) {\n      err = e;\n    }\n  }\n  throw err;\n}\n\nasync function jsPrivateEphemeralKey(curve, V, d) {\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdh, curve.name);\n  // The output includes parity byte\n  const sharedSecretWithParity = nobleCurve.getSharedSecret(d, V);\n  const sharedKey = sharedSecretWithParity.subarray(1);\n  return { secretKey: d, sharedKey };\n}\n\nasync function jsPublicEphemeralKey(curve, Q) {\n  const nobleCurve = await util.getNobleCurve(enums.publicKey.ecdh, curve.name);\n  const { publicKey: V, privateKey: v } = await curve.genKeyPair();\n\n  // The output includes parity byte\n  const sharedSecretWithParity = nobleCurve.getSharedSecret(v, Q);\n  const sharedKey = sharedSecretWithParity.subarray(1);\n  return { publicKey: V, sharedKey };\n}\n\n/**\n * Generate ECDHE secret from private key and public part of ephemeral key using webCrypto\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} V - Public part of ephemeral key\n * @param {Uint8Array} Q - Recipient public key\n * @param {Uint8Array} d - Recipient private key\n * @returns {Promise<{secretKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function webPrivateEphemeralKey(curve, V, Q, d) {\n  const webCrypto = util.getWebCrypto();\n  const recipient = privateToJWK(curve.payloadSize, curve.web, Q, d);\n  let privateKey = webCrypto.importKey(\n    'jwk',\n    recipient,\n    {\n      name: 'ECDH',\n      namedCurve: curve.web\n    },\n    true,\n    ['deriveKey', 'deriveBits']\n  );\n  const jwk = rawPublicToJWK(curve.payloadSize, curve.web, V);\n  let sender = webCrypto.importKey(\n    'jwk',\n    jwk,\n    {\n      name: 'ECDH',\n      namedCurve: curve.web\n    },\n    true,\n    []\n  );\n  [privateKey, sender] = await Promise.all([privateKey, sender]);\n  let S = webCrypto.deriveBits(\n    {\n      name: 'ECDH',\n      namedCurve: curve.web,\n      public: sender\n    },\n    privateKey,\n    curve.sharedSize\n  );\n  let secret = webCrypto.exportKey(\n    'jwk',\n    privateKey\n  );\n  [S, secret] = await Promise.all([S, secret]);\n  const sharedKey = new Uint8Array(S);\n  const secretKey = b64ToUint8Array(secret.d, true);\n  return { secretKey, sharedKey };\n}\n\n/**\n * Generate ECDHE ephemeral key and secret from public key using webCrypto\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} Q - Recipient public key\n * @returns {Promise<{publicKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function webPublicEphemeralKey(curve, Q) {\n  const webCrypto = util.getWebCrypto();\n  const jwk = rawPublicToJWK(curve.payloadSize, curve.web, Q);\n  let keyPair = webCrypto.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve.web\n    },\n    true,\n    ['deriveKey', 'deriveBits']\n  );\n  let recipient = webCrypto.importKey(\n    'jwk',\n    jwk,\n    {\n      name: 'ECDH',\n      namedCurve: curve.web\n    },\n    false,\n    []\n  );\n  [keyPair, recipient] = await Promise.all([keyPair, recipient]);\n  let s = webCrypto.deriveBits(\n    {\n      name: 'ECDH',\n      namedCurve: curve.web,\n      public: recipient\n    },\n    keyPair.privateKey,\n    curve.sharedSize\n  );\n  let p = webCrypto.exportKey(\n    'jwk',\n    keyPair.publicKey\n  );\n  [s, p] = await Promise.all([s, p]);\n  const sharedKey = new Uint8Array(s);\n  const publicKey = new Uint8Array(jwkToRawPublic(p, curve.wireFormatLeadingByte));\n  return { publicKey, sharedKey };\n}\n\n/**\n * Generate ECDHE secret from private key and public part of ephemeral key using nodeCrypto\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} V - Public part of ephemeral key\n * @param {Uint8Array} d - Recipient private key\n * @returns {Promise<{secretKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function nodePrivateEphemeralKey(curve, V, d) {\n  const nodeCrypto = util.getNodeCrypto();\n  const recipient = nodeCrypto.createECDH(curve.node);\n  recipient.setPrivateKey(d);\n  const sharedKey = new Uint8Array(recipient.computeSecret(V));\n  const secretKey = new Uint8Array(recipient.getPrivateKey());\n  return { secretKey, sharedKey };\n}\n\n/**\n * Generate ECDHE ephemeral key and secret from public key using nodeCrypto\n *\n * @param {CurveWithOID} curve - Elliptic curve object\n * @param {Uint8Array} Q - Recipient public key\n * @returns {Promise<{publicKey: Uint8Array, sharedKey: Uint8Array}>}\n * @async\n */\nasync function nodePublicEphemeralKey(curve, Q) {\n  const nodeCrypto = util.getNodeCrypto();\n  const sender = nodeCrypto.createECDH(curve.node);\n  sender.generateKeys();\n  const sharedKey = new Uint8Array(sender.computeSecret(Q));\n  const publicKey = new Uint8Array(sender.getPublicKey());\n  return { publicKey, sharedKey };\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview A Digital signature algorithm implementation\n * @module crypto/public_key/dsa\n */\nimport { getRandomBigInteger } from '../random';\nimport util from '../../util';\nimport { isProbablePrime } from './prime';\nimport { bigIntToUint8Array, bitLength, byteLength, mod, modExp, modInv, uint8ArrayToBigInt } from '../biginteger';\n\n/*\n  TODO regarding the hash function, read:\n   https://tools.ietf.org/html/rfc4880#section-13.6\n   https://tools.ietf.org/html/rfc4880#section-14\n*/\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\n/**\n * DSA Sign function\n * @param {Integer} hashAlgo\n * @param {Uint8Array} hashed\n * @param {Uint8Array} g\n * @param {Uint8Array} p\n * @param {Uint8Array} q\n * @param {Uint8Array} x\n * @returns {Promise<{ r: Uint8Array, s: Uint8Array }>}\n * @async\n */\nexport async function sign(hashAlgo, hashed, g, p, q, x) {\n  const _0n = BigInt(0);\n  p = uint8ArrayToBigInt(p);\n  q = uint8ArrayToBigInt(q);\n  g = uint8ArrayToBigInt(g);\n  x = uint8ArrayToBigInt(x);\n\n  let k;\n  let r;\n  let s;\n  let t;\n  g = mod(g, p);\n  x = mod(x, q);\n  // If the output size of the chosen hash is larger than the number of\n  // bits of q, the hash result is truncated to fit by taking the number\n  // of leftmost bits equal to the number of bits of q.  This (possibly\n  // truncated) hash function result is treated as a number and used\n  // directly in the DSA signature algorithm.\n  const h = mod(uint8ArrayToBigInt(hashed.subarray(0, byteLength(q))), q);\n  // FIPS-186-4, section 4.6:\n  // The values of r and s shall be checked to determine if r = 0 or s = 0.\n  // If either r = 0 or s = 0, a new value of k shall be generated, and the\n  // signature shall be recalculated. It is extremely unlikely that r = 0\n  // or s = 0 if signatures are generated properly.\n  while (true) {\n    // See Appendix B here: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    k = getRandomBigInteger(_1n, q); // returns in [1, q-1]\n    r = mod(modExp(g, k, p), q); // (g**k mod p) mod q\n    if (r === _0n) {\n      continue;\n    }\n    const xr = mod(x * r, q);\n    t = mod(h + xr, q); // H(m) + x*r mod q\n    s = mod(modInv(k, q) * t, q); // k**-1 * (H(m) + x*r) mod q\n    if (s === _0n) {\n      continue;\n    }\n    break;\n  }\n  return {\n    r: bigIntToUint8Array(r, 'be', byteLength(p)),\n    s: bigIntToUint8Array(s, 'be', byteLength(p))\n  };\n}\n\n/**\n * DSA Verify function\n * @param {Integer} hashAlgo\n * @param {Uint8Array} r\n * @param {Uint8Array} s\n * @param {Uint8Array} hashed\n * @param {Uint8Array} g\n * @param {Uint8Array} p\n * @param {Uint8Array} q\n * @param {Uint8Array} y\n * @returns {boolean}\n * @async\n */\nexport async function verify(hashAlgo, r, s, hashed, g, p, q, y) {\n  r = uint8ArrayToBigInt(r);\n  s = uint8ArrayToBigInt(s);\n\n  p = uint8ArrayToBigInt(p);\n  q = uint8ArrayToBigInt(q);\n  g = uint8ArrayToBigInt(g);\n  y = uint8ArrayToBigInt(y);\n\n  if (r <= _0n || r >= q ||\n      s <= _0n || s >= q) {\n    util.printDebug('invalid DSA Signature');\n    return false;\n  }\n  const h = mod(uint8ArrayToBigInt(hashed.subarray(0, byteLength(q))), q);\n  const w = modInv(s, q); // s**-1 mod q\n  if (w === _0n) {\n    util.printDebug('invalid DSA Signature');\n    return false;\n  }\n\n  g = mod(g, p);\n  y = mod(y, p);\n  const u1 = mod(h * w, q); // H(m) * w mod q\n  const u2 = mod(r * w, q); // r * w mod q\n  const t1 = modExp(g, u1, p); // g**u1 mod p\n  const t2 = modExp(y, u2, p); // y**u2 mod p\n  const v = mod(mod(t1 * t2, p), q); // (g**u1 * y**u2 mod p) mod q\n  return v === r;\n}\n\n/**\n * Validate DSA parameters\n * @param {Uint8Array} p - DSA prime\n * @param {Uint8Array} q - DSA group order\n * @param {Uint8Array} g - DSA sub-group generator\n * @param {Uint8Array} y - DSA public key\n * @param {Uint8Array} x - DSA private key\n * @returns {Promise<Boolean>} Whether params are valid.\n * @async\n */\nexport async function validateParams(p, q, g, y, x) {\n  p = uint8ArrayToBigInt(p);\n  q = uint8ArrayToBigInt(q);\n  g = uint8ArrayToBigInt(g);\n  y = uint8ArrayToBigInt(y);\n  // Check that 1 < g < p\n  if (g <= _1n || g >= p) {\n    return false;\n  }\n\n  /**\n   * Check that subgroup order q divides p-1\n   */\n  if (mod(p - _1n, q) !== _0n) {\n    return false;\n  }\n\n  /**\n   * g has order q\n   * Check that g ** q = 1 mod p\n   */\n  if (modExp(g, q, p) !== _1n) {\n    return false;\n  }\n\n  /**\n   * Check q is large and probably prime (we mainly want to avoid small factors)\n   */\n  const qSize = BigInt(bitLength(q));\n  const _150n = BigInt(150);\n  if (qSize < _150n || !isProbablePrime(q, null, 32)) {\n    return false;\n  }\n\n  /**\n   * Re-derive public key y' = g ** x mod p\n   * Expect y == y'\n   *\n   * Blinded exponentiation computes g**{rq + x} to compare to y\n   */\n  x = uint8ArrayToBigInt(x);\n  const _2n = BigInt(2);\n  const r = getRandomBigInteger(_2n << (qSize - _1n), _2n << qSize); // draw r of same size as q\n  const rqx = q * r + x;\n  if (y !== modExp(g, rqx, p)) {\n    return false;\n  }\n\n  return true;\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * Encoded symmetric key for ECDH (incl. legacy x25519)\n *\n * @module type/ecdh_symkey\n */\n\nimport util from '../util';\n\nclass ECDHSymmetricKey {\n  constructor(data) {\n    if (data) {\n      this.data = data;\n    }\n  }\n\n  /**\n   * Read an ECDHSymmetricKey from an Uint8Array:\n   * - 1 octect for the length `l`\n   * - `l` octects of encoded session key data\n   * @param {Uint8Array} bytes\n   * @returns {Number} Number of read bytes.\n   */\n  read(bytes) {\n    if (bytes.length >= 1) {\n      const length = bytes[0];\n      if (bytes.length >= 1 + length) {\n        this.data = bytes.subarray(1, 1 + length);\n        return 1 + this.data.length;\n      }\n    }\n    throw new Error('Invalid symmetric key');\n  }\n\n  /**\n   * Write an ECDHSymmetricKey as an Uint8Array\n   * @returns  {Uint8Array} Serialised data\n   */\n  write() {\n    return util.concatUint8Array([new Uint8Array([this.data.length]), this.data]);\n  }\n}\n\nexport default ECDHSymmetricKey;\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { UnsupportedError } from '../packet/packet';\n\n/**\n * Implementation of type KDF parameters\n *\n * {@link https://tools.ietf.org/html/rfc6637#section-7|RFC 6637 7}:\n * A key derivation function (KDF) is necessary to implement the EC\n * encryption.  The Concatenation Key Derivation Function (Approved\n * Alternative 1) [NIST-SP800-56A] with the KDF hash function that is\n * SHA2-256 [FIPS-180-3] or stronger is REQUIRED.\n * @module type/kdf_params\n * @private\n */\n\nclass KDFParams {\n  /**\n   * @param {enums.hash} hash - Hash algorithm\n   * @param {enums.symmetric} cipher - Symmetric algorithm\n   */\n  constructor(data) {\n    if (data) {\n      const { hash, cipher } = data;\n      this.hash = hash;\n      this.cipher = cipher;\n    } else {\n      this.hash = null;\n      this.cipher = null;\n    }\n  }\n\n  /**\n   * Read KDFParams from an Uint8Array\n   * @param {Uint8Array} input - Where to read the KDFParams from\n   * @returns {Number} Number of read bytes.\n   */\n  read(input) {\n    if (input.length < 4 || input[0] !== 3 || input[1] !== 1) {\n      throw new UnsupportedError('Cannot read KDFParams');\n    }\n    this.hash = input[2];\n    this.cipher = input[3];\n    return 4;\n  }\n\n  /**\n   * Write KDFParams to an Uint8Array\n   * @returns  {Uint8Array}  Array with the KDFParams value\n   */\n  write() {\n    return new Uint8Array([3, 1, this.hash, this.cipher]);\n  }\n}\n\nexport default KDFParams;\n","/**\n * Encoded symmetric key for x25519 and x448\n * The payload format varies for v3 and v6 PKESK:\n * the former includes an algorithm byte preceeding the encrypted session key.\n *\n * @module type/x25519x448_symkey\n */\n\nimport util from '../util';\n\nclass ECDHXSymmetricKey {\n  static fromObject({ wrappedKey, algorithm }) {\n    const instance = new ECDHXSymmetricKey();\n    instance.wrappedKey = wrappedKey;\n    instance.algorithm = algorithm;\n    return instance;\n  }\n\n  /**\n   * - 1 octect for the length `l`\n   * - `l` octects of encoded session key data (with optional leading algorithm byte)\n   * @param {Uint8Array} bytes\n   * @returns {Number} Number of read bytes.\n   */\n  read(bytes) {\n    let read = 0;\n    let followLength = bytes[read++];\n    this.algorithm = followLength % 2 ? bytes[read++] : null; // session key size is always even\n    followLength -= followLength % 2;\n    this.wrappedKey = util.readExactSubarray(bytes, read, read + followLength); read += followLength;\n  }\n\n  /**\n   * Write an MontgomerySymmetricKey as an Uint8Array\n   * @returns  {Uint8Array} Serialised data\n   */\n  write() {\n    return util.concatUint8Array([\n      this.algorithm ?\n        new Uint8Array([this.wrappedKey.length + 1, this.algorithm]) :\n        new Uint8Array([this.wrappedKey.length]),\n      this.wrappedKey\n    ]);\n  }\n}\n\nexport default ECDHXSymmetricKey;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n// The GPG4Browsers crypto interface\n\n/**\n * @fileoverview Provides functions for asymmetric encryption and decryption as\n * well as key generation and parameter handling for all public-key cryptosystems.\n * @module crypto/crypto\n */\n\nimport { rsa, elliptic, elgamal, dsa } from './public_key';\nimport { getRandomBytes } from './random';\nimport { getCipherParams } from './cipher';\nimport ECDHSymkey from '../type/ecdh_symkey';\nimport KDFParams from '../type/kdf_params';\nimport enums from '../enums';\nimport util from '../util';\nimport OID from '../type/oid';\nimport { UnsupportedError } from '../packet/packet';\nimport ECDHXSymmetricKey from '../type/ecdh_x_symkey';\n\n/**\n * Encrypts data using specified algorithm and public key parameters.\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.1|RFC 4880 9.1} for public key algorithms.\n * @param {module:enums.publicKey} keyAlgo - Public key algorithm\n * @param {module:enums.symmetric|null} symmetricAlgo - Cipher algorithm (v3 only)\n * @param {Object} publicParams - Algorithm-specific public key parameters\n * @param {Uint8Array} data - Session key data to be encrypted\n * @param {Uint8Array} fingerprint - Recipient fingerprint\n * @returns {Promise<Object>} Encrypted session key parameters.\n * @async\n */\nexport async function publicKeyEncrypt(keyAlgo, symmetricAlgo, publicParams, data, fingerprint) {\n  switch (keyAlgo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign: {\n      const { n, e } = publicParams;\n      const c = await rsa.encrypt(data, n, e);\n      return { c };\n    }\n    case enums.publicKey.elgamal: {\n      const { p, g, y } = publicParams;\n      return elgamal.encrypt(data, p, g, y);\n    }\n    case enums.publicKey.ecdh: {\n      const { oid, Q, kdfParams } = publicParams;\n      const { publicKey: V, wrappedKey: C } = await elliptic.ecdh.encrypt(\n        oid, kdfParams, data, Q, fingerprint);\n      return { V, C: new ECDHSymkey(C) };\n    }\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      if (symmetricAlgo && !util.isAES(symmetricAlgo)) {\n        // see https://gitlab.com/openpgp-wg/rfc4880bis/-/merge_requests/276\n        throw new Error('X25519 and X448 keys can only encrypt AES session keys');\n      }\n      const { A } = publicParams;\n      const { ephemeralPublicKey, wrappedKey } = await elliptic.ecdhX.encrypt(\n        keyAlgo, data, A);\n      const C = ECDHXSymmetricKey.fromObject({ algorithm: symmetricAlgo, wrappedKey });\n      return { ephemeralPublicKey, C };\n    }\n    default:\n      return [];\n  }\n}\n\n/**\n * Decrypts data using specified algorithm and private key parameters.\n * See {@link https://tools.ietf.org/html/rfc4880#section-5.5.3|RFC 4880 5.5.3}\n * @param {module:enums.publicKey} algo - Public key algorithm\n * @param {Object} publicKeyParams - Algorithm-specific public key parameters\n * @param {Object} privateKeyParams - Algorithm-specific private key parameters\n * @param {Object} sessionKeyParams - Encrypted session key parameters\n * @param {Uint8Array} fingerprint - Recipient fingerprint\n * @param {Uint8Array} [randomPayload] - Data to return on decryption error, instead of throwing\n *                                    (needed for constant-time processing in RSA and ElGamal)\n * @returns {Promise<Uint8Array>} Decrypted data.\n * @throws {Error} on sensitive decryption error, unless `randomPayload` is given\n * @async\n */\nexport async function publicKeyDecrypt(algo, publicKeyParams, privateKeyParams, sessionKeyParams, fingerprint, randomPayload) {\n  switch (algo) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt: {\n      const { c } = sessionKeyParams;\n      const { n, e } = publicKeyParams;\n      const { d, p, q, u } = privateKeyParams;\n      return rsa.decrypt(c, n, e, d, p, q, u, randomPayload);\n    }\n    case enums.publicKey.elgamal: {\n      const { c1, c2 } = sessionKeyParams;\n      const p = publicKeyParams.p;\n      const x = privateKeyParams.x;\n      return elgamal.decrypt(c1, c2, p, x, randomPayload);\n    }\n    case enums.publicKey.ecdh: {\n      const { oid, Q, kdfParams } = publicKeyParams;\n      const { d } = privateKeyParams;\n      const { V, C } = sessionKeyParams;\n      return elliptic.ecdh.decrypt(\n        oid, kdfParams, V, C.data, Q, d, fingerprint);\n    }\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const { A } = publicKeyParams;\n      const { k } = privateKeyParams;\n      const { ephemeralPublicKey, C } = sessionKeyParams;\n      if (C.algorithm !== null && !util.isAES(C.algorithm)) {\n        throw new Error('AES session key expected');\n      }\n      return elliptic.ecdhX.decrypt(\n        algo, ephemeralPublicKey, C.wrappedKey, A, k);\n    }\n    default:\n      throw new Error('Unknown public key encryption algorithm.');\n  }\n}\n\n/**\n * Parse public key material in binary form to get the key parameters\n * @param {module:enums.publicKey} algo - The key algorithm\n * @param {Uint8Array} bytes - The key material to parse\n * @returns {{ read: Number, publicParams: Object }} Number of read bytes plus key parameters referenced by name.\n */\nexport function parsePublicKeyParams(algo, bytes) {\n  let read = 0;\n  switch (algo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign: {\n      const n = util.readMPI(bytes.subarray(read)); read += n.length + 2;\n      const e = util.readMPI(bytes.subarray(read)); read += e.length + 2;\n      return { read, publicParams: { n, e } };\n    }\n    case enums.publicKey.dsa: {\n      const p = util.readMPI(bytes.subarray(read)); read += p.length + 2;\n      const q = util.readMPI(bytes.subarray(read)); read += q.length + 2;\n      const g = util.readMPI(bytes.subarray(read)); read += g.length + 2;\n      const y = util.readMPI(bytes.subarray(read)); read += y.length + 2;\n      return { read, publicParams: { p, q, g, y } };\n    }\n    case enums.publicKey.elgamal: {\n      const p = util.readMPI(bytes.subarray(read)); read += p.length + 2;\n      const g = util.readMPI(bytes.subarray(read)); read += g.length + 2;\n      const y = util.readMPI(bytes.subarray(read)); read += y.length + 2;\n      return { read, publicParams: { p, g, y } };\n    }\n    case enums.publicKey.ecdsa: {\n      const oid = new OID(); read += oid.read(bytes);\n      checkSupportedCurve(oid);\n      const Q = util.readMPI(bytes.subarray(read)); read += Q.length + 2;\n      return { read: read, publicParams: { oid, Q } };\n    }\n    case enums.publicKey.eddsaLegacy: {\n      const oid = new OID(); read += oid.read(bytes);\n      checkSupportedCurve(oid);\n      if (oid.getName() !== enums.curve.ed25519Legacy) {\n        throw new Error('Unexpected OID for eddsaLegacy');\n      }\n      let Q = util.readMPI(bytes.subarray(read)); read += Q.length + 2;\n      Q = util.leftPad(Q, 33);\n      return { read: read, publicParams: { oid, Q } };\n    }\n    case enums.publicKey.ecdh: {\n      const oid = new OID(); read += oid.read(bytes);\n      checkSupportedCurve(oid);\n      const Q = util.readMPI(bytes.subarray(read)); read += Q.length + 2;\n      const kdfParams = new KDFParams(); read += kdfParams.read(bytes.subarray(read));\n      return { read: read, publicParams: { oid, Q, kdfParams } };\n    }\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448:\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const A = util.readExactSubarray(bytes, read, read + getCurvePayloadSize(algo)); read += A.length;\n      return { read, publicParams: { A } };\n    }\n    default:\n      throw new UnsupportedError('Unknown public key encryption algorithm.');\n  }\n}\n\n/**\n * Parse private key material in binary form to get the key parameters\n * @param {module:enums.publicKey} algo - The key algorithm\n * @param {Uint8Array} bytes - The key material to parse\n * @param {Object} publicParams - (ECC only) public params, needed to format some private params\n * @returns {{ read: Number, privateParams: Object }} Number of read bytes plus the key parameters referenced by name.\n */\nexport function parsePrivateKeyParams(algo, bytes, publicParams) {\n  let read = 0;\n  switch (algo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign: {\n      const d = util.readMPI(bytes.subarray(read)); read += d.length + 2;\n      const p = util.readMPI(bytes.subarray(read)); read += p.length + 2;\n      const q = util.readMPI(bytes.subarray(read)); read += q.length + 2;\n      const u = util.readMPI(bytes.subarray(read)); read += u.length + 2;\n      return { read, privateParams: { d, p, q, u } };\n    }\n    case enums.publicKey.dsa:\n    case enums.publicKey.elgamal: {\n      const x = util.readMPI(bytes.subarray(read)); read += x.length + 2;\n      return { read, privateParams: { x } };\n    }\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.ecdh: {\n      const payloadSize = getCurvePayloadSize(algo, publicParams.oid);\n      let d = util.readMPI(bytes.subarray(read)); read += d.length + 2;\n      d = util.leftPad(d, payloadSize);\n      return { read, privateParams: { d } };\n    }\n    case enums.publicKey.eddsaLegacy: {\n      const payloadSize = getCurvePayloadSize(algo, publicParams.oid);\n      if (publicParams.oid.getName() !== enums.curve.ed25519Legacy) {\n        throw new Error('Unexpected OID for eddsaLegacy');\n      }\n      let seed = util.readMPI(bytes.subarray(read)); read += seed.length + 2;\n      seed = util.leftPad(seed, payloadSize);\n      return { read, privateParams: { seed } };\n    }\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448: {\n      const payloadSize = getCurvePayloadSize(algo);\n      const seed = util.readExactSubarray(bytes, read, read + payloadSize); read += seed.length;\n      return { read, privateParams: { seed } };\n    }\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const payloadSize = getCurvePayloadSize(algo);\n      const k = util.readExactSubarray(bytes, read, read + payloadSize); read += k.length;\n      return { read, privateParams: { k } };\n    }\n    default:\n      throw new UnsupportedError('Unknown public key encryption algorithm.');\n  }\n}\n\n/** Returns the types comprising the encrypted session key of an algorithm\n * @param {module:enums.publicKey} algo - The key algorithm\n * @param {Uint8Array} bytes - The key material to parse\n * @returns {Object} The session key parameters referenced by name.\n */\nexport function parseEncSessionKeyParams(algo, bytes) {\n  let read = 0;\n  switch (algo) {\n    //   Algorithm-Specific Fields for RSA encrypted session keys:\n    //       - MPI of RSA encrypted value m**e mod n.\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign: {\n      const c = util.readMPI(bytes.subarray(read));\n      return { c };\n    }\n\n    //   Algorithm-Specific Fields for Elgamal encrypted session keys:\n    //       - MPI of Elgamal value g**k mod p\n    //       - MPI of Elgamal value m * y**k mod p\n    case enums.publicKey.elgamal: {\n      const c1 = util.readMPI(bytes.subarray(read)); read += c1.length + 2;\n      const c2 = util.readMPI(bytes.subarray(read));\n      return { c1, c2 };\n    }\n    //   Algorithm-Specific Fields for ECDH encrypted session keys:\n    //       - MPI containing the ephemeral key used to establish the shared secret\n    //       - ECDH Symmetric Key\n    case enums.publicKey.ecdh: {\n      const V = util.readMPI(bytes.subarray(read)); read += V.length + 2;\n      const C = new ECDHSymkey(); C.read(bytes.subarray(read));\n      return { V, C };\n    }\n    //   Algorithm-Specific Fields for X25519 or X448 encrypted session keys:\n    //       - 32 octets representing an ephemeral X25519 public key (or 57 octets for X448).\n    //       - A one-octet size of the following fields.\n    //       - The one-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).\n    //       - The encrypted session key.\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const pointSize = getCurvePayloadSize(algo);\n      const ephemeralPublicKey = util.readExactSubarray(bytes, read, read + pointSize); read += ephemeralPublicKey.length;\n      const C = new ECDHXSymmetricKey(); C.read(bytes.subarray(read));\n      return { ephemeralPublicKey, C };\n    }\n    default:\n      throw new UnsupportedError('Unknown public key encryption algorithm.');\n  }\n}\n\n/**\n * Convert params to MPI and serializes them in the proper order\n * @param {module:enums.publicKey} algo - The public key algorithm\n * @param {Object} params - The key parameters indexed by name\n * @returns {Uint8Array} The array containing the MPIs.\n */\nexport function serializeParams(algo, params) {\n  // Some algorithms do not rely on MPIs to store the binary params\n  const algosWithNativeRepresentation = new Set([\n    enums.publicKey.ed25519,\n    enums.publicKey.x25519,\n    enums.publicKey.ed448,\n    enums.publicKey.x448\n  ]);\n  const orderedParams = Object.keys(params).map(name => {\n    const param = params[name];\n    if (!util.isUint8Array(param)) return param.write();\n    return algosWithNativeRepresentation.has(algo) ? param : util.uint8ArrayToMPI(param);\n  });\n  return util.concatUint8Array(orderedParams);\n}\n\n/**\n * Generate algorithm-specific key parameters\n * @param {module:enums.publicKey} algo - The public key algorithm\n * @param {Integer} bits - Bit length for RSA keys\n * @param {module:type/oid} oid - Object identifier for ECC keys\n * @returns {Promise<{ publicParams: {Object}, privateParams: {Object} }>} The parameters referenced by name.\n * @async\n */\nexport function generateParams(algo, bits, oid) {\n  switch (algo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign:\n      return rsa.generate(bits, 65537).then(({ n, e, d, p, q, u }) => ({\n        privateParams: { d, p, q, u },\n        publicParams: { n, e }\n      }));\n    case enums.publicKey.ecdsa:\n      return elliptic.generate(oid).then(({ oid, Q, secret }) => ({\n        privateParams: { d: secret },\n        publicParams: { oid: new OID(oid), Q }\n      }));\n    case enums.publicKey.eddsaLegacy:\n      return elliptic.generate(oid).then(({ oid, Q, secret }) => ({\n        privateParams: { seed: secret },\n        publicParams: { oid: new OID(oid), Q }\n      }));\n    case enums.publicKey.ecdh:\n      return elliptic.generate(oid).then(({ oid, Q, secret, hash, cipher }) => ({\n        privateParams: { d: secret },\n        publicParams: {\n          oid: new OID(oid),\n          Q,\n          kdfParams: new KDFParams({ hash, cipher })\n        }\n      }));\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448:\n      return elliptic.eddsa.generate(algo).then(({ A, seed }) => ({\n        privateParams: { seed },\n        publicParams: { A }\n      }));\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448:\n      return elliptic.ecdhX.generate(algo).then(({ A, k }) => ({\n        privateParams: { k },\n        publicParams: { A }\n      }));\n    case enums.publicKey.dsa:\n    case enums.publicKey.elgamal:\n      throw new Error('Unsupported algorithm for key generation.');\n    default:\n      throw new Error('Unknown public key algorithm.');\n  }\n}\n\n/**\n * Validate algorithm-specific key parameters\n * @param {module:enums.publicKey} algo - The public key algorithm\n * @param {Object} publicParams - Algorithm-specific public key parameters\n * @param {Object} privateParams - Algorithm-specific private key parameters\n * @returns {Promise<Boolean>} Whether the parameters are valid.\n * @async\n */\nexport async function validateParams(algo, publicParams, privateParams) {\n  if (!publicParams || !privateParams) {\n    throw new Error('Missing key parameters');\n  }\n  switch (algo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign: {\n      const { n, e } = publicParams;\n      const { d, p, q, u } = privateParams;\n      return rsa.validateParams(n, e, d, p, q, u);\n    }\n    case enums.publicKey.dsa: {\n      const { p, q, g, y } = publicParams;\n      const { x } = privateParams;\n      return dsa.validateParams(p, q, g, y, x);\n    }\n    case enums.publicKey.elgamal: {\n      const { p, g, y } = publicParams;\n      const { x } = privateParams;\n      return elgamal.validateParams(p, g, y, x);\n    }\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.ecdh: {\n      const algoModule = elliptic[enums.read(enums.publicKey, algo)];\n      const { oid, Q } = publicParams;\n      const { d } = privateParams;\n      return algoModule.validateParams(oid, Q, d);\n    }\n    case enums.publicKey.eddsaLegacy: {\n      const { Q, oid } = publicParams;\n      const { seed } = privateParams;\n      return elliptic.eddsaLegacy.validateParams(oid, Q, seed);\n    }\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448: {\n      const { A } = publicParams;\n      const { seed } = privateParams;\n      return elliptic.eddsa.validateParams(algo, A, seed);\n    }\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const { A } = publicParams;\n      const { k } = privateParams;\n      return elliptic.ecdhX.validateParams(algo, A, k);\n    }\n    default:\n      throw new Error('Unknown public key algorithm.');\n  }\n}\n\n/**\n * Generating a session key for the specified symmetric algorithm\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2} for algorithms.\n * @param {module:enums.symmetric} algo - Symmetric encryption algorithm\n * @returns {Uint8Array} Random bytes as a string to be used as a key.\n */\nexport function generateSessionKey(algo) {\n  const { keySize } = getCipherParams(algo);\n  return getRandomBytes(keySize);\n}\n\n/**\n * Check whether the given curve OID is supported\n * @param {module:type/oid} oid - EC object identifier\n * @throws {UnsupportedError} if curve is not supported\n */\nfunction checkSupportedCurve(oid) {\n  try {\n    oid.getName();\n  } catch (e) {\n    throw new UnsupportedError('Unknown curve OID');\n  }\n}\n\n/**\n * Get encoded secret size for a given elliptic algo\n * @param {module:enums.publicKey} algo - alrogithm identifier\n * @param {module:type/oid} [oid] - curve OID if needed by algo\n */\nexport function getCurvePayloadSize(algo, oid) {\n  switch (algo) {\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.ecdh:\n    case enums.publicKey.eddsaLegacy:\n      return new elliptic.CurveWithOID(oid).payloadSize;\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448:\n      return elliptic.eddsa.getPayloadSize(algo);\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448:\n      return elliptic.ecdhX.getPayloadSize(algo);\n    default:\n      throw new Error('Unknown elliptic algo');\n  }\n}\n\n/**\n * Get preferred signing hash algo for a given elliptic algo\n * @param {module:enums.publicKey} algo - alrogithm identifier\n * @param {module:type/oid} [oid] - curve OID if needed by algo\n */\nexport function getPreferredCurveHashAlgo(algo, oid) {\n  switch (algo) {\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.eddsaLegacy:\n      return elliptic.getPreferredHashAlgo(oid);\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448:\n      return elliptic.eddsa.getPreferredHashAlgo(algo);\n    default:\n      throw new Error('Unknown elliptic signing algo');\n  }\n}\n\n","// Modified by ProtonTech AG\n\n// Modified by Recurity Labs GmbH\n\n// modified version of https://www.hanewin.net/encrypt/PGdecode.js:\n\n/* OpenPGP encryption using RSA/AES\n * Copyright 2005-2006 Herbert Hanewinkel, www.haneWIN.de\n * version 2.0, check www.haneWIN.de for the latest version\n\n * This software is provided as-is, without express or implied warranty.\n * Permission to use, copy, modify, distribute or sell this software, with or\n * without fee, for any purpose and by any individual or organization, is hereby\n * granted, provided that the above copyright notice and this paragraph appear\n * in all copies. Distribution as a part of an application or binary must\n * include the above copyright notice in the documentation and/or other\n * materials provided with the application or distribution.\n */\n\n/**\n * @module crypto/mode/cfb\n */\n\nimport { cfb as nobleAesCfb, unsafe as nobleAesHelpers } from '@noble/ciphers/aes';\n\nimport { transform as streamTransform } from '@openpgp/web-stream-tools';\nimport util from '../../util';\nimport enums from '../../enums';\nimport { getLegacyCipher, getCipherParams } from '../cipher';\nimport { getRandomBytes } from '../random';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\n\nconst knownAlgos = nodeCrypto ? nodeCrypto.getCiphers() : [];\nconst nodeAlgos = {\n  idea: knownAlgos.includes('idea-cfb') ? 'idea-cfb' : undefined, /* Unused, not implemented */\n  tripledes: knownAlgos.includes('des-ede3-cfb') ? 'des-ede3-cfb' : undefined,\n  cast5: knownAlgos.includes('cast5-cfb') ? 'cast5-cfb' : undefined,\n  blowfish: knownAlgos.includes('bf-cfb') ? 'bf-cfb' : undefined,\n  aes128: knownAlgos.includes('aes-128-cfb') ? 'aes-128-cfb' : undefined,\n  aes192: knownAlgos.includes('aes-192-cfb') ? 'aes-192-cfb' : undefined,\n  aes256: knownAlgos.includes('aes-256-cfb') ? 'aes-256-cfb' : undefined\n  /* twofish is not implemented in OpenSSL */\n};\n\n/**\n * Generates a random byte prefix for the specified algorithm\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2} for algorithms.\n * @param {module:enums.symmetric} algo - Symmetric encryption algorithm\n * @returns {Promise<Uint8Array>} Random bytes with length equal to the block size of the cipher, plus the last two bytes repeated.\n * @async\n */\nexport async function getPrefixRandom(algo) {\n  const { blockSize } = getCipherParams(algo);\n  const prefixrandom = await getRandomBytes(blockSize);\n  const repeat = new Uint8Array([prefixrandom[prefixrandom.length - 2], prefixrandom[prefixrandom.length - 1]]);\n  return util.concat([prefixrandom, repeat]);\n}\n\n/**\n * CFB encryption\n * @param {enums.symmetric} algo - block cipher algorithm\n * @param {Uint8Array} key\n * @param {MaybeStream<Uint8Array>} plaintext\n * @param {Uint8Array} iv\n * @param {Object} config - full configuration, defaults to openpgp.config\n * @returns MaybeStream<Uint8Array>\n */\nexport async function encrypt(algo, key, plaintext, iv, config) {\n  const algoName = enums.read(enums.symmetric, algo);\n  if (util.getNodeCrypto() && nodeAlgos[algoName]) { // Node crypto library.\n    return nodeEncrypt(algo, key, plaintext, iv);\n  }\n  if (util.isAES(algo)) {\n    return aesEncrypt(algo, key, plaintext, iv, config);\n  }\n\n  const LegacyCipher = await getLegacyCipher(algo);\n  const cipherfn = new LegacyCipher(key);\n  const block_size = cipherfn.blockSize;\n\n  const blockc = iv.slice();\n  let pt = new Uint8Array();\n  const process = chunk => {\n    if (chunk) {\n      pt = util.concatUint8Array([pt, chunk]);\n    }\n    const ciphertext = new Uint8Array(pt.length);\n    let i;\n    let j = 0;\n    while (chunk ? pt.length >= block_size : pt.length) {\n      const encblock = cipherfn.encrypt(blockc);\n      for (i = 0; i < block_size; i++) {\n        blockc[i] = pt[i] ^ encblock[i];\n        ciphertext[j++] = blockc[i];\n      }\n      pt = pt.subarray(block_size);\n    }\n    return ciphertext.subarray(0, j);\n  };\n  return streamTransform(plaintext, process, process);\n}\n\n/**\n * CFB decryption\n * @param {enums.symmetric} algo - block cipher algorithm\n * @param {Uint8Array} key\n * @param {MaybeStream<Uint8Array>} ciphertext\n * @param {Uint8Array} iv\n * @returns MaybeStream<Uint8Array>\n */\nexport async function decrypt(algo, key, ciphertext, iv) {\n  const algoName = enums.read(enums.symmetric, algo);\n  if (nodeCrypto && nodeAlgos[algoName]) { // Node crypto library.\n    return nodeDecrypt(algo, key, ciphertext, iv);\n  }\n  if (util.isAES(algo)) {\n    return aesDecrypt(algo, key, ciphertext, iv);\n  }\n\n  const LegacyCipher = await getLegacyCipher(algo);\n  const cipherfn = new LegacyCipher(key);\n  const block_size = cipherfn.blockSize;\n\n  let blockp = iv;\n  let ct = new Uint8Array();\n  const process = chunk => {\n    if (chunk) {\n      ct = util.concatUint8Array([ct, chunk]);\n    }\n    const plaintext = new Uint8Array(ct.length);\n    let i;\n    let j = 0;\n    while (chunk ? ct.length >= block_size : ct.length) {\n      const decblock = cipherfn.encrypt(blockp);\n      blockp = ct.subarray(0, block_size);\n      for (i = 0; i < block_size; i++) {\n        plaintext[j++] = blockp[i] ^ decblock[i];\n      }\n      ct = ct.subarray(block_size);\n    }\n    return plaintext.subarray(0, j);\n  };\n  return streamTransform(ciphertext, process, process);\n}\n\nclass WebCryptoEncryptor {\n  constructor(algo, key, iv) {\n    const { blockSize } = getCipherParams(algo);\n    this.key = key;\n    this.prevBlock = iv;\n    this.nextBlock = new Uint8Array(blockSize);\n    this.i = 0; // pointer inside next block\n    this.blockSize = blockSize;\n    this.zeroBlock = new Uint8Array(this.blockSize);\n  }\n\n  static async isSupported(algo) {\n    const { keySize } = getCipherParams(algo);\n    return webCrypto.importKey('raw', new Uint8Array(keySize), 'aes-cbc', false, ['encrypt'])\n      .then(() => true, () => false);\n  }\n\n  async _runCBC(plaintext, nonZeroIV) {\n    const mode = 'AES-CBC';\n    this.keyRef = this.keyRef || await webCrypto.importKey('raw', this.key, mode, false, ['encrypt']);\n    const ciphertext = await webCrypto.encrypt(\n      { name: mode, iv: nonZeroIV || this.zeroBlock },\n      this.keyRef,\n      plaintext\n    );\n    return new Uint8Array(ciphertext).subarray(0, plaintext.length);\n  }\n\n  async encryptChunk(value) {\n    const missing = this.nextBlock.length - this.i;\n    const added = value.subarray(0, missing);\n    this.nextBlock.set(added, this.i);\n    if ((this.i + value.length) >= (2 * this.blockSize)) {\n      const leftover = (value.length - missing) % this.blockSize;\n      const plaintext = util.concatUint8Array([\n        this.nextBlock,\n        value.subarray(missing, value.length - leftover)\n      ]);\n      const toEncrypt = util.concatUint8Array([\n        this.prevBlock,\n        plaintext.subarray(0, plaintext.length - this.blockSize) // stop one block \"early\", since we only need to xor the plaintext and pass it over as prevBlock\n      ]);\n\n      const encryptedBlocks = await this._runCBC(toEncrypt);\n      xorMut(encryptedBlocks, plaintext);\n      this.prevBlock = encryptedBlocks.slice(-this.blockSize);\n\n      // take care of leftover data\n      if (leftover > 0) this.nextBlock.set(value.subarray(-leftover));\n      this.i = leftover;\n\n      return encryptedBlocks;\n    }\n\n    this.i += added.length;\n    let encryptedBlock;\n    if (this.i === this.nextBlock.length) { // block ready to be encrypted\n      const curBlock = this.nextBlock;\n      encryptedBlock = await this._runCBC(this.prevBlock);\n      xorMut(encryptedBlock, curBlock);\n      this.prevBlock = encryptedBlock.slice();\n      this.i = 0;\n\n      const remaining = value.subarray(added.length);\n      this.nextBlock.set(remaining, this.i);\n      this.i += remaining.length;\n    } else {\n      encryptedBlock = new Uint8Array();\n    }\n\n    return encryptedBlock;\n  }\n\n  async finish() {\n    let result;\n    if (this.i === 0) { // nothing more to encrypt\n      result = new Uint8Array();\n    } else {\n      this.nextBlock = this.nextBlock.subarray(0, this.i);\n      const curBlock = this.nextBlock;\n      const encryptedBlock = await this._runCBC(this.prevBlock);\n      xorMut(encryptedBlock, curBlock);\n      result = encryptedBlock.subarray(0, curBlock.length);\n    }\n\n    this.clearSensitiveData();\n    return result;\n  }\n\n  clearSensitiveData() {\n    this.nextBlock.fill(0);\n    this.prevBlock.fill(0);\n    this.keyRef = null;\n    this.key = null;\n  }\n\n  async encrypt(plaintext) {\n    // plaintext is internally padded to block length before encryption\n    const encryptedWithPadding = await this._runCBC(\n      util.concatUint8Array([new Uint8Array(this.blockSize), plaintext]),\n      this.iv\n    );\n    // drop encrypted padding\n    const ct = encryptedWithPadding.subarray(0, plaintext.length);\n    xorMut(ct, plaintext);\n    this.clearSensitiveData();\n    return ct;\n  }\n}\n\nclass NobleStreamProcessor {\n  constructor(forEncryption, algo, key, iv) {\n    this.forEncryption = forEncryption;\n    const { blockSize } = getCipherParams(algo);\n    this.key = nobleAesHelpers.expandKeyLE(key);\n\n    if (iv.byteOffset % 4 !== 0) iv = iv.slice(); // aligned arrays required by noble-ciphers\n    this.prevBlock = getUint32Array(iv);\n    this.nextBlock = new Uint8Array(blockSize);\n    this.i = 0; // pointer inside next block\n    this.blockSize = blockSize;\n  }\n\n  _runCFB(src) {\n    const src32 = getUint32Array(src);\n    const dst = new Uint8Array(src.length);\n    const dst32 = getUint32Array(dst);\n    for (let i = 0; i + 4 <= dst32.length; i += 4) {\n      const { s0: e0, s1: e1, s2: e2, s3: e3 } = nobleAesHelpers.encrypt(this.key, this.prevBlock[0], this.prevBlock[1], this.prevBlock[2], this.prevBlock[3]);\n      dst32[i + 0] = src32[i + 0] ^ e0;\n      dst32[i + 1] = src32[i + 1] ^ e1;\n      dst32[i + 2] = src32[i + 2] ^ e2;\n      dst32[i + 3] = src32[i + 3] ^ e3;\n      this.prevBlock = (this.forEncryption ? dst32 : src32).slice(i, i + 4);\n    }\n    return dst;\n  }\n\n  async processChunk(value) {\n    const missing = this.nextBlock.length - this.i;\n    const added = value.subarray(0, missing);\n    this.nextBlock.set(added, this.i);\n\n    if ((this.i + value.length) >= (2 * this.blockSize)) {\n      const leftover = (value.length - missing) % this.blockSize;\n      const toProcess = util.concatUint8Array([\n        this.nextBlock,\n        value.subarray(missing, value.length - leftover)\n      ]);\n\n      const processedBlocks = this._runCFB(toProcess);\n\n      // take care of leftover data\n      if (leftover > 0) this.nextBlock.set(value.subarray(-leftover));\n      this.i = leftover;\n\n      return processedBlocks;\n    }\n\n    this.i += added.length;\n\n    let processedBlock;\n    if (this.i === this.nextBlock.length) { // block ready to be encrypted\n      processedBlock = this._runCFB(this.nextBlock);\n      this.i = 0;\n\n      const remaining = value.subarray(added.length);\n      this.nextBlock.set(remaining, this.i);\n      this.i += remaining.length;\n    } else {\n      processedBlock = new Uint8Array();\n    }\n\n    return processedBlock;\n  }\n\n  async finish() {\n    let result;\n    if (this.i === 0) { // nothing more to encrypt\n      result = new Uint8Array();\n    } else {\n      const processedBlock = this._runCFB(this.nextBlock);\n\n      result = processedBlock.subarray(0, this.i);\n    }\n\n    this.clearSensitiveData();\n    return result;\n  }\n\n  clearSensitiveData() {\n    this.nextBlock.fill(0);\n    this.prevBlock.fill(0);\n    this.key.fill(0);\n  }\n}\n\n\nasync function aesEncrypt(algo, key, pt, iv) {\n  if (webCrypto && await WebCryptoEncryptor.isSupported(algo)) { // Chromium does not implement AES with 192-bit keys\n    const cfb = new WebCryptoEncryptor(algo, key, iv);\n    return util.isStream(pt) ? streamTransform(pt, value => cfb.encryptChunk(value), () => cfb.finish()) : cfb.encrypt(pt);\n  } else if (util.isStream(pt)) { // async callbacks are not accepted by streamTransform unless the input is a stream\n    const cfb = new NobleStreamProcessor(true, algo, key, iv);\n    return streamTransform(pt, value => cfb.processChunk(value), () => cfb.finish());\n  }\n  return nobleAesCfb(key, iv).encrypt(pt);\n}\n\nasync function aesDecrypt(algo, key, ct, iv) {\n  if (util.isStream(ct)) {\n    const cfb = new NobleStreamProcessor(false, algo, key, iv);\n    return streamTransform(ct, value => cfb.processChunk(value), () => cfb.finish());\n  }\n  return nobleAesCfb(key, iv).decrypt(ct);\n}\n\nfunction xorMut(a, b) {\n  const aLength = Math.min(a.length, b.length);\n  for (let i = 0; i < aLength; i++) {\n    a[i] = a[i] ^ b[i];\n  }\n}\n\nconst getUint32Array = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction nodeEncrypt(algo, key, pt, iv) {\n  const algoName = enums.read(enums.symmetric, algo);\n  const cipherObj = new nodeCrypto.createCipheriv(nodeAlgos[algoName], key, iv);\n  return streamTransform(pt, value => new Uint8Array(cipherObj.update(value)));\n}\n\nfunction nodeDecrypt(algo, key, ct, iv) {\n  const algoName = enums.read(enums.symmetric, algo);\n  const decipherObj = new nodeCrypto.createDecipheriv(nodeAlgos[algoName], key, iv);\n  return streamTransform(ct, value => new Uint8Array(decipherObj.update(value)));\n}\n","/**\n * @fileoverview This module implements AES-CMAC on top of\n * native AES-CBC using either the WebCrypto API or Node.js' crypto API.\n * @module crypto/cmac\n */\n\nimport { cbc as nobleAesCbc } from '@noble/ciphers/aes';\nimport util from '../util';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\n\n\n/**\n * This implementation of CMAC is based on the description of OMAC in\n * http://web.cs.ucdavis.edu/~rogaway/papers/eax.pdf. As per that\n * document:\n *\n * We have made a small modification to the OMAC algorithm as it was\n * originally presented, changing one of its two constants.\n * Specifically, the constant 4 at line 85 was the constant 1/2 (the\n * multiplicative inverse of 2) in the original definition of OMAC [14].\n * The OMAC authors indicate that they will promulgate this modification\n * [15], which slightly simplifies implementations.\n */\n\nconst blockLength = 16;\n\n\n/**\n * xor `padding` into the end of `data`. This function implements \"the\n * operation xor [which] xors the shorter string into the end of longer\n * one\". Since data is always as least as long as padding, we can\n * simplify the implementation.\n * @param {Uint8Array} data\n * @param {Uint8Array} padding\n */\nfunction rightXORMut(data, padding) {\n  const offset = data.length - blockLength;\n  for (let i = 0; i < blockLength; i++) {\n    data[i + offset] ^= padding[i];\n  }\n  return data;\n}\n\nfunction pad(data, padding, padding2) {\n  // if |M| in {n, 2n, 3n, ...}\n  if (data.length && data.length % blockLength === 0) {\n    // then return M xor B,\n    return rightXORMut(data, padding);\n  }\n  // else return (M || 10^(n1(|M| mod n))) xor P\n  const padded = new Uint8Array(data.length + (blockLength - (data.length % blockLength)));\n  padded.set(data);\n  padded[data.length] = 0b10000000;\n  return rightXORMut(padded, padding2);\n}\n\nconst zeroBlock = new Uint8Array(blockLength);\n\nexport default async function CMAC(key) {\n  const cbc = await CBC(key);\n\n  // L  E_K(0^n); B  2L; P  4L\n  const padding = util.double(await cbc(zeroBlock));\n  const padding2 = util.double(padding);\n\n  return async function(data) {\n    // return CBC_K(pad(M; B, P))\n    return (await cbc(pad(data, padding, padding2))).subarray(-blockLength);\n  };\n}\n\nasync function CBC(key) {\n  if (util.getNodeCrypto()) { // Node crypto library\n    return async function(pt) {\n      const en = new nodeCrypto.createCipheriv('aes-' + (key.length * 8) + '-cbc', key, zeroBlock);\n      const ct = en.update(pt);\n      return new Uint8Array(ct);\n    };\n  }\n\n  if (util.getWebCrypto()) {\n    try {\n      key = await webCrypto.importKey('raw', key, { name: 'AES-CBC', length: key.length * 8 }, false, ['encrypt']);\n      return async function(pt) {\n        const ct = await webCrypto.encrypt({ name: 'AES-CBC', iv: zeroBlock, length: blockLength * 8 }, key, pt);\n        return new Uint8Array(ct).subarray(0, ct.byteLength - blockLength);\n      };\n    } catch (err) {\n      // no 192 bit support in Chromium, which throws `OperationError`, see: https://www.chromium.org/blink/webcrypto#TOC-AES-support\n      if (err.name !== 'NotSupportedError' &&\n        !(key.length === 24 && err.name === 'OperationError')) {\n        throw err;\n      }\n      util.printDebugError('Browser did not support operation: ' + err.message);\n    }\n  }\n\n  return async function(pt) {\n    return nobleAesCbc(key, zeroBlock, { disablePadding: true }).encrypt(pt);\n  };\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2018 ProtonTech AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview This module implements AES-EAX en/decryption on top of\n * native AES-CTR using either the WebCrypto API or Node.js' crypto API.\n * @module crypto/mode/eax\n */\n\nimport { ctr as nobleAesCtr } from '@noble/ciphers/aes';\nimport CMAC from '../cmac';\nimport util from '../../util';\nimport enums from '../../enums';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\nconst Buffer = util.getNodeBuffer();\n\n\nconst blockLength = 16;\nconst ivLength = blockLength;\nconst tagLength = blockLength;\n\nconst zero = new Uint8Array(blockLength);\nconst one = new Uint8Array(blockLength); one[blockLength - 1] = 1;\nconst two = new Uint8Array(blockLength); two[blockLength - 1] = 2;\n\nasync function OMAC(key) {\n  const cmac = await CMAC(key);\n  return function(t, message) {\n    return cmac(util.concatUint8Array([t, message]));\n  };\n}\n\nasync function CTR(key) {\n  if (util.getNodeCrypto()) { // Node crypto library\n    return async function(pt, iv) {\n      const en = new nodeCrypto.createCipheriv('aes-' + (key.length * 8) + '-ctr', key, iv);\n      const ct = Buffer.concat([en.update(pt), en.final()]);\n      return new Uint8Array(ct);\n    };\n  }\n\n  if (util.getWebCrypto()) {\n    try {\n      const keyRef = await webCrypto.importKey('raw', key, { name: 'AES-CTR', length: key.length * 8 }, false, ['encrypt']);\n      return async function(pt, iv) {\n        const ct = await webCrypto.encrypt({ name: 'AES-CTR', counter: iv, length: blockLength * 8 }, keyRef, pt);\n        return new Uint8Array(ct);\n      };\n    } catch (err) {\n      // no 192 bit support in Chromium, which throws `OperationError`, see: https://www.chromium.org/blink/webcrypto#TOC-AES-support\n      if (err.name !== 'NotSupportedError' &&\n        !(key.length === 24 && err.name === 'OperationError')) {\n        throw err;\n      }\n      util.printDebugError('Browser did not support operation: ' + err.message);\n    }\n  }\n\n  return async function(pt, iv) {\n    return nobleAesCtr(key, iv).encrypt(pt);\n  };\n}\n\n\n/**\n * Class to en/decrypt using EAX mode.\n * @param {enums.symmetric} cipher - The symmetric cipher algorithm to use\n * @param {Uint8Array} key - The encryption key\n */\nasync function EAX(cipher, key) {\n  if (cipher !== enums.symmetric.aes128 &&\n    cipher !== enums.symmetric.aes192 &&\n    cipher !== enums.symmetric.aes256) {\n    throw new Error('EAX mode supports only AES cipher');\n  }\n\n  const [\n    omac,\n    ctr\n  ] = await Promise.all([\n    OMAC(key),\n    CTR(key)\n  ]);\n\n  return {\n    /**\n     * Encrypt plaintext input.\n     * @param {Uint8Array} plaintext - The cleartext input to be encrypted\n     * @param {Uint8Array} nonce - The nonce (16 bytes)\n     * @param {Uint8Array} adata - Associated data to sign\n     * @returns {Promise<Uint8Array>} The ciphertext output.\n     */\n    encrypt: async function(plaintext, nonce, adata) {\n      const [\n        omacNonce,\n        omacAdata\n      ] = await Promise.all([\n        omac(zero, nonce),\n        omac(one, adata)\n      ]);\n      const ciphered = await ctr(plaintext, omacNonce);\n      const omacCiphered = await omac(two, ciphered);\n      const tag = omacCiphered; // Assumes that omac(*).length === tagLength.\n      for (let i = 0; i < tagLength; i++) {\n        tag[i] ^= omacAdata[i] ^ omacNonce[i];\n      }\n      return util.concatUint8Array([ciphered, tag]);\n    },\n\n    /**\n     * Decrypt ciphertext input.\n     * @param {Uint8Array} ciphertext - The ciphertext input to be decrypted\n     * @param {Uint8Array} nonce - The nonce (16 bytes)\n     * @param {Uint8Array} adata - Associated data to verify\n     * @returns {Promise<Uint8Array>} The plaintext output.\n     */\n    decrypt: async function(ciphertext, nonce, adata) {\n      if (ciphertext.length < tagLength) throw new Error('Invalid EAX ciphertext');\n      const ciphered = ciphertext.subarray(0, -tagLength);\n      const ctTag = ciphertext.subarray(-tagLength);\n      const [\n        omacNonce,\n        omacAdata,\n        omacCiphered\n      ] = await Promise.all([\n        omac(zero, nonce),\n        omac(one, adata),\n        omac(two, ciphered)\n      ]);\n      const tag = omacCiphered; // Assumes that omac(*).length === tagLength.\n      for (let i = 0; i < tagLength; i++) {\n        tag[i] ^= omacAdata[i] ^ omacNonce[i];\n      }\n      if (!util.equalsUint8Array(ctTag, tag)) throw new Error('Authentication tag mismatch');\n      const plaintext = await ctr(ciphered, omacNonce);\n      return plaintext;\n    }\n  };\n}\n\n\n/**\n * Get EAX nonce as defined by {@link https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-04#section-5.16.1|RFC4880bis-04, section 5.16.1}.\n * @param {Uint8Array} iv - The initialization vector (16 bytes)\n * @param {Uint8Array} chunkIndex - The chunk index (8 bytes)\n */\nEAX.getNonce = function(iv, chunkIndex) {\n  const nonce = iv.slice();\n  for (let i = 0; i < chunkIndex.length; i++) {\n    nonce[8 + i] ^= chunkIndex[i];\n  }\n  return nonce;\n};\n\nEAX.blockLength = blockLength;\nEAX.ivLength = ivLength;\nEAX.tagLength = tagLength;\n\nexport default EAX;\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2018 ProtonTech AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview This module implements AES-OCB en/decryption.\n * @module crypto/mode/ocb\n */\n\nimport { cbc as nobleAesCbc } from '@noble/ciphers/aes';\nimport { getCipherParams } from '../cipher';\nimport util from '../../util';\n\nconst blockLength = 16;\nconst ivLength = 15;\n\n// https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-04#section-5.16.2:\n// While OCB [RFC7253] allows the authentication tag length to be of any\n// number up to 128 bits long, this document requires a fixed\n// authentication tag length of 128 bits (16 octets) for simplicity.\nconst tagLength = 16;\n\n\nfunction ntz(n) {\n  let ntz = 0;\n  for (let i = 1; (n & i) === 0; i <<= 1) {\n    ntz++;\n  }\n  return ntz;\n}\n\nfunction xorMut(S, T) {\n  for (let i = 0; i < S.length; i++) {\n    S[i] ^= T[i];\n  }\n  return S;\n}\n\nfunction xor(S, T) {\n  return xorMut(S.slice(), T);\n}\n\nconst zeroBlock = new Uint8Array(blockLength);\nconst one = new Uint8Array([1]);\n\n/**\n * Class to en/decrypt using OCB mode.\n * @param {enums.symmetric} cipher - The symmetric cipher algorithm to use\n * @param {Uint8Array} key - The encryption key\n */\nasync function OCB(cipher, key) {\n  const { keySize } = getCipherParams(cipher);\n  // sanity checks\n  if (!util.isAES(cipher) || key.length !== keySize) {\n    throw new Error('Unexpected algorithm or key size');\n  }\n\n  let maxNtz = 0;\n\n  // `encipher` and `decipher` cannot be async, since `crypt` shares state across calls,\n  // hence its execution cannot be broken up.\n  // As a result, WebCrypto cannot currently be used for `encipher`.\n  const encipher = block => nobleAesCbc(key, zeroBlock, { disablePadding: true }).encrypt(block);\n  const decipher = block => nobleAesCbc(key, zeroBlock, { disablePadding: true }).decrypt(block);\n  let mask;\n\n  constructKeyVariables(cipher, key);\n\n  function constructKeyVariables() {\n    const mask_x = encipher(zeroBlock);\n    const mask_$ = util.double(mask_x);\n    mask = [];\n    mask[0] = util.double(mask_$);\n\n\n    mask.x = mask_x;\n    mask.$ = mask_$;\n  }\n\n  function extendKeyVariables(text, adata) {\n    const newMaxNtz = util.nbits(Math.max(text.length, adata.length) / blockLength | 0) - 1;\n    for (let i = maxNtz + 1; i <= newMaxNtz; i++) {\n      mask[i] = util.double(mask[i - 1]);\n    }\n    maxNtz = newMaxNtz;\n  }\n\n  function hash(adata) {\n    if (!adata.length) {\n      // Fast path\n      return zeroBlock;\n    }\n\n    //\n    // Consider A as a sequence of 128-bit blocks\n    //\n    const m = adata.length / blockLength | 0;\n\n    const offset = new Uint8Array(blockLength);\n    const sum = new Uint8Array(blockLength);\n    for (let i = 0; i < m; i++) {\n      xorMut(offset, mask[ntz(i + 1)]);\n      xorMut(sum, encipher(xor(offset, adata)));\n      adata = adata.subarray(blockLength);\n    }\n\n    //\n    // Process any final partial block; compute final hash value\n    //\n    if (adata.length) {\n      xorMut(offset, mask.x);\n\n      const cipherInput = new Uint8Array(blockLength);\n      cipherInput.set(adata, 0);\n      cipherInput[adata.length] = 0b10000000;\n      xorMut(cipherInput, offset);\n\n      xorMut(sum, encipher(cipherInput));\n    }\n\n    return sum;\n  }\n\n  /**\n   * Encrypt/decrypt data.\n   * @param {encipher|decipher} fn - Encryption/decryption block cipher function\n   * @param {Uint8Array} text - The cleartext or ciphertext (without tag) input\n   * @param {Uint8Array} nonce - The nonce (15 bytes)\n   * @param {Uint8Array} adata - Associated data to sign\n   * @returns {Promise<Uint8Array>} The ciphertext or plaintext output, with tag appended in both cases.\n   */\n  function crypt(fn, text, nonce, adata) {\n    //\n    // Consider P as a sequence of 128-bit blocks\n    //\n    const m = text.length / blockLength | 0;\n\n    //\n    // Key-dependent variables\n    //\n    extendKeyVariables(text, adata);\n\n    //\n    // Nonce-dependent and per-encryption variables\n    //\n    //    Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N\n    // Note: We assume here that tagLength mod 16 == 0.\n    const paddedNonce = util.concatUint8Array([zeroBlock.subarray(0, ivLength - nonce.length), one, nonce]);\n    //    bottom = str2num(Nonce[123..128])\n    const bottom = paddedNonce[blockLength - 1] & 0b111111;\n    //    Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6))\n    paddedNonce[blockLength - 1] &= 0b11000000;\n    const kTop = encipher(paddedNonce);\n    //    Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72])\n    const stretched = util.concatUint8Array([kTop, xor(kTop.subarray(0, 8), kTop.subarray(1, 9))]);\n    //    Offset_0 = Stretch[1+bottom..128+bottom]\n    const offset = util.shiftRight(stretched.subarray(0 + (bottom >> 3), 17 + (bottom >> 3)), 8 - (bottom & 7)).subarray(1);\n    //    Checksum_0 = zeros(128)\n    const checksum = new Uint8Array(blockLength);\n\n    const ct = new Uint8Array(text.length + tagLength);\n\n    //\n    // Process any whole blocks\n    //\n    let i;\n    let pos = 0;\n    for (i = 0; i < m; i++) {\n      // Offset_i = Offset_{i-1} xor L_{ntz(i)}\n      xorMut(offset, mask[ntz(i + 1)]);\n      // C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i)\n      // P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i)\n      ct.set(xorMut(fn(xor(offset, text)), offset), pos);\n      // Checksum_i = Checksum_{i-1} xor P_i\n      xorMut(checksum, fn === encipher ? text : ct.subarray(pos));\n\n      text = text.subarray(blockLength);\n      pos += blockLength;\n    }\n\n    //\n    // Process any final partial block and compute raw tag\n    //\n    if (text.length) {\n      // Offset_* = Offset_m xor L_*\n      xorMut(offset, mask.x);\n      // Pad = ENCIPHER(K, Offset_*)\n      const padding = encipher(offset);\n      // C_* = P_* xor Pad[1..bitlen(P_*)]\n      ct.set(xor(text, padding), pos);\n\n      // Checksum_* = Checksum_m xor (P_* || 1 || new Uint8Array(127-bitlen(P_*)))\n      const xorInput = new Uint8Array(blockLength);\n      xorInput.set(fn === encipher ? text : ct.subarray(pos, -tagLength), 0);\n      xorInput[text.length] = 0b10000000;\n      xorMut(checksum, xorInput);\n      pos += text.length;\n    }\n    // Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)\n    const tag = xorMut(encipher(xorMut(xorMut(checksum, offset), mask.$)), hash(adata));\n\n    //\n    // Assemble ciphertext\n    //\n    // C = C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]\n    ct.set(tag, pos);\n    return ct;\n  }\n\n\n  return {\n    /**\n     * Encrypt plaintext input.\n     * @param {Uint8Array} plaintext - The cleartext input to be encrypted\n     * @param {Uint8Array} nonce - The nonce (15 bytes)\n     * @param {Uint8Array} adata - Associated data to sign\n     * @returns {Promise<Uint8Array>} The ciphertext output.\n     */\n    encrypt: async function(plaintext, nonce, adata) {\n      return crypt(encipher, plaintext, nonce, adata);\n    },\n\n    /**\n     * Decrypt ciphertext input.\n     * @param {Uint8Array} ciphertext - The ciphertext input to be decrypted\n     * @param {Uint8Array} nonce - The nonce (15 bytes)\n     * @param {Uint8Array} adata - Associated data to sign\n     * @returns {Promise<Uint8Array>} The ciphertext output.\n     */\n    decrypt: async function(ciphertext, nonce, adata) {\n      if (ciphertext.length < tagLength) throw new Error('Invalid OCB ciphertext');\n\n      const tag = ciphertext.subarray(-tagLength);\n      ciphertext = ciphertext.subarray(0, -tagLength);\n\n      const crypted = crypt(decipher, ciphertext, nonce, adata);\n      // if (Tag[1..TAGLEN] == T)\n      if (util.equalsUint8Array(tag, crypted.subarray(-tagLength))) {\n        return crypted.subarray(0, -tagLength);\n      }\n      throw new Error('Authentication tag mismatch');\n    }\n  };\n}\n\n\n/**\n * Get OCB nonce as defined by {@link https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-04#section-5.16.2|RFC4880bis-04, section 5.16.2}.\n * @param {Uint8Array} iv - The initialization vector (15 bytes)\n * @param {Uint8Array} chunkIndex - The chunk index (8 bytes)\n */\nOCB.getNonce = function(iv, chunkIndex) {\n  const nonce = iv.slice();\n  for (let i = 0; i < chunkIndex.length; i++) {\n    nonce[7 + i] ^= chunkIndex[i];\n  }\n  return nonce;\n};\n\nOCB.blockLength = blockLength;\nOCB.ivLength = ivLength;\nOCB.tagLength = tagLength;\n\nexport default OCB;\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2016 Tankred Hase\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview This module wraps native AES-GCM en/decryption for both\n * the WebCrypto api as well as node.js' crypto api.\n * @module crypto/mode/gcm\n */\n\nimport { gcm as nobleAesGcm } from '@noble/ciphers/aes';\nimport util from '../../util';\nimport enums from '../../enums';\n\nconst webCrypto = util.getWebCrypto();\nconst nodeCrypto = util.getNodeCrypto();\nconst Buffer = util.getNodeBuffer();\n\nconst blockLength = 16;\nconst ivLength = 12; // size of the IV in bytes\nconst tagLength = 16; // size of the tag in bytes\nconst ALGO = 'AES-GCM';\n\n/**\n * Class to en/decrypt using GCM mode.\n * @param {enums.symmetric} cipher - The symmetric cipher algorithm to use\n * @param {Uint8Array} key - The encryption key\n */\nasync function GCM(cipher, key) {\n  if (cipher !== enums.symmetric.aes128 &&\n    cipher !== enums.symmetric.aes192 &&\n    cipher !== enums.symmetric.aes256) {\n    throw new Error('GCM mode supports only AES cipher');\n  }\n\n  if (util.getNodeCrypto()) { // Node crypto library\n    return {\n      encrypt: async function(pt, iv, adata = new Uint8Array()) {\n        const en = new nodeCrypto.createCipheriv('aes-' + (key.length * 8) + '-gcm', key, iv);\n        en.setAAD(adata);\n        const ct = Buffer.concat([en.update(pt), en.final(), en.getAuthTag()]); // append auth tag to ciphertext\n        return new Uint8Array(ct);\n      },\n\n      decrypt: async function(ct, iv, adata = new Uint8Array()) {\n        const de = new nodeCrypto.createDecipheriv('aes-' + (key.length * 8) + '-gcm', key, iv);\n        de.setAAD(adata);\n        de.setAuthTag(ct.slice(ct.length - tagLength, ct.length)); // read auth tag at end of ciphertext\n        const pt = Buffer.concat([de.update(ct.slice(0, ct.length - tagLength)), de.final()]);\n        return new Uint8Array(pt);\n      }\n    };\n  }\n\n  if (util.getWebCrypto()) {\n    try {\n      const _key = await webCrypto.importKey('raw', key, { name: ALGO }, false, ['encrypt', 'decrypt']);\n      // Safari 13 and Safari iOS 14 does not support GCM-en/decrypting empty messages\n      const webcryptoEmptyMessagesUnsupported = navigator.userAgent.match(/Version\\/13\\.\\d(\\.\\d)* Safari/) ||\n        navigator.userAgent.match(/Version\\/(13|14)\\.\\d(\\.\\d)* Mobile\\/\\S* Safari/);\n      return {\n        encrypt: async function(pt, iv, adata = new Uint8Array()) {\n          if (webcryptoEmptyMessagesUnsupported && !pt.length) {\n            return nobleAesGcm(key, iv, adata).encrypt(pt);\n          }\n          const ct = await webCrypto.encrypt({ name: ALGO, iv, additionalData: adata, tagLength: tagLength * 8 }, _key, pt);\n          return new Uint8Array(ct);\n        },\n\n        decrypt: async function(ct, iv, adata = new Uint8Array()) {\n          if (webcryptoEmptyMessagesUnsupported && ct.length === tagLength) {\n            return nobleAesGcm(key, iv, adata).decrypt(ct);\n          }\n          try {\n            const pt = await webCrypto.decrypt({ name: ALGO, iv, additionalData: adata, tagLength: tagLength * 8 }, _key, ct);\n            return new Uint8Array(pt);\n          } catch (e) {\n            if (e.name === 'OperationError') {\n              throw new Error('Authentication tag mismatch');\n            }\n          }\n        }\n      };\n    } catch (err) {\n      // no 192 bit support in Chromium, which throws `OperationError`, see: https://www.chromium.org/blink/webcrypto#TOC-AES-support\n      if (err.name !== 'NotSupportedError' &&\n        !(key.length === 24 && err.name === 'OperationError')) {\n        throw err;\n      }\n      util.printDebugError('Browser did not support operation: ' + err.message);\n    }\n  }\n\n  return {\n    encrypt: async function(pt, iv, adata) {\n      return nobleAesGcm(key, iv, adata).encrypt(pt);\n    },\n\n    decrypt: async function(ct, iv, adata) {\n      return nobleAesGcm(key, iv, adata).decrypt(ct);\n    }\n  };\n}\n\n\n/**\n * Get GCM nonce. Note: this operation is not defined by the standard.\n * A future version of the standard may define GCM mode differently,\n * hopefully under a different ID (we use Private/Experimental algorithm\n * ID 100) so that we can maintain backwards compatibility.\n * @param {Uint8Array} iv - The initialization vector (12 bytes)\n * @param {Uint8Array} chunkIndex - The chunk index (8 bytes)\n */\nGCM.getNonce = function(iv, chunkIndex) {\n  const nonce = iv.slice();\n  for (let i = 0; i < chunkIndex.length; i++) {\n    nonce[4 + i] ^= chunkIndex[i];\n  }\n  return nonce;\n};\n\nGCM.blockLength = blockLength;\nGCM.ivLength = ivLength;\nGCM.tagLength = tagLength;\n\nexport default GCM;\n","/**\n * @fileoverview Cipher modes\n * @module crypto/cipherMode\n */\n\nexport * as cfb from './cfb';\nimport eax from './eax';\nimport ocb from './ocb';\nimport gcm from './gcm';\nimport enums from '../../enums';\n\n/**\n* Get implementation of the given AEAD mode\n* @param {enums.aead} algo\n* @param {Boolean} [acceptExperimentalGCM] - whether to allow the non-standard, legacy `experimentalGCM` algo\n* @returns {Object}\n* @throws {Error} on invalid algo\n*/\nexport function getAEADMode(algo, acceptExperimentalGCM = false) {\n  switch (algo) {\n    case enums.aead.eax:\n      return eax;\n    case enums.aead.ocb:\n      return ocb;\n    case enums.aead.gcm:\n      return gcm;\n    case enums.aead.experimentalGCM:\n      if (!acceptExperimentalGCM) {\n        throw new Error('Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead');\n      }\n      return gcm;\n    default:\n      throw new Error('Unsupported AEAD mode');\n  }\n}\n","/**\n * @fileoverview Provides functions for asymmetric signing and signature verification\n * @module crypto/signature\n */\n\nimport { elliptic, rsa, dsa } from './public_key';\nimport enums from '../enums';\nimport util from '../util';\nimport { UnsupportedError } from '../packet/packet';\n\n/**\n * Parse signature in binary form to get the parameters.\n * The returned values are only padded for EdDSA, since in the other cases their expected length\n * depends on the key params, hence we delegate the padding to the signature verification function.\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.1|RFC 4880 9.1}\n * See {@link https://tools.ietf.org/html/rfc4880#section-5.2.2|RFC 4880 5.2.2.}\n * @param {module:enums.publicKey} algo - Public key algorithm\n * @param {Uint8Array} signature - Data for which the signature was created\n * @returns {Promise<Object>} True if signature is valid.\n * @async\n */\nexport function parseSignatureParams(algo, signature) {\n  let read = 0;\n  switch (algo) {\n    // Algorithm-Specific Fields for RSA signatures:\n    // -  MPI of RSA signature value m**d mod n.\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaSign: {\n      const s = util.readMPI(signature.subarray(read)); read += s.length + 2;\n      // The signature needs to be the same length as the public key modulo n.\n      // We pad s on signature verification, where we have access to n.\n      return { read, signatureParams: { s } };\n    }\n    // Algorithm-Specific Fields for DSA or ECDSA signatures:\n    // -  MPI of DSA or ECDSA value r.\n    // -  MPI of DSA or ECDSA value s.\n    case enums.publicKey.dsa:\n    case enums.publicKey.ecdsa:\n    {\n      // If the signature payload sizes are unexpected, we will throw on verification,\n      // where we also have access to the OID curve from the key.\n      const r = util.readMPI(signature.subarray(read)); read += r.length + 2;\n      const s = util.readMPI(signature.subarray(read)); read += s.length + 2;\n      return { read, signatureParams: { r, s } };\n    }\n    // Algorithm-Specific Fields for legacy EdDSA signatures:\n    // -  MPI of an EC point r.\n    // -  EdDSA value s, in MPI, in the little endian representation\n    case enums.publicKey.eddsaLegacy: {\n      // Only Curve25519Legacy is supported (no Curve448Legacy), but the relevant checks are done on key parsing and signature\n      // verification: if the signature payload sizes are unexpected, we will throw on verification,\n      // where we also have access to the OID curve from the key.\n      const r = util.readMPI(signature.subarray(read)); read += r.length + 2;\n      const s = util.readMPI(signature.subarray(read)); read += s.length + 2;\n      return { read, signatureParams: { r, s } };\n    }\n    // Algorithm-Specific Fields for Ed25519 signatures:\n    // - 64 octets of the native signature\n    // Algorithm-Specific Fields for Ed448 signatures:\n    // - 114 octets of the native signature\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448: {\n      const rsSize = 2 * elliptic.eddsa.getPayloadSize(algo);\n      const RS = util.readExactSubarray(signature, read, read + rsSize); read += RS.length;\n      return { read, signatureParams: { RS } };\n    }\n\n    default:\n      throw new UnsupportedError('Unknown signature algorithm.');\n  }\n}\n\n/**\n * Verifies the signature provided for data using specified algorithms and public key parameters.\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.1|RFC 4880 9.1}\n * and {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC 4880 9.4}\n * for public key and hash algorithms.\n * @param {module:enums.publicKey} algo - Public key algorithm\n * @param {module:enums.hash} hashAlgo - Hash algorithm\n * @param {Object} signature - Named algorithm-specific signature parameters\n * @param {Object} publicParams - Algorithm-specific public key parameters\n * @param {Uint8Array} data - Data for which the signature was created\n * @param {Uint8Array} hashed - The hashed data\n * @returns {Promise<Boolean>} True if signature is valid.\n * @async\n */\nexport async function verify(algo, hashAlgo, signature, publicParams, data, hashed) {\n  switch (algo) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaSign: {\n      const { n, e } = publicParams;\n      const s = util.leftPad(signature.s, n.length); // padding needed for webcrypto and node crypto\n      return rsa.verify(hashAlgo, data, s, n, e, hashed);\n    }\n    case enums.publicKey.dsa: {\n      const { g, p, q, y } = publicParams;\n      const { r, s } = signature; // no need to pad, since we always handle them as BigIntegers\n      return dsa.verify(hashAlgo, r, s, hashed, g, p, q, y);\n    }\n    case enums.publicKey.ecdsa: {\n      const { oid, Q } = publicParams;\n      const curveSize = new elliptic.CurveWithOID(oid).payloadSize;\n      // padding needed for webcrypto\n      const r = util.leftPad(signature.r, curveSize);\n      const s = util.leftPad(signature.s, curveSize);\n      return elliptic.ecdsa.verify(oid, hashAlgo, { r, s }, data, Q, hashed);\n    }\n    case enums.publicKey.eddsaLegacy: {\n      const { oid, Q } = publicParams;\n      const curveSize = new elliptic.CurveWithOID(oid).payloadSize;\n      // When dealing little-endian MPI data, we always need to left-pad it, as done with big-endian values:\n      // https://www.ietf.org/archive/id/draft-ietf-openpgp-rfc4880bis-10.html#section-3.2-9\n      const r = util.leftPad(signature.r, curveSize);\n      const s = util.leftPad(signature.s, curveSize);\n      return elliptic.eddsaLegacy.verify(oid, hashAlgo, { r, s }, data, Q, hashed);\n    }\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448: {\n      const { A } = publicParams;\n      return elliptic.eddsa.verify(algo, hashAlgo, signature, data, A, hashed);\n    }\n    default:\n      throw new Error('Unknown signature algorithm.');\n  }\n}\n\n/**\n * Creates a signature on data using specified algorithms and private key parameters.\n * See {@link https://tools.ietf.org/html/rfc4880#section-9.1|RFC 4880 9.1}\n * and {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC 4880 9.4}\n * for public key and hash algorithms.\n * @param {module:enums.publicKey} algo - Public key algorithm\n * @param {module:enums.hash} hashAlgo - Hash algorithm\n * @param {Object} publicKeyParams - Algorithm-specific public and private key parameters\n * @param {Object} privateKeyParams - Algorithm-specific public and private key parameters\n * @param {Uint8Array} data - Data to be signed\n * @param {Uint8Array} hashed - The hashed data\n * @returns {Promise<Object>} Signature                      Object containing named signature parameters.\n * @async\n */\nexport async function sign(algo, hashAlgo, publicKeyParams, privateKeyParams, data, hashed) {\n  if (!publicKeyParams || !privateKeyParams) {\n    throw new Error('Missing key parameters');\n  }\n  switch (algo) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaSign: {\n      const { n, e } = publicKeyParams;\n      const { d, p, q, u } = privateKeyParams;\n      const s = await rsa.sign(hashAlgo, data, n, e, d, p, q, u, hashed);\n      return { s };\n    }\n    case enums.publicKey.dsa: {\n      const { g, p, q } = publicKeyParams;\n      const { x } = privateKeyParams;\n      return dsa.sign(hashAlgo, hashed, g, p, q, x);\n    }\n    case enums.publicKey.elgamal:\n      throw new Error('Signing with Elgamal is not defined in the OpenPGP standard.');\n    case enums.publicKey.ecdsa: {\n      const { oid, Q } = publicKeyParams;\n      const { d } = privateKeyParams;\n      return elliptic.ecdsa.sign(oid, hashAlgo, data, Q, d, hashed);\n    }\n    case enums.publicKey.eddsaLegacy: {\n      const { oid, Q } = publicKeyParams;\n      const { seed } = privateKeyParams;\n      return elliptic.eddsaLegacy.sign(oid, hashAlgo, data, Q, seed, hashed);\n    }\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448: {\n      const { A } = publicKeyParams;\n      const { seed } = privateKeyParams;\n      return elliptic.eddsa.sign(algo, hashAlgo, data, A, seed, hashed);\n    }\n    default:\n      throw new Error('Unknown signature algorithm.');\n  }\n}\n","import defaultConfig from '../../config';\nimport enums from '../../enums';\nimport util from '../../util';\nimport { getRandomBytes } from '../../crypto';\n\nconst ARGON2_TYPE = 0x02; // id\nconst ARGON2_VERSION = 0x13;\nconst ARGON2_SALT_SIZE = 16;\n\nexport class Argon2OutOfMemoryError extends Error {\n  constructor(...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, Argon2OutOfMemoryError);\n    }\n\n    this.name = 'Argon2OutOfMemoryError';\n  }\n}\n\n// cache argon wasm module\nlet loadArgonWasmModule;\nlet argon2Promise;\n// reload wasm module above this treshold, to deallocated used memory\nconst ARGON2_WASM_MEMORY_THRESHOLD_RELOAD = 2 << 19;\n\nclass Argon2S2K {\n  /**\n  * @param {Object} [config] - Full configuration, defaults to openpgp.config\n  */\n  constructor(config = defaultConfig) {\n    const { passes, parallelism, memoryExponent } = config.s2kArgon2Params;\n\n    this.type = 'argon2';\n    /**\n     * 16 bytes of salt\n     * @type {Uint8Array}\n     */\n    this.salt = null;\n    /**\n     * number of passes\n     * @type {Integer}\n     */\n    this.t = passes;\n    /**\n     * degree of parallelism (lanes)\n     * @type {Integer}\n     */\n    this.p = parallelism;\n    /**\n     * exponent indicating memory size\n     * @type {Integer}\n     */\n    this.encodedM = memoryExponent;\n  }\n\n  generateSalt() {\n    this.salt = getRandomBytes(ARGON2_SALT_SIZE);\n  }\n\n  /**\n  * Parsing function for argon2 string-to-key specifier.\n  * @param {Uint8Array} bytes - Payload of argon2 string-to-key specifier\n  * @returns {Integer} Actual length of the object.\n  */\n  read(bytes) {\n    let i = 0;\n\n    this.salt = bytes.subarray(i, i + 16);\n    i += 16;\n\n    this.t = bytes[i++];\n    this.p = bytes[i++];\n    this.encodedM = bytes[i++]; // memory size exponent, one-octect\n\n    return i;\n  }\n\n  /**\n  * Serializes s2k information\n  * @returns {Uint8Array} Binary representation of s2k.\n  */\n  write() {\n    const arr = [\n      new Uint8Array([enums.write(enums.s2k, this.type)]),\n      this.salt,\n      new Uint8Array([this.t, this.p, this.encodedM])\n    ];\n\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n  * Produces a key using the specified passphrase and the defined\n  * hashAlgorithm\n  * @param {String} passphrase - Passphrase containing user input\n  * @returns {Promise<Uint8Array>} Produced key with a length corresponding to `keySize`\n  * @throws {Argon2OutOfMemoryError|Errors}\n  * @async\n  */\n  async produceKey(passphrase, keySize) {\n    const decodedM = 2 << (this.encodedM - 1);\n\n    try {\n      // on first load, the argon2 lib is imported and the WASM module is initialized.\n      // the two steps need to be atomic to avoid race conditions causing multiple wasm modules\n      // being loaded when `argon2Promise` is not initialized.\n      loadArgonWasmModule = loadArgonWasmModule || (await import('argon2id')).default;\n      argon2Promise = argon2Promise || loadArgonWasmModule();\n\n      // important to keep local ref to argon2 in case the module is reloaded by another instance\n      const argon2 = await argon2Promise;\n\n      const passwordBytes = util.encodeUTF8(passphrase);\n      const hash = argon2({\n        version: ARGON2_VERSION,\n        type: ARGON2_TYPE,\n        password: passwordBytes,\n        salt: this.salt,\n        tagLength: keySize,\n        memorySize: decodedM,\n        parallelism: this.p,\n        passes: this.t\n      });\n\n      // a lot of memory was used, reload to deallocate\n      if (decodedM > ARGON2_WASM_MEMORY_THRESHOLD_RELOAD) {\n        // it will be awaited if needed at the next `produceKey` invocation\n        argon2Promise = loadArgonWasmModule();\n        argon2Promise.catch(() => {});\n      }\n      return hash;\n    } catch (e) {\n      if (e.message && (\n        e.message.includes('Unable to grow instance memory') || // Chrome\n        e.message.includes('failed to grow memory') || // Firefox\n        e.message.includes('WebAssembly.Memory.grow') || // Safari\n        e.message.includes('Out of memory') // Safari iOS\n      )) {\n        throw new Argon2OutOfMemoryError('Could not allocate required memory for Argon2');\n      } else {\n        throw e;\n      }\n    }\n  }\n}\n\nexport default Argon2S2K;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * Implementation of the String-to-key specifier\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-3.7|RFC4880 3.7}:\n * String-to-key (S2K) specifiers are used to convert passphrase strings\n * into symmetric-key encryption/decryption keys.  They are used in two\n * places, currently: to encrypt the secret part of private keys in the\n * private keyring, and to convert passphrases to encryption keys for\n * symmetrically encrypted messages.\n * @module type/s2k\n */\n\nimport defaultConfig from '../../config';\nimport { getRandomBytes, computeDigest } from '../../crypto';\nimport enums from '../../enums';\nimport { UnsupportedError } from '../../packet/packet';\nimport util from '../../util';\n\nclass GenericS2K {\n  /**\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(s2kType, config = defaultConfig) {\n    /**\n     * Hash function identifier, or 0 for gnu-dummy keys\n     * @type {module:enums.hash | 0}\n     */\n    this.algorithm = enums.hash.sha256;\n    /**\n     * enums.s2k identifier or 'gnu-dummy'\n     * @type {String}\n     */\n    this.type = enums.read(enums.s2k, s2kType);\n    /** @type {Integer} */\n    this.c = config.s2kIterationCountByte;\n    /** Eight bytes of salt in a binary string.\n     * @type {Uint8Array}\n     */\n    this.salt = null;\n  }\n\n  generateSalt() {\n    switch (this.type) {\n      case 'salted':\n      case 'iterated':\n        this.salt = getRandomBytes(8);\n    }\n  }\n\n  getCount() {\n    // Exponent bias, defined in RFC4880\n    const expbias = 6;\n\n    return (16 + (this.c & 15)) << ((this.c >> 4) + expbias);\n  }\n\n  /**\n   * Parsing function for a string-to-key specifier ({@link https://tools.ietf.org/html/rfc4880#section-3.7|RFC 4880 3.7}).\n   * @param {Uint8Array} bytes - Payload of string-to-key specifier\n   * @returns {Integer} Actual length of the object.\n   */\n  read(bytes) {\n    let i = 0;\n    this.algorithm = bytes[i++];\n\n    switch (this.type) {\n      case 'simple':\n        break;\n\n      case 'salted':\n        this.salt = bytes.subarray(i, i + 8);\n        i += 8;\n        break;\n\n      case 'iterated':\n        this.salt = bytes.subarray(i, i + 8);\n        i += 8;\n\n        // Octet 10: count, a one-octet, coded value\n        this.c = bytes[i++];\n        break;\n\n      case 'gnu':\n        if (util.uint8ArrayToString(bytes.subarray(i, i + 3)) === 'GNU') {\n          i += 3; // GNU\n          const gnuExtType = 1000 + bytes[i++];\n          if (gnuExtType === 1001) {\n            this.type = 'gnu-dummy';\n            // GnuPG extension mode 1001 -- don't write secret key at all\n          } else {\n            throw new UnsupportedError('Unknown s2k gnu protection mode.');\n          }\n        } else {\n          throw new UnsupportedError('Unknown s2k type.');\n        }\n        break;\n\n      default:\n        throw new UnsupportedError('Unknown s2k type.'); // unreachable\n    }\n\n    return i;\n  }\n\n  /**\n   * Serializes s2k information\n   * @returns {Uint8Array} Binary representation of s2k.\n   */\n  write() {\n    if (this.type === 'gnu-dummy') {\n      return new Uint8Array([101, 0, ...util.stringToUint8Array('GNU'), 1]);\n    }\n    const arr = [new Uint8Array([enums.write(enums.s2k, this.type), this.algorithm])];\n\n    switch (this.type) {\n      case 'simple':\n        break;\n      case 'salted':\n        arr.push(this.salt);\n        break;\n      case 'iterated':\n        arr.push(this.salt);\n        arr.push(new Uint8Array([this.c]));\n        break;\n      case 'gnu':\n        throw new Error('GNU s2k type not supported.');\n      default:\n        throw new Error('Unknown s2k type.');\n    }\n\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n   * Produces a key using the specified passphrase and the defined\n   * hashAlgorithm\n   * @param {String} passphrase - Passphrase containing user input\n   * @returns {Promise<Uint8Array>} Produced key with a length corresponding to.\n   * hashAlgorithm hash length\n   * @async\n   */\n  async produceKey(passphrase, numBytes) {\n    passphrase = util.encodeUTF8(passphrase);\n\n    const arr = [];\n    let rlength = 0;\n\n    let prefixlen = 0;\n    while (rlength < numBytes) {\n      let toHash;\n      switch (this.type) {\n        case 'simple':\n          toHash = util.concatUint8Array([new Uint8Array(prefixlen), passphrase]);\n          break;\n        case 'salted':\n          toHash = util.concatUint8Array([new Uint8Array(prefixlen), this.salt, passphrase]);\n          break;\n        case 'iterated': {\n          const data = util.concatUint8Array([this.salt, passphrase]);\n          let datalen = data.length;\n          const count = Math.max(this.getCount(), datalen);\n          toHash = new Uint8Array(prefixlen + count);\n          toHash.set(data, prefixlen);\n          for (let pos = prefixlen + datalen; pos < count; pos += datalen, datalen *= 2) {\n            toHash.copyWithin(pos, prefixlen, pos);\n          }\n          break;\n        }\n        case 'gnu':\n          throw new Error('GNU s2k type not supported.');\n        default:\n          throw new Error('Unknown s2k type.');\n      }\n      const result = await computeDigest(this.algorithm, toHash);\n      arr.push(result);\n      rlength += result.length;\n      prefixlen++;\n    }\n\n    return util.concatUint8Array(arr).subarray(0, numBytes);\n  }\n}\n\nexport default GenericS2K;\n","import defaultConfig from '../../config';\nimport Argon2S2K, { Argon2OutOfMemoryError } from './argon2';\nimport GenericS2K from './generic';\nimport enums from '../../enums';\nimport { UnsupportedError } from '../../packet/packet';\n\nconst allowedS2KTypesForEncryption = new Set([enums.s2k.argon2, enums.s2k.iterated]);\n\n/**\n * Instantiate a new S2K instance of the given type\n * @param {module:enums.s2k} type\n * @oaram {Object} [config]\n * @returns {Object} New s2k object\n * @throws {Error} for unknown or unsupported types\n */\nexport function newS2KFromType(type, config = defaultConfig) {\n  switch (type) {\n    case enums.s2k.argon2:\n      return new Argon2S2K(config);\n    case enums.s2k.iterated:\n    case enums.s2k.gnu:\n    case enums.s2k.salted:\n    case enums.s2k.simple:\n      return new GenericS2K(type, config);\n    default:\n      throw new UnsupportedError('Unsupported S2K type');\n  }\n}\n\n/**\n * Instantiate a new S2K instance based on the config settings\n * @oaram {Object} config\n * @returns {Object} New s2k object\n * @throws {Error} for unknown or unsupported types\n */\nexport function newS2KFromConfig(config) {\n  const { s2kType } = config;\n\n  if (!allowedS2KTypesForEncryption.has(s2kType)) {\n    throw new Error('The provided `config.s2kType` value is not allowed');\n  }\n\n  return newS2KFromType(s2kType, config);\n}\n\nexport { Argon2OutOfMemoryError };\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { isArrayStream, passiveClone as streamPassiveClone, parse as streamParse, readToEnd as streamReadToEnd } from '@openpgp/web-stream-tools';\nimport enums from '../enums';\nimport util from '../util';\n\n/**\n * Implementation of the Literal Data Packet (Tag 11)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.9|RFC4880 5.9}:\n * A Literal Data packet contains the body of a message; data that is not to be\n * further interpreted.\n */\nclass LiteralDataPacket {\n  static get tag() {\n    return enums.packet.literalData;\n  }\n\n  /**\n   * @param {Date} date - The creation date of the literal package\n   */\n  constructor(date = new Date()) {\n    this.format = enums.literal.utf8; // default format for literal data packets\n    this.date = util.normalizeDate(date);\n    this.text = null; // textual data representation\n    this.data = null; // literal data representation\n    this.filename = '';\n  }\n\n  /**\n   * Set the packet data to a javascript native string, end of line\n   * will be normalized to \\r\\n and by default text is converted to UTF8\n   * @param {String | ReadableStream<String>} text - Any native javascript string\n   * @param {enums.literal} [format] - The format of the string of bytes\n   */\n  setText(text, format = enums.literal.utf8) {\n    this.format = format;\n    this.text = text;\n    this.data = null;\n  }\n\n  /**\n   * Returns literal data packets as native JavaScript string\n   * with normalized end of line to \\n\n   * @param {Boolean} [clone] - Whether to return a clone so that getBytes/getText can be called again\n   * @returns {String | ReadableStream<String>} Literal data as text.\n   */\n  getText(clone = false) {\n    if (this.text === null || util.isStream(this.text)) { // Assume that this.text has been read\n      this.text = util.decodeUTF8(util.nativeEOL(this.getBytes(clone)));\n    }\n    return this.text;\n  }\n\n  /**\n   * Set the packet data to value represented by the provided string of bytes.\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes - The string of bytes\n   * @param {enums.literal} format - The format of the string of bytes\n   */\n  setBytes(bytes, format) {\n    this.format = format;\n    this.data = bytes;\n    this.text = null;\n  }\n\n\n  /**\n   * Get the byte sequence representing the literal packet data\n   * @param {Boolean} [clone] - Whether to return a clone so that getBytes/getText can be called again\n   * @returns {Uint8Array | ReadableStream<Uint8Array>} A sequence of bytes.\n   */\n  getBytes(clone = false) {\n    if (this.data === null) {\n      // encode UTF8 and normalize EOL to \\r\\n\n      this.data = util.canonicalizeEOL(util.encodeUTF8(this.text));\n    }\n    if (clone) {\n      return streamPassiveClone(this.data);\n    }\n    return this.data;\n  }\n\n\n  /**\n   * Sets the filename of the literal packet data\n   * @param {String} filename - Any native javascript string\n   */\n  setFilename(filename) {\n    this.filename = filename;\n  }\n\n\n  /**\n   * Get the filename of the literal packet data\n   * @returns {String} Filename.\n   */\n  getFilename() {\n    return this.filename;\n  }\n\n  /**\n   * Parsing function for a literal data packet (tag 11).\n   *\n   * @param {Uint8Array | ReadableStream<Uint8Array>} input - Payload of a tag 11 packet\n   * @returns {Promise<LiteralDataPacket>} Object representation.\n   * @async\n   */\n  async read(bytes) {\n    await streamParse(bytes, async reader => {\n      // - A one-octet field that describes how the data is formatted.\n      const format = await reader.readByte(); // enums.literal\n\n      const filename_len = await reader.readByte();\n      this.filename = util.decodeUTF8(await reader.readBytes(filename_len));\n\n      this.date = util.readDate(await reader.readBytes(4));\n\n      let data = reader.remainder();\n      if (isArrayStream(data)) data = await streamReadToEnd(data);\n      this.setBytes(data, format);\n    });\n  }\n\n  /**\n   * Creates a Uint8Array representation of the packet, excluding the data\n   *\n   * @returns {Uint8Array} Uint8Array representation of the packet.\n   */\n  writeHeader() {\n    const filename = util.encodeUTF8(this.filename);\n    const filename_length = new Uint8Array([filename.length]);\n\n    const format = new Uint8Array([this.format]);\n    const date = util.writeDate(this.date);\n\n    return util.concatUint8Array([format, filename_length, filename, date]);\n  }\n\n  /**\n   * Creates a Uint8Array representation of the packet\n   *\n   * @returns {Uint8Array | ReadableStream<Uint8Array>} Uint8Array representation of the packet.\n   */\n  write() {\n    const header = this.writeHeader();\n    const data = this.getBytes();\n\n    return util.concat([header, data]);\n  }\n}\n\nexport default LiteralDataPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @module type/keyid\n */\n\nimport util from '../util';\n\n/**\n * Implementation of type key id\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-3.3|RFC4880 3.3}:\n * A Key ID is an eight-octet scalar that identifies a key.\n * Implementations SHOULD NOT assume that Key IDs are unique.  The\n * section \"Enhanced Key Formats\" below describes how Key IDs are\n * formed.\n */\nclass KeyID {\n  constructor() {\n    this.bytes = '';\n  }\n\n  /**\n   * Parsing method for a key id\n   * @param {Uint8Array} bytes - Input to read the key id from\n   */\n  read(bytes) {\n    this.bytes = util.uint8ArrayToString(bytes.subarray(0, 8));\n    return this.bytes.length;\n  }\n\n  /**\n   * Serializes the Key ID\n   * @returns {Uint8Array} Key ID as a Uint8Array.\n   */\n  write() {\n    return util.stringToUint8Array(this.bytes);\n  }\n\n  /**\n   * Returns the Key ID represented as a hexadecimal string\n   * @returns {String} Key ID as a hexadecimal string.\n   */\n  toHex() {\n    return util.uint8ArrayToHex(util.stringToUint8Array(this.bytes));\n  }\n\n  /**\n   * Checks equality of Key ID's\n   * @param {KeyID} keyID\n   * @param {Boolean} matchWildcard - Indicates whether to check if either keyID is a wildcard\n   */\n  equals(keyID, matchWildcard = false) {\n    return (matchWildcard && (keyID.isWildcard() || this.isWildcard())) || this.bytes === keyID.bytes;\n  }\n\n  /**\n   * Checks to see if the Key ID is unset\n   * @returns {Boolean} True if the Key ID is null.\n   */\n  isNull() {\n    return this.bytes === '';\n  }\n\n  /**\n   * Checks to see if the Key ID is a \"wildcard\" Key ID (all zeros)\n   * @returns {Boolean} True if this is a wildcard Key ID.\n   */\n  isWildcard() {\n    return /^0+$/.test(this.toHex());\n  }\n\n  static mapToHex(keyID) {\n    return keyID.toHex();\n  }\n\n  static fromID(hex) {\n    const keyID = new KeyID();\n    keyID.read(util.hexToUint8Array(hex));\n    return keyID;\n  }\n\n  static wildcard() {\n    const keyID = new KeyID();\n    keyID.read(new Uint8Array(8));\n    return keyID;\n  }\n}\n\nexport default KeyID;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { fromAsync as streamFromAsync, slice as streamSlice, readToEnd as streamReadToEnd, clone as streamClone, transform as streamTransform } from '@openpgp/web-stream-tools';\nimport { readSimpleLength, UnsupportedError, writeSimpleLength } from './packet';\nimport KeyID from '../type/keyid';\nimport { signature, serializeParams, getRandomBytes, getHashByteLength, computeDigest } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\n// Symbol to store cryptographic validity of the signature, to avoid recomputing multiple times on verification.\nconst verified = Symbol('verified');\n\n// A salt notation is used to randomize signatures.\n// This is to protect EdDSA signatures in particular, which are known to be vulnerable to fault attacks\n// leading to secret key extraction if two signatures over the same data can be collected (see https://github.com/jedisct1/libsodium/issues/170).\n// For simplicity, we add the salt to all algos, as it may also serve as protection in case of weaknesses in the hash algo, potentially hindering e.g.\n// some chosen-prefix attacks.\n// v6 signatures do not need to rely on this notation, as they already include a separate, built-in salt.\nconst SALT_NOTATION_NAME = 'salt@notations.openpgpjs.org';\n\n// GPG puts the Issuer and Signature subpackets in the unhashed area.\n// Tampering with those invalidates the signature, so we still trust them and parse them.\n// All other unhashed subpackets are ignored.\nconst allowedUnhashedSubpackets = new Set([\n  enums.signatureSubpacket.issuerKeyID,\n  enums.signatureSubpacket.issuerFingerprint,\n  enums.signatureSubpacket.embeddedSignature\n]);\n\n/**\n * Implementation of the Signature Packet (Tag 2)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.2|RFC4480 5.2}:\n * A Signature packet describes a binding between some public key and\n * some data.  The most common signatures are a signature of a file or a\n * block of text, and a signature that is a certification of a User ID.\n */\nclass SignaturePacket {\n  static get tag() {\n    return enums.packet.signature;\n  }\n\n  constructor() {\n    this.version = null;\n    /** @type {enums.signature} */\n    this.signatureType = null;\n    /** @type {enums.hash} */\n    this.hashAlgorithm = null;\n    /** @type {enums.publicKey} */\n    this.publicKeyAlgorithm = null;\n\n    this.signatureData = null;\n    this.unhashedSubpackets = [];\n    this.unknownSubpackets = [];\n    this.signedHashValue = null;\n    this.salt = null;\n\n    this.created = null;\n    this.signatureExpirationTime = null;\n    this.signatureNeverExpires = true;\n    this.exportable = null;\n    this.trustLevel = null;\n    this.trustAmount = null;\n    this.regularExpression = null;\n    this.revocable = null;\n    this.keyExpirationTime = null;\n    this.keyNeverExpires = null;\n    this.preferredSymmetricAlgorithms = null;\n    this.revocationKeyClass = null;\n    this.revocationKeyAlgorithm = null;\n    this.revocationKeyFingerprint = null;\n    this.issuerKeyID = new KeyID();\n    this.rawNotations = [];\n    this.notations = {};\n    this.preferredHashAlgorithms = null;\n    this.preferredCompressionAlgorithms = null;\n    this.keyServerPreferences = null;\n    this.preferredKeyServer = null;\n    this.isPrimaryUserID = null;\n    this.policyURI = null;\n    this.keyFlags = null;\n    this.signersUserID = null;\n    this.reasonForRevocationFlag = null;\n    this.reasonForRevocationString = null;\n    this.features = null;\n    this.signatureTargetPublicKeyAlgorithm = null;\n    this.signatureTargetHashAlgorithm = null;\n    this.signatureTargetHash = null;\n    this.embeddedSignature = null;\n    this.issuerKeyVersion = null;\n    this.issuerFingerprint = null;\n    this.preferredAEADAlgorithms = null;\n    this.preferredCipherSuites = null;\n\n    this.revoked = null;\n    this[verified] = null;\n  }\n\n  /**\n   * parsing function for a signature packet (tag 2).\n   * @param {String} bytes - Payload of a tag 2 packet\n   * @returns {SignaturePacket} Object representation.\n   */\n  read(bytes, config = defaultConfig) {\n    let i = 0;\n    this.version = bytes[i++];\n    if (this.version === 5 && !config.enableParsingV5Entities) {\n      throw new UnsupportedError('Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed');\n    }\n\n    if (this.version !== 4 && this.version !== 5 && this.version !== 6) {\n      throw new UnsupportedError(`Version ${this.version} of the signature packet is unsupported.`);\n    }\n\n    this.signatureType = bytes[i++];\n    this.publicKeyAlgorithm = bytes[i++];\n    this.hashAlgorithm = bytes[i++];\n\n    // hashed subpackets\n    i += this.readSubPackets(bytes.subarray(i, bytes.length), true);\n    if (!this.created) {\n      throw new Error('Missing signature creation time subpacket.');\n    }\n\n    // A V4 signature hashes the packet body\n    // starting from its first field, the version number, through the end\n    // of the hashed subpacket data.  Thus, the fields hashed are the\n    // signature version, the signature type, the public-key algorithm, the\n    // hash algorithm, the hashed subpacket length, and the hashed\n    // subpacket body.\n    this.signatureData = bytes.subarray(0, i);\n\n    // unhashed subpackets\n    i += this.readSubPackets(bytes.subarray(i, bytes.length), false);\n\n    // Two-octet field holding left 16 bits of signed hash value.\n    this.signedHashValue = bytes.subarray(i, i + 2);\n    i += 2;\n\n    // Only for v6 signatures, a variable-length field containing:\n    if (this.version === 6) {\n      // A one-octet salt size. The value MUST match the value defined\n      // for the hash algorithm as specified in Table 23 (Hash algorithm registry).\n      // To allow parsing unknown hash algos, we only check the expected salt length when verifying.\n      const saltLength = bytes[i++];\n\n      // The salt; a random value value of the specified size.\n      this.salt = bytes.subarray(i, i + saltLength);\n      i += saltLength;\n    }\n\n    const signatureMaterial = bytes.subarray(i, bytes.length);\n    const { read, signatureParams } = signature.parseSignatureParams(this.publicKeyAlgorithm, signatureMaterial);\n    if (read < signatureMaterial.length) {\n      throw new Error('Error reading MPIs');\n    }\n    this.params = signatureParams;\n  }\n\n  /**\n   * @returns {Uint8Array | ReadableStream<Uint8Array>}\n   */\n  writeParams() {\n    if (this.params instanceof Promise) {\n      return streamFromAsync(\n        async () => serializeParams(this.publicKeyAlgorithm, await this.params)\n      );\n    }\n    return serializeParams(this.publicKeyAlgorithm, this.params);\n  }\n\n  write() {\n    const arr = [];\n    arr.push(this.signatureData);\n    arr.push(this.writeUnhashedSubPackets());\n    arr.push(this.signedHashValue);\n    if (this.version === 6) {\n      arr.push(new Uint8Array([this.salt.length]));\n      arr.push(this.salt);\n    }\n    arr.push(this.writeParams());\n    return util.concat(arr);\n  }\n\n  /**\n   * Signs provided data. This needs to be done prior to serialization.\n   * @param {SecretKeyPacket} key - Private key used to sign the message.\n   * @param {Object} data - Contains packets to be signed.\n   * @param {Date} [date] - The signature creation time.\n   * @param {Boolean} [detached] - Whether to create a detached signature\n   * @throws {Error} if signing failed\n   * @async\n   */\n  async sign(key, data, date = new Date(), detached = false, config) {\n    this.version = key.version;\n\n    this.created = util.normalizeDate(date);\n    this.issuerKeyVersion = key.version;\n    this.issuerFingerprint = key.getFingerprintBytes();\n    this.issuerKeyID = key.getKeyID();\n\n    const arr = [new Uint8Array([this.version, this.signatureType, this.publicKeyAlgorithm, this.hashAlgorithm])];\n\n    // add randomness to the signature\n    if (this.version === 6) {\n      const saltLength = saltLengthForHash(this.hashAlgorithm);\n      if (this.salt === null) {\n        this.salt = getRandomBytes(saltLength);\n      } else if (saltLength !== this.salt.length) {\n        throw new Error('Provided salt does not have the required length');\n      }\n    } else if (config.nonDeterministicSignaturesViaNotation) {\n      const saltNotations = this.rawNotations.filter(({ name }) => (name === SALT_NOTATION_NAME));\n      // since re-signing the same object is not supported, it's not expected to have multiple salt notations,\n      // but we guard against it as a sanity check\n      if (saltNotations.length === 0) {\n        const saltValue = getRandomBytes(saltLengthForHash(this.hashAlgorithm));\n        this.rawNotations.push({\n          name: SALT_NOTATION_NAME,\n          value: saltValue,\n          humanReadable: false,\n          critical: false\n        });\n      } else {\n        throw new Error('Unexpected existing salt notation');\n      }\n    }\n\n    // Add hashed subpackets\n    arr.push(this.writeHashedSubPackets());\n\n    // Remove unhashed subpackets, in case some allowed unhashed\n    // subpackets existed, in order not to duplicate them (in both\n    // the hashed and unhashed subpackets) when re-signing.\n    this.unhashedSubpackets = [];\n\n    this.signatureData = util.concat(arr);\n\n    const toHash = this.toHash(this.signatureType, data, detached);\n    const hash = await this.hash(this.signatureType, data, toHash, detached);\n\n    this.signedHashValue = streamSlice(streamClone(hash), 0, 2);\n    const signed = async () => signature.sign(\n      this.publicKeyAlgorithm, this.hashAlgorithm, key.publicParams, key.privateParams, toHash, await streamReadToEnd(hash)\n    );\n    if (util.isStream(hash)) {\n      this.params = signed();\n    } else {\n      this.params = await signed();\n\n      // Store the fact that this signature is valid, e.g. for when we call `await\n      // getLatestValidSignature(this.revocationSignatures, key, data)` later.\n      // Note that this only holds up if the key and data passed to verify are the\n      // same as the ones passed to sign.\n      this[verified] = true;\n    }\n  }\n\n  /**\n   * Creates Uint8Array of bytes of all subpacket data except Issuer and Embedded Signature subpackets\n   * @returns {Uint8Array} Subpacket data.\n   */\n  writeHashedSubPackets() {\n    const sub = enums.signatureSubpacket;\n    const arr = [];\n    let bytes;\n    if (this.created === null) {\n      throw new Error('Missing signature creation time');\n    }\n    arr.push(writeSubPacket(sub.signatureCreationTime, true, util.writeDate(this.created)));\n    if (this.signatureExpirationTime !== null) {\n      arr.push(writeSubPacket(sub.signatureExpirationTime, true, util.writeNumber(this.signatureExpirationTime, 4)));\n    }\n    if (this.exportable !== null) {\n      arr.push(writeSubPacket(sub.exportableCertification, true, new Uint8Array([this.exportable ? 1 : 0])));\n    }\n    if (this.trustLevel !== null) {\n      bytes = new Uint8Array([this.trustLevel, this.trustAmount]);\n      arr.push(writeSubPacket(sub.trustSignature, true, bytes));\n    }\n    if (this.regularExpression !== null) {\n      arr.push(writeSubPacket(sub.regularExpression, true, this.regularExpression));\n    }\n    if (this.revocable !== null) {\n      arr.push(writeSubPacket(sub.revocable, true, new Uint8Array([this.revocable ? 1 : 0])));\n    }\n    if (this.keyExpirationTime !== null) {\n      arr.push(writeSubPacket(sub.keyExpirationTime, true, util.writeNumber(this.keyExpirationTime, 4)));\n    }\n    if (this.preferredSymmetricAlgorithms !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.preferredSymmetricAlgorithms));\n      arr.push(writeSubPacket(sub.preferredSymmetricAlgorithms, false, bytes));\n    }\n    if (this.revocationKeyClass !== null) {\n      bytes = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]);\n      bytes = util.concat([bytes, this.revocationKeyFingerprint]);\n      arr.push(writeSubPacket(sub.revocationKey, false, bytes));\n    }\n    if (!this.issuerKeyID.isNull() && this.issuerKeyVersion < 5) {\n      // If the version of [the] key is greater than 4, this subpacket\n      // MUST NOT be included in the signature.\n      // Note: making this critical breaks RPM <=4.16.\n      // See: https://github.com/ProtonMail/go-crypto/issues/263\n      arr.push(writeSubPacket(sub.issuerKeyID, false, this.issuerKeyID.write()));\n    }\n    this.rawNotations.forEach(({ name, value, humanReadable, critical }) => {\n      bytes = [new Uint8Array([humanReadable ? 0x80 : 0, 0, 0, 0])];\n      const encodedName = util.encodeUTF8(name);\n      // 2 octets of name length\n      bytes.push(util.writeNumber(encodedName.length, 2));\n      // 2 octets of value length\n      bytes.push(util.writeNumber(value.length, 2));\n      bytes.push(encodedName);\n      bytes.push(value);\n      bytes = util.concat(bytes);\n      arr.push(writeSubPacket(sub.notationData, critical, bytes));\n    });\n    if (this.preferredHashAlgorithms !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.preferredHashAlgorithms));\n      arr.push(writeSubPacket(sub.preferredHashAlgorithms, false, bytes));\n    }\n    if (this.preferredCompressionAlgorithms !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.preferredCompressionAlgorithms));\n      arr.push(writeSubPacket(sub.preferredCompressionAlgorithms, false, bytes));\n    }\n    if (this.keyServerPreferences !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.keyServerPreferences));\n      arr.push(writeSubPacket(sub.keyServerPreferences, false, bytes));\n    }\n    if (this.preferredKeyServer !== null) {\n      arr.push(writeSubPacket(sub.preferredKeyServer, false, util.encodeUTF8(this.preferredKeyServer)));\n    }\n    if (this.isPrimaryUserID !== null) {\n      arr.push(writeSubPacket(sub.primaryUserID, false, new Uint8Array([this.isPrimaryUserID ? 1 : 0])));\n    }\n    if (this.policyURI !== null) {\n      arr.push(writeSubPacket(sub.policyURI, false, util.encodeUTF8(this.policyURI)));\n    }\n    if (this.keyFlags !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.keyFlags));\n      arr.push(writeSubPacket(sub.keyFlags, true, bytes));\n    }\n    if (this.signersUserID !== null) {\n      arr.push(writeSubPacket(sub.signersUserID, false, util.encodeUTF8(this.signersUserID)));\n    }\n    if (this.reasonForRevocationFlag !== null) {\n      bytes = util.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString);\n      arr.push(writeSubPacket(sub.reasonForRevocation, true, bytes));\n    }\n    if (this.features !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.features));\n      arr.push(writeSubPacket(sub.features, false, bytes));\n    }\n    if (this.signatureTargetPublicKeyAlgorithm !== null) {\n      bytes = [new Uint8Array([this.signatureTargetPublicKeyAlgorithm, this.signatureTargetHashAlgorithm])];\n      bytes.push(util.stringToUint8Array(this.signatureTargetHash));\n      bytes = util.concat(bytes);\n      arr.push(writeSubPacket(sub.signatureTarget, true, bytes));\n    }\n    if (this.embeddedSignature !== null) {\n      arr.push(writeSubPacket(sub.embeddedSignature, true, this.embeddedSignature.write()));\n    }\n    if (this.issuerFingerprint !== null) {\n      bytes = [new Uint8Array([this.issuerKeyVersion]), this.issuerFingerprint];\n      bytes = util.concat(bytes);\n      arr.push(writeSubPacket(sub.issuerFingerprint, this.version >= 5, bytes));\n    }\n    if (this.preferredAEADAlgorithms !== null) {\n      bytes = util.stringToUint8Array(util.uint8ArrayToString(this.preferredAEADAlgorithms));\n      arr.push(writeSubPacket(sub.preferredAEADAlgorithms, false, bytes));\n    }\n    if (this.preferredCipherSuites !== null) {\n      bytes = new Uint8Array([].concat(...this.preferredCipherSuites));\n      arr.push(writeSubPacket(sub.preferredCipherSuites, false, bytes));\n    }\n\n    const result = util.concat(arr);\n    const length = util.writeNumber(result.length, this.version === 6 ? 4 : 2);\n\n    return util.concat([length, result]);\n  }\n\n  /**\n   * Creates an Uint8Array containing the unhashed subpackets\n   * @returns {Uint8Array} Subpacket data.\n   */\n  writeUnhashedSubPackets() {\n    const arr = this.unhashedSubpackets.map(({ type, critical, body }) => {\n      return writeSubPacket(type, critical, body);\n    });\n\n    const result = util.concat(arr);\n    const length = util.writeNumber(result.length, this.version === 6 ? 4 : 2);\n\n    return util.concat([length, result]);\n  }\n\n  // Signature subpackets\n  readSubPacket(bytes, hashed = true) {\n    let mypos = 0;\n\n    // The leftmost bit denotes a \"critical\" packet\n    const critical = !!(bytes[mypos] & 0x80);\n    const type = bytes[mypos] & 0x7F;\n\n    mypos++;\n\n    if (!hashed) {\n      this.unhashedSubpackets.push({\n        type,\n        critical,\n        body: bytes.subarray(mypos, bytes.length)\n      });\n      if (!allowedUnhashedSubpackets.has(type)) {\n        return;\n      }\n    }\n\n    // subpacket type\n    switch (type) {\n      case enums.signatureSubpacket.signatureCreationTime:\n        // Signature Creation Time\n        this.created = util.readDate(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.signatureExpirationTime: {\n        // Signature Expiration Time in seconds\n        const seconds = util.readNumber(bytes.subarray(mypos, bytes.length));\n\n        this.signatureNeverExpires = seconds === 0;\n        this.signatureExpirationTime = seconds;\n\n        break;\n      }\n      case enums.signatureSubpacket.exportableCertification:\n        // Exportable Certification\n        this.exportable = bytes[mypos++] === 1;\n        break;\n      case enums.signatureSubpacket.trustSignature:\n        // Trust Signature\n        this.trustLevel = bytes[mypos++];\n        this.trustAmount = bytes[mypos++];\n        break;\n      case enums.signatureSubpacket.regularExpression:\n        // Regular Expression\n        this.regularExpression = bytes[mypos];\n        break;\n      case enums.signatureSubpacket.revocable:\n        // Revocable\n        this.revocable = bytes[mypos++] === 1;\n        break;\n      case enums.signatureSubpacket.keyExpirationTime: {\n        // Key Expiration Time in seconds\n        const seconds = util.readNumber(bytes.subarray(mypos, bytes.length));\n\n        this.keyExpirationTime = seconds;\n        this.keyNeverExpires = seconds === 0;\n\n        break;\n      }\n      case enums.signatureSubpacket.preferredSymmetricAlgorithms:\n        // Preferred Symmetric Algorithms\n        this.preferredSymmetricAlgorithms = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.revocationKey:\n        // Revocation Key\n        // (1 octet of class, 1 octet of public-key algorithm ID, 20\n        // octets of\n        // fingerprint)\n        this.revocationKeyClass = bytes[mypos++];\n        this.revocationKeyAlgorithm = bytes[mypos++];\n        this.revocationKeyFingerprint = bytes.subarray(mypos, mypos + 20);\n        break;\n\n      case enums.signatureSubpacket.issuerKeyID:\n        // Issuer\n        if (this.version === 4) {\n          this.issuerKeyID.read(bytes.subarray(mypos, bytes.length));\n        } else if (hashed) {\n          // If the version of the key is greater than 4, this subpacket MUST NOT be included in the signature,\n          // since the Issuer Fingerprint subpacket is to be used instead.\n          // The `issuerKeyID` value will be set when reading the issuerFingerprint packet.\n          // For this reason, if the issuer Key ID packet is present but unhashed, we simply ignore it,\n          // to avoid situations where `.getSigningKeyIDs()` returns a keyID potentially different from the (signed)\n          // issuerFingerprint.\n          // If the packet is hashed, then we reject the signature, to avoid verifying data different from\n          // what was parsed.\n          throw new Error('Unexpected Issuer Key ID subpacket');\n        }\n        break;\n\n      case enums.signatureSubpacket.notationData: {\n        // Notation Data\n        const humanReadable = !!(bytes[mypos] & 0x80);\n\n        // We extract key/value tuple from the byte stream.\n        mypos += 4;\n        const m = util.readNumber(bytes.subarray(mypos, mypos + 2));\n        mypos += 2;\n        const n = util.readNumber(bytes.subarray(mypos, mypos + 2));\n        mypos += 2;\n\n        const name = util.decodeUTF8(bytes.subarray(mypos, mypos + m));\n        const value = bytes.subarray(mypos + m, mypos + m + n);\n\n        this.rawNotations.push({ name, humanReadable, value, critical });\n\n        if (humanReadable) {\n          this.notations[name] = util.decodeUTF8(value);\n        }\n        break;\n      }\n      case enums.signatureSubpacket.preferredHashAlgorithms:\n        // Preferred Hash Algorithms\n        this.preferredHashAlgorithms = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.preferredCompressionAlgorithms:\n        // Preferred Compression Algorithms\n        this.preferredCompressionAlgorithms = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.keyServerPreferences:\n        // Key Server Preferences\n        this.keyServerPreferences = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.preferredKeyServer:\n        // Preferred Key Server\n        this.preferredKeyServer = util.decodeUTF8(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.primaryUserID:\n        // Primary User ID\n        this.isPrimaryUserID = bytes[mypos++] !== 0;\n        break;\n      case enums.signatureSubpacket.policyURI:\n        // Policy URI\n        this.policyURI = util.decodeUTF8(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.keyFlags:\n        // Key Flags\n        this.keyFlags = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.signersUserID:\n        // Signer's User ID\n        this.signersUserID = util.decodeUTF8(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.reasonForRevocation:\n        // Reason for Revocation\n        this.reasonForRevocationFlag = bytes[mypos++];\n        this.reasonForRevocationString = util.decodeUTF8(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.features:\n        // Features\n        this.features = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.signatureTarget: {\n        // Signature Target\n        // (1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)\n        this.signatureTargetPublicKeyAlgorithm = bytes[mypos++];\n        this.signatureTargetHashAlgorithm = bytes[mypos++];\n\n        const len = getHashByteLength(this.signatureTargetHashAlgorithm);\n\n        this.signatureTargetHash = util.uint8ArrayToString(bytes.subarray(mypos, mypos + len));\n        break;\n      }\n      case enums.signatureSubpacket.embeddedSignature:\n        // Embedded Signature\n        this.embeddedSignature = new SignaturePacket();\n        this.embeddedSignature.read(bytes.subarray(mypos, bytes.length));\n        break;\n      case enums.signatureSubpacket.issuerFingerprint:\n        // Issuer Fingerprint\n        this.issuerKeyVersion = bytes[mypos++];\n        this.issuerFingerprint = bytes.subarray(mypos, bytes.length);\n        if (this.issuerKeyVersion >= 5) {\n          this.issuerKeyID.read(this.issuerFingerprint);\n        } else {\n          this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));\n        }\n        break;\n      case enums.signatureSubpacket.preferredAEADAlgorithms:\n        // Preferred AEAD Algorithms\n        this.preferredAEADAlgorithms = [...bytes.subarray(mypos, bytes.length)];\n        break;\n      case enums.signatureSubpacket.preferredCipherSuites:\n        // Preferred AEAD Cipher Suites\n        this.preferredCipherSuites = [];\n        for (let i = mypos; i < bytes.length; i += 2) {\n          this.preferredCipherSuites.push([bytes[i], bytes[i + 1]]);\n        }\n        break;\n      default:\n        this.unknownSubpackets.push({\n          type,\n          critical,\n          body: bytes.subarray(mypos, bytes.length)\n        });\n        break;\n    }\n  }\n\n  readSubPackets(bytes, trusted = true, config) {\n    const subpacketLengthBytes = this.version === 6 ? 4 : 2;\n\n    // Two-octet scalar octet count for following subpacket data.\n    const subpacketLength = util.readNumber(bytes.subarray(0, subpacketLengthBytes));\n\n    let i = subpacketLengthBytes;\n\n    // subpacket data set (zero or more subpackets)\n    while (i < 2 + subpacketLength) {\n      const len = readSimpleLength(bytes.subarray(i, bytes.length));\n      i += len.offset;\n\n      this.readSubPacket(bytes.subarray(i, i + len.len), trusted, config);\n\n      i += len.len;\n    }\n\n    return i;\n  }\n\n  // Produces data to produce signature on\n  toSign(type, data) {\n    const t = enums.signature;\n\n    switch (type) {\n      case t.binary:\n        if (data.text !== null) {\n          return util.encodeUTF8(data.getText(true));\n        }\n        return data.getBytes(true);\n\n      case t.text: {\n        const bytes = data.getBytes(true);\n        // normalize EOL to \\r\\n\n        return util.canonicalizeEOL(bytes);\n      }\n      case t.standalone:\n        return new Uint8Array(0);\n\n      case t.certGeneric:\n      case t.certPersona:\n      case t.certCasual:\n      case t.certPositive:\n      case t.certRevocation: {\n        let packet;\n        let tag;\n\n        if (data.userID) {\n          tag = 0xB4;\n          packet = data.userID;\n        } else if (data.userAttribute) {\n          tag = 0xD1;\n          packet = data.userAttribute;\n        } else {\n          throw new Error('Either a userID or userAttribute packet needs to be ' +\n            'supplied for certification.');\n        }\n\n        const bytes = packet.write();\n\n        return util.concat([this.toSign(t.key, data),\n          new Uint8Array([tag]),\n          util.writeNumber(bytes.length, 4),\n          bytes]);\n      }\n      case t.subkeyBinding:\n      case t.subkeyRevocation:\n      case t.keyBinding:\n        return util.concat([this.toSign(t.key, data), this.toSign(t.key, {\n          key: data.bind\n        })]);\n\n      case t.key:\n        if (data.key === undefined) {\n          throw new Error('Key packet is required for this signature.');\n        }\n        return data.key.writeForHash(this.version);\n\n      case t.keyRevocation:\n        return this.toSign(t.key, data);\n      case t.timestamp:\n        return new Uint8Array(0);\n      case t.thirdParty:\n        throw new Error('Not implemented');\n      default:\n        throw new Error('Unknown signature type.');\n    }\n  }\n\n  calculateTrailer(data, detached) {\n    let length = 0;\n    return streamTransform(streamClone(this.signatureData), value => {\n      length += value.length;\n    }, () => {\n      const arr = [];\n      if (this.version === 5 && (this.signatureType === enums.signature.binary || this.signatureType === enums.signature.text)) {\n        if (detached) {\n          arr.push(new Uint8Array(6));\n        } else {\n          arr.push(data.writeHeader());\n        }\n      }\n      arr.push(new Uint8Array([this.version, 0xFF]));\n      if (this.version === 5) {\n        arr.push(new Uint8Array(4));\n      }\n      arr.push(util.writeNumber(length, 4));\n      // For v5, this should really be writeNumber(length, 8) rather than the\n      // hardcoded 4 zero bytes above\n      return util.concat(arr);\n    });\n  }\n\n  toHash(signatureType, data, detached = false) {\n    const bytes = this.toSign(signatureType, data);\n\n    return util.concat([this.salt || new Uint8Array(), bytes, this.signatureData, this.calculateTrailer(data, detached)]);\n  }\n\n  async hash(signatureType, data, toHash, detached = false) {\n    if (this.version === 6 && this.salt.length !== saltLengthForHash(this.hashAlgorithm)) {\n      // avoid hashing unexpected salt size\n      throw new Error('Signature salt does not have the expected length');\n    }\n\n    if (!toHash) toHash = this.toHash(signatureType, data, detached);\n    return computeDigest(this.hashAlgorithm, toHash);\n  }\n\n  /**\n   * verifies the signature packet. Note: not all signature types are implemented\n   * @param {PublicSubkeyPacket|PublicKeyPacket|\n   *         SecretSubkeyPacket|SecretKeyPacket} key - the public key to verify the signature\n   * @param {module:enums.signature} signatureType - Expected signature type\n   * @param {Uint8Array|Object} data - Data which on the signature applies\n   * @param {Date} [date] - Use the given date instead of the current time to check for signature validity and expiration\n   * @param {Boolean} [detached] - Whether to verify a detached signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if signature validation failed\n   * @async\n   */\n  async verify(key, signatureType, data, date = new Date(), detached = false, config = defaultConfig) {\n    if (!this.issuerKeyID.equals(key.getKeyID())) {\n      throw new Error('Signature was not issued by the given public key');\n    }\n    if (this.publicKeyAlgorithm !== key.algorithm) {\n      throw new Error('Public key algorithm used to sign signature does not match issuer key algorithm.');\n    }\n\n    const isMessageSignature = signatureType === enums.signature.binary || signatureType === enums.signature.text;\n    // Cryptographic validity is cached after one successful verification.\n    // However, for message signatures, we always re-verify, since the passed `data` can change\n    const skipVerify = this[verified] && !isMessageSignature;\n    if (!skipVerify) {\n      let toHash;\n      let hash;\n      if (this.hashed) {\n        hash = await this.hashed;\n      } else {\n        toHash = this.toHash(signatureType, data, detached);\n        hash = await this.hash(signatureType, data, toHash);\n      }\n      hash = await streamReadToEnd(hash);\n      if (this.signedHashValue[0] !== hash[0] ||\n          this.signedHashValue[1] !== hash[1]) {\n        throw new Error('Signed digest did not match');\n      }\n\n      this.params = await this.params;\n\n      this[verified] = await signature.verify(\n        this.publicKeyAlgorithm, this.hashAlgorithm, this.params, key.publicParams,\n        toHash, hash\n      );\n\n      if (!this[verified]) {\n        throw new Error('Signature verification failed');\n      }\n    }\n\n    const normDate = util.normalizeDate(date);\n    if (normDate && this.created > normDate) {\n      throw new Error('Signature creation time is in the future');\n    }\n    if (normDate && normDate >= this.getExpirationTime()) {\n      throw new Error('Signature is expired');\n    }\n    if (config.rejectHashAlgorithms.has(this.hashAlgorithm)) {\n      throw new Error('Insecure hash algorithm: ' + enums.read(enums.hash, this.hashAlgorithm).toUpperCase());\n    }\n    if (config.rejectMessageHashAlgorithms.has(this.hashAlgorithm) &&\n      [enums.signature.binary, enums.signature.text].includes(this.signatureType)) {\n      throw new Error('Insecure message hash algorithm: ' + enums.read(enums.hash, this.hashAlgorithm).toUpperCase());\n    }\n    this.unknownSubpackets.forEach(({ type, critical }) => {\n      if (critical) {\n        throw new Error(`Unknown critical signature subpacket type ${type}`);\n      }\n    });\n    this.rawNotations.forEach(({ name, critical }) => {\n      if (critical && (config.knownNotations.indexOf(name) < 0)) {\n        throw new Error(`Unknown critical notation: ${name}`);\n      }\n    });\n    if (this.revocationKeyClass !== null) {\n      throw new Error('This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.');\n    }\n  }\n\n  /**\n   * Verifies signature expiration date\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @returns {Boolean} True if expired.\n   */\n  isExpired(date = new Date()) {\n    const normDate = util.normalizeDate(date);\n    if (normDate !== null) {\n      return !(this.created <= normDate && normDate < this.getExpirationTime());\n    }\n    return false;\n  }\n\n  /**\n   * Returns the expiration time of the signature or Infinity if signature does not expire\n   * @returns {Date | Infinity} Expiration time.\n   */\n  getExpirationTime() {\n    return this.signatureNeverExpires ? Infinity : new Date(this.created.getTime() + this.signatureExpirationTime * 1000);\n  }\n}\n\nexport default SignaturePacket;\n\n/**\n * Creates a Uint8Array representation of a sub signature packet\n * @see {@link https://tools.ietf.org/html/rfc4880#section-5.2.3.1|RFC4880 5.2.3.1}\n * @see {@link https://tools.ietf.org/html/rfc4880#section-5.2.3.2|RFC4880 5.2.3.2}\n * @param {Integer} type - Subpacket signature type.\n * @param {Boolean} critical - Whether the subpacket should be critical.\n * @param {String} data - Data to be included\n * @returns {Uint8Array} The signature subpacket.\n * @private\n */\nfunction writeSubPacket(type, critical, data) {\n  const arr = [];\n  arr.push(writeSimpleLength(data.length + 1));\n  arr.push(new Uint8Array([(critical ? 0x80 : 0) | type]));\n  arr.push(data);\n  return util.concat(arr);\n}\n\n/**\n * Select the required salt length for the given hash algorithm, as per Table 23 (Hash algorithm registry) of the crypto refresh.\n * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-openpgp-crypto-refresh#section-9.5|Crypto Refresh Section 9.5}\n * @param {enums.hash} hashAlgorithm - Hash algorithm.\n * @returns {Integer} Salt length.\n * @private\n */\nfunction saltLengthForHash(hashAlgorithm) {\n  switch (hashAlgorithm) {\n    case enums.hash.sha256: return 16;\n    case enums.hash.sha384: return 24;\n    case enums.hash.sha512: return 32;\n    case enums.hash.sha224: return 16;\n    case enums.hash.sha3_256: return 16;\n    case enums.hash.sha3_512: return 32;\n    default: throw new Error('Unsupported hash function');\n  }\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { fromAsync as streamFromAsync } from '@openpgp/web-stream-tools';\nimport SignaturePacket from './signature';\nimport KeyID from '../type/keyid';\nimport enums from '../enums';\nimport util from '../util';\nimport { UnsupportedError } from './packet';\n\n/**\n * Implementation of the One-Pass Signature Packets (Tag 4)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.4|RFC4880 5.4}:\n * The One-Pass Signature packet precedes the signed data and contains\n * enough information to allow the receiver to begin calculating any\n * hashes needed to verify the signature.  It allows the Signature\n * packet to be placed at the end of the message, so that the signer\n * can compute the entire signed message in one pass.\n */\nclass OnePassSignaturePacket {\n  static get tag() {\n    return enums.packet.onePassSignature;\n  }\n\n  static fromSignaturePacket(signaturePacket, isLast) {\n    const onePassSig = new OnePassSignaturePacket();\n    onePassSig.version = signaturePacket.version === 6 ? 6 : 3;\n    onePassSig.signatureType = signaturePacket.signatureType;\n    onePassSig.hashAlgorithm = signaturePacket.hashAlgorithm;\n    onePassSig.publicKeyAlgorithm = signaturePacket.publicKeyAlgorithm;\n    onePassSig.issuerKeyID = signaturePacket.issuerKeyID;\n    onePassSig.salt = signaturePacket.salt; // v6 only\n    onePassSig.issuerFingerprint = signaturePacket.issuerFingerprint; // v6 only\n\n    onePassSig.flags = isLast ? 1 : 0;\n    return onePassSig;\n  }\n\n  constructor() {\n    /** A one-octet version number.  The current versions are 3 and 6. */\n    this.version = null;\n    /**\n     * A one-octet signature type.\n     * Signature types are described in\n     * {@link https://tools.ietf.org/html/rfc4880#section-5.2.1|RFC4880 Section 5.2.1}.\n     * @type {enums.signature}\n\n     */\n    this.signatureType = null;\n    /**\n     * A one-octet number describing the hash algorithm used.\n     * @see {@link https://tools.ietf.org/html/rfc4880#section-9.4|RFC4880 9.4}\n     * @type {enums.hash}\n     */\n    this.hashAlgorithm = null;\n    /**\n     * A one-octet number describing the public-key algorithm used.\n     * @see {@link https://tools.ietf.org/html/rfc4880#section-9.1|RFC4880 9.1}\n     * @type {enums.publicKey}\n     */\n    this.publicKeyAlgorithm = null;\n    /** Only for v6, a variable-length field containing the salt. */\n    this.salt = null;\n    /** Only for v3 packets, an eight-octet number holding the Key ID of the signing key. */\n    this.issuerKeyID = null;\n    /** Only for v6 packets, 32 octets of the fingerprint of the signing key. */\n    this.issuerFingerprint = null;\n    /**\n     * A one-octet number holding a flag showing whether the signature is nested.\n     * A zero value indicates that the next packet is another One-Pass Signature packet\n     * that describes another signature to be applied to the same message data.\n     */\n    this.flags = null;\n  }\n\n  /**\n   * parsing function for a one-pass signature packet (tag 4).\n   * @param {Uint8Array} bytes - Payload of a tag 4 packet\n   * @returns {OnePassSignaturePacket} Object representation.\n   */\n  read(bytes) {\n    let mypos = 0;\n    // A one-octet version number.  The current versions are 3 or 6.\n    this.version = bytes[mypos++];\n    if (this.version !== 3 && this.version !== 6) {\n      throw new UnsupportedError(`Version ${this.version} of the one-pass signature packet is unsupported.`);\n    }\n\n    // A one-octet signature type.  Signature types are described in\n    //   Section 5.2.1.\n    this.signatureType = bytes[mypos++];\n\n    // A one-octet number describing the hash algorithm used.\n    this.hashAlgorithm = bytes[mypos++];\n\n    // A one-octet number describing the public-key algorithm used.\n    this.publicKeyAlgorithm = bytes[mypos++];\n\n    if (this.version === 6) {\n      // Only for v6 signatures, a variable-length field containing:\n\n      // A one-octet salt size. The value MUST match the value defined\n      // for the hash algorithm as specified in Table 23 (Hash algorithm registry).\n      // To allow parsing unknown hash algos, we only check the expected salt length when verifying.\n      const saltLength = bytes[mypos++];\n\n      // The salt; a random value value of the specified size.\n      this.salt = bytes.subarray(mypos, mypos + saltLength);\n      mypos += saltLength;\n\n      // Only for v6 packets, 32 octets of the fingerprint of the signing key.\n      this.issuerFingerprint = bytes.subarray(mypos, mypos + 32);\n      mypos += 32;\n      this.issuerKeyID = new KeyID();\n      // For v6 the Key ID is the high-order 64 bits of the fingerprint.\n      this.issuerKeyID.read(this.issuerFingerprint);\n    } else {\n      // Only for v3 packets, an eight-octet number holding the Key ID of the signing key.\n      this.issuerKeyID = new KeyID();\n      this.issuerKeyID.read(bytes.subarray(mypos, mypos + 8));\n      mypos += 8;\n    }\n\n    // A one-octet number holding a flag showing whether the signature\n    //   is nested.  A zero value indicates that the next packet is\n    //   another One-Pass Signature packet that describes another\n    //   signature to be applied to the same message data.\n    this.flags = bytes[mypos++];\n    return this;\n  }\n\n  /**\n   * creates a string representation of a one-pass signature packet\n   * @returns {Uint8Array} A Uint8Array representation of a one-pass signature packet.\n   */\n  write() {\n    const arr = [new Uint8Array([\n      this.version,\n      this.signatureType,\n      this.hashAlgorithm,\n      this.publicKeyAlgorithm\n    ])];\n    if (this.version === 6) {\n      arr.push(\n        new Uint8Array([this.salt.length]),\n        this.salt,\n        this.issuerFingerprint\n      );\n    } else {\n      arr.push(this.issuerKeyID.write());\n    }\n    arr.push(new Uint8Array([this.flags]));\n    return util.concatUint8Array(arr);\n  }\n\n  calculateTrailer(...args) {\n    return streamFromAsync(async () => SignaturePacket.prototype.calculateTrailer.apply(await this.correspondingSig, args));\n  }\n\n  async verify() {\n    const correspondingSig = await this.correspondingSig;\n    if (!correspondingSig || correspondingSig.constructor.tag !== enums.packet.signature) {\n      throw new Error('Corresponding signature packet missing');\n    }\n    if (\n      correspondingSig.signatureType !== this.signatureType ||\n      correspondingSig.hashAlgorithm !== this.hashAlgorithm ||\n      correspondingSig.publicKeyAlgorithm !== this.publicKeyAlgorithm ||\n      !correspondingSig.issuerKeyID.equals(this.issuerKeyID) ||\n      (this.version === 3 && correspondingSig.version === 6) ||\n      (this.version === 6 && correspondingSig.version !== 6) ||\n      (this.version === 6 && !util.equalsUint8Array(correspondingSig.issuerFingerprint, this.issuerFingerprint)) ||\n      (this.version === 6 && !util.equalsUint8Array(correspondingSig.salt, this.salt))\n    ) {\n      throw new Error('Corresponding signature packet does not match one-pass signature packet');\n    }\n    correspondingSig.hashed = this.hashed;\n    return correspondingSig.verify.apply(correspondingSig, arguments);\n  }\n}\n\nOnePassSignaturePacket.prototype.hash = SignaturePacket.prototype.hash;\nOnePassSignaturePacket.prototype.toHash = SignaturePacket.prototype.toHash;\nOnePassSignaturePacket.prototype.toSign = SignaturePacket.prototype.toSign;\n\nexport default OnePassSignaturePacket;\n","import { transformPair as streamTransformPair, transform as streamTransform, getWriter as streamGetWriter, getReader as streamGetReader, clone as streamClone } from '@openpgp/web-stream-tools';\nimport {\n  readPacket, supportsStreaming,\n  writeTag, writeHeader,\n  writePartialLength, writeSimpleLength,\n  UnparseablePacket,\n  UnsupportedError,\n  UnknownPacketError,\n  MalformedPacketError\n} from './packet';\nimport util from '../util';\nimport enums from '../enums';\nimport defaultConfig from '../config';\n\n/**\n * Instantiate a new packet given its tag\n * @function newPacketFromTag\n * @param {module:enums.packet} tag - Property value from {@link module:enums.packet}\n * @param {Object} allowedPackets - mapping where keys are allowed packet tags, pointing to their Packet class\n * @returns {Object} New packet object with type based on tag\n * @throws {Error|UnsupportedError} for disallowed or unknown packets\n */\nexport function newPacketFromTag(tag, allowedPackets) {\n  if (!allowedPackets[tag]) {\n    // distinguish between disallowed packets and unknown ones\n    let packetType;\n    try {\n      packetType = enums.read(enums.packet, tag);\n    } catch (e) {\n      throw new UnknownPacketError(`Unknown packet type with tag: ${tag}`);\n    }\n    throw new Error(`Packet not allowed in this context: ${packetType}`);\n  }\n  return new allowedPackets[tag]();\n}\n\n/**\n * This class represents a list of openpgp packets.\n * Take care when iterating over it - the packets themselves\n * are stored as numerical indices.\n * @extends Array\n */\nclass PacketList extends Array {\n  /**\n   * Parses the given binary data and returns a list of packets.\n   * Equivalent to calling `read` on an empty PacketList instance.\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes - binary data to parse\n   * @param {Object} allowedPackets - mapping where keys are allowed packet tags, pointing to their Packet class\n   * @param {Object} [config] - full configuration, defaults to openpgp.config\n   * @param {function(enums.packet[], boolean, Object): void} [grammarValidator]\n   * @param {Boolean} [delayErrors] - delay errors until the input stream has been read completely\n   * @returns {PacketList} parsed list of packets\n   * @throws on parsing errors\n   * @async\n   */\n  static async fromBinary(bytes, allowedPackets, config = defaultConfig, grammarValidator = null, delayErrors = false) {\n    const packets = new PacketList();\n    await packets.read(bytes, allowedPackets, config, grammarValidator, delayErrors);\n    return packets;\n  }\n\n  /**\n   * Reads a stream of binary data and interprets it as a list of packets.\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes - binary data to parse\n   * @param {Object} allowedPackets - mapping where keys are allowed packet tags, pointing to their Packet class\n   * @param {Object} [config] - full configuration, defaults to openpgp.config\n   * @param {function(enums.packet[], boolean, Object): void} [grammarValidator]\n   * @param {Boolean} [delayErrors] - delay errors until the input stream has been read completely\n   * @throws on parsing errors\n   * @async\n   */\n  async read(bytes, allowedPackets, config = defaultConfig, grammarValidator = null, delayErrors = false) {\n    let additionalAllowedPackets;\n    if (config.additionalAllowedPackets.length) {\n      additionalAllowedPackets = util.constructAllowedPackets(config.additionalAllowedPackets);\n      allowedPackets = { ...allowedPackets, ...additionalAllowedPackets };\n    }\n    this.stream = streamTransformPair(bytes, async (readable, writable) => {\n      const reader = streamGetReader(readable);\n      const writer = streamGetWriter(writable);\n      try {\n        let useStreamType = util.isStream(readable);\n        while (true) {\n          await writer.ready;\n          let unauthenticatedError;\n          let wasStream;\n          await readPacket(reader, useStreamType, async parsed => {\n            try {\n              if (parsed.tag === enums.packet.marker || parsed.tag === enums.packet.trust || parsed.tag === enums.packet.padding) {\n                // According to the spec, these packet types should be ignored and not cause parsing errors, even if not explicitly allowed:\n                // - Marker packets MUST be ignored when received: https://github.com/openpgpjs/openpgpjs/issues/1145\n                // - Trust packets SHOULD be ignored outside of keyrings (unsupported): https://datatracker.ietf.org/doc/html/rfc4880#section-5.10\n                // - [Padding Packets] MUST be ignored when received: https://datatracker.ietf.org/doc/html/draft-ietf-openpgp-crypto-refresh#name-padding-packet-tag-21\n                return;\n              }\n              const packet = newPacketFromTag(parsed.tag, allowedPackets);\n              // Unknown packets throw in the call above, we ignore them\n              // in the grammar checker.\n              try {\n                grammarValidator?.recordPacket(parsed.tag, additionalAllowedPackets);\n              } catch (e) {\n                if (config.enforceGrammar) {\n                  throw e;\n                } else {\n                  util.printDebugError(e);\n                }\n              }\n              packet.packets = new PacketList();\n              packet.fromStream = util.isStream(parsed.packet);\n              wasStream = packet.fromStream;\n              try {\n                await packet.read(parsed.packet, config);\n              } catch (e) {\n                if (!(e instanceof UnsupportedError)) {\n                  throw util.wrapError(new MalformedPacketError(`Parsing ${packet.constructor.name} failed`), e);\n                }\n                throw e;\n              }\n              await writer.write(packet);\n            } catch (e) {\n              // If an implementation encounters a critical packet where the packet type is unknown in a packet sequence,\n              // it MUST reject the whole packet sequence. On the other hand, an unknown non-critical packet MUST be ignored.\n              // Packet Tags from 0 to 39 are critical. Packet Tags from 40 to 63 are non-critical.\n              const throwUnknownPacketError =\n                e instanceof UnknownPacketError &&\n                parsed.tag <= 39;\n              // In case of unsupported packet versions/algorithms/etc, we ignore the error by default\n              // (unless the packet is a data packet, see below).\n              const throwUnsupportedError =\n                e instanceof UnsupportedError &&\n                !(e instanceof UnknownPacketError) &&\n                !config.ignoreUnsupportedPackets;\n              // In case of packet parsing errors, e.name was set to 'MalformedPacketError' above.\n              // By default, we throw for these errors.\n              const throwMalformedPacketError =\n                e instanceof MalformedPacketError &&\n                !config.ignoreMalformedPackets;\n              // The packets that support streaming are the ones that contain message data.\n              // Those are also the ones we want to be more strict about and throw on all errors\n              // (since we likely cannot process the message without these packets anyway).\n              const throwDataPacketError = supportsStreaming(parsed.tag);\n              // Throw all other errors, including `GrammarError`s, disallowed packet errors, and unexpected errors.\n              const throwOtherError = !(\n                e instanceof UnknownPacketError ||\n                e instanceof UnsupportedError ||\n                e instanceof MalformedPacketError\n              );\n              if (\n                throwUnknownPacketError ||\n                throwUnsupportedError ||\n                throwMalformedPacketError ||\n                throwDataPacketError ||\n                throwOtherError\n              ) {\n                if (delayErrors) {\n                  unauthenticatedError = e;\n                } else {\n                  await writer.abort(e);\n                }\n              } else {\n                const unparsedPacket = new UnparseablePacket(parsed.tag, parsed.packet);\n                await writer.write(unparsedPacket);\n              }\n              util.printDebugError(e);\n            }\n          });\n          if (wasStream) {\n            // Don't allow more than one streaming packet, as read errors\n            // may get lost in the second packet's data stream.\n            useStreamType = null;\n          }\n\n          // If there was a parse error, read the entire input first\n          // in case there's an MDC error, which should take precedence.\n          if (unauthenticatedError) {\n            await reader.readToEnd();\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw unauthenticatedError;\n          }\n\n          // We peek to check whether this was the last packet.\n          // We peek 2 bytes instead of 1 because `readPacket` also\n          // peeks 2 bytes, and we want to cut a `subarray` of the\n          // correct length into `web-stream-tools`' `externalBuffer`\n          // as a tiny optimization here.\n          const nextPacket = await reader.peekBytes(2);\n          const done = !nextPacket || !nextPacket.length;\n          if (done) {\n            // Here we are past the MDC check for SEIPDv1 data, hence\n            // the data is always authenticated at this point.\n            try {\n              grammarValidator?.recordEnd();\n            } catch (e) {\n              if (config.enforceGrammar) {\n                throw e;\n              } else {\n                util.printDebugError(e);\n              }\n            }\n            await writer.ready;\n            await writer.close();\n            return;\n          }\n        }\n      } catch (e) {\n        await writer.abort(e);\n      }\n    });\n\n    // Wait until first few packets have been read\n    const reader = streamGetReader(this.stream);\n    while (true) {\n      const { done, value } = await reader.read();\n      if (!done) {\n        this.push(value);\n      } else {\n        this.stream = null;\n      }\n      if (done || supportsStreaming(value.constructor.tag)) {\n        break;\n      }\n    }\n    reader.releaseLock();\n  }\n\n  /**\n   * Creates a binary representation of openpgp objects contained within the\n   * class instance.\n   * @returns {Uint8Array} A Uint8Array containing valid openpgp packets.\n   */\n  write() {\n    const arr = [];\n\n    for (let i = 0; i < this.length; i++) {\n      const tag = this[i] instanceof UnparseablePacket ? this[i].tag : this[i].constructor.tag;\n      const packetbytes = this[i].write();\n      if (util.isStream(packetbytes) && supportsStreaming(this[i].constructor.tag)) {\n        let buffer = [];\n        let bufferLength = 0;\n        const minLength = 512;\n        arr.push(writeTag(tag));\n        arr.push(streamTransform(packetbytes, value => {\n          buffer.push(value);\n          bufferLength += value.length;\n          if (bufferLength >= minLength) {\n            const powerOf2 = Math.min(Math.log(bufferLength) / Math.LN2 | 0, 30);\n            const chunkSize = 2 ** powerOf2;\n            const bufferConcat = util.concat([writePartialLength(powerOf2)].concat(buffer));\n            buffer = [bufferConcat.subarray(1 + chunkSize)];\n            bufferLength = buffer[0].length;\n            return bufferConcat.subarray(0, 1 + chunkSize);\n          }\n        }, () => util.concat([writeSimpleLength(bufferLength)].concat(buffer))));\n      } else {\n        if (util.isStream(packetbytes)) {\n          let length = 0;\n          arr.push(streamTransform(streamClone(packetbytes), value => {\n            length += value.length;\n          }, () => writeHeader(tag, length)));\n        } else {\n          arr.push(writeHeader(tag, packetbytes.length));\n        }\n        arr.push(packetbytes);\n      }\n    }\n\n    return util.concat(arr);\n  }\n\n  /**\n   * Creates a new PacketList with all packets matching the given tag(s)\n   * @param {...module:enums.packet} tags - packet tags to look for\n   * @returns {PacketList}\n   */\n  filterByTag(...tags) {\n    const filtered = new PacketList();\n\n    const handle = tag => packetType => tag === packetType;\n\n    for (let i = 0; i < this.length; i++) {\n      if (tags.some(handle(this[i].constructor.tag))) {\n        filtered.push(this[i]);\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Traverses packet list and returns first packet with matching tag\n   * @param {module:enums.packet} tag - The packet tag\n   * @returns {Packet|undefined}\n   */\n  findPacket(tag) {\n    return this.find(packet => packet.constructor.tag === tag);\n  }\n\n  /**\n   * Find indices of packets with the given tag(s)\n   * @param {...module:enums.packet} tags - packet tags to look for\n   * @returns {Integer[]} packet indices\n   */\n  indexOfTag(...tags) {\n    const tagIndex = [];\n    const that = this;\n\n    const handle = tag => packetType => tag === packetType;\n\n    for (let i = 0; i < this.length; i++) {\n      if (tags.some(handle(that[i].constructor.tag))) {\n        tagIndex.push(i);\n      }\n    }\n    return tagIndex;\n  }\n}\n\nexport default PacketList;\n","import enums from '../enums';\n\nexport class GrammarError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GrammarError);\n    }\n\n    this.name = 'GrammarError';\n  }\n}\n\nenum MessageType {\n  EmptyMessage, // incl. empty signed message\n  PlaintextOrEncryptedData,\n  EncryptedSessionKeys,\n  StandaloneAdditionalAllowedData\n}\n\n/**\n * Implement OpenPGP message grammar based on: https://www.rfc-editor.org/rfc/rfc9580.html#section-10.3 .\n * It is slightly more lenient as it also allows standalone ESK sequences, as well as empty (signed) messages.\n * This latter case is needed to allow unknown packets.\n * A new `MessageGrammarValidator` instance must be created for each packet sequence, as the instance is stateful:\n * - `recordPacket` must be called for each packet in the sequence; the function will throw as soon as\n *  an invalid packet is detected.\n * - `recordEnd` must be called at the end of the packet sequence to confirm its validity.\n */\nexport class MessageGrammarValidator {\n  // PDA validator inspired by https://blog.jabberhead.tk/2022/10/26/implementing-packet-sequence-validation-using-pushdown-automata/ .\n  private state: MessageType = MessageType.EmptyMessage;\n  private leadingOnePassSignatureCounter: number = 0;\n\n  /**\n   * Determine validity of the next packet in the sequence.\n   * NB: padding, marker and unknown packets are expected to already be filtered out on parsing,\n   * and are not accepted by `recordPacket`.\n   * @param packet - packet to validate\n   * @param additionalAllowedPackets - object containing packets which are allowed anywhere in the sequence, except they cannot precede a OPS packet\n   * @throws {GrammarError} on invalid `packet` input\n   */\n  recordPacket(packet: enums.packet, additionalAllowedPackets?: { [key in enums.packet]: any }) {\n    switch (this.state) {\n      case MessageType.EmptyMessage:\n      case MessageType.StandaloneAdditionalAllowedData:\n        switch (packet) {\n          case enums.packet.literalData:\n          case enums.packet.compressedData:\n          case enums.packet.aeadEncryptedData:\n          case enums.packet.symEncryptedIntegrityProtectedData:\n          case enums.packet.symmetricallyEncryptedData:\n            this.state = MessageType.PlaintextOrEncryptedData;\n            return;\n          case enums.packet.signature:\n            // Signature | <AdditionalAllowedPacketsOnly> and\n            // OPS | Signature | <AdditionalAllowedPacketsOnly> | Signature and\n            // OPS | <AdditionalAllowedPacketsOnly> | Signature are allowed\n            if (this.state === MessageType.StandaloneAdditionalAllowedData) {\n              if (--this.leadingOnePassSignatureCounter < 0) {\n                throw new GrammarError('Trailing signature packet without OPS');\n              }\n            }\n            // this.state remains EmptyMessage or StandaloneAdditionalAllowedData\n            return;\n          case enums.packet.onePassSignature:\n            if (this.state === MessageType.StandaloneAdditionalAllowedData) {\n              // we do not allow this case, for simplicity\n              throw new GrammarError('OPS following StandaloneAdditionalAllowedData');\n            }\n            this.leadingOnePassSignatureCounter++;\n            // this.state remains EmptyMessage\n            return;\n          case enums.packet.publicKeyEncryptedSessionKey:\n          case enums.packet.symEncryptedSessionKey:\n            this.state = MessageType.EncryptedSessionKeys;\n            return;\n          default:\n            if (!additionalAllowedPackets?.[packet]) {\n              throw new GrammarError(`Unexpected packet ${packet} in state ${this.state}`);\n            }\n            this.state = MessageType.StandaloneAdditionalAllowedData;\n            return;\n        }\n      case MessageType.PlaintextOrEncryptedData:\n        switch (packet) {\n          case enums.packet.signature:\n            if (--this.leadingOnePassSignatureCounter < 0) {\n              throw new GrammarError('Trailing signature packet without OPS');\n            }\n            this.state = MessageType.PlaintextOrEncryptedData;\n            return;\n          default:\n            if (!additionalAllowedPackets?.[packet]) {\n              throw new GrammarError(`Unexpected packet ${packet} in state ${this.state}`);\n            }\n            this.state = MessageType.PlaintextOrEncryptedData;\n            return;\n        }\n      case MessageType.EncryptedSessionKeys:\n        switch (packet) {\n          case enums.packet.publicKeyEncryptedSessionKey:\n          case enums.packet.symEncryptedSessionKey:\n            this.state = MessageType.EncryptedSessionKeys;\n            return;\n          case enums.packet.symEncryptedIntegrityProtectedData:\n          case enums.packet.aeadEncryptedData:\n          case enums.packet.symmetricallyEncryptedData:\n            this.state = MessageType.PlaintextOrEncryptedData;\n            return;\n          case enums.packet.signature:\n            if (--this.leadingOnePassSignatureCounter < 0) {\n              throw new GrammarError('Trailing signature packet without OPS');\n            }\n            this.state = MessageType.PlaintextOrEncryptedData;\n            return;\n          default:\n            if (!additionalAllowedPackets?.[packet]) {\n              throw new GrammarError(`Unexpected packet ${packet} in state ${this.state}`);\n            }\n            this.state = MessageType.EncryptedSessionKeys;\n        }\n    }\n  }\n\n  /**\n   * Signal end of the packet sequence for final validity check\n   * @throws {GrammarError} on invalid sequence\n   */\n  recordEnd() {\n    switch (this.state) {\n      case MessageType.EmptyMessage: // needs to be allowed for PacketLists that only include unknown packets\n      case MessageType.PlaintextOrEncryptedData:\n      case MessageType.EncryptedSessionKeys:\n      case MessageType.StandaloneAdditionalAllowedData:\n        if (this.leadingOnePassSignatureCounter > 0) {\n          throw new GrammarError('Missing trailing signature packets');\n        }\n    }\n  }\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { Inflate, Deflate, Zlib, Unzlib } from 'fflate';\nimport { isArrayStream, fromAsync as streamFromAsync, parse as streamParse, readToEnd as streamReadToEnd } from '@openpgp/web-stream-tools';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\nimport LiteralDataPacket from './literal_data';\nimport OnePassSignaturePacket from './one_pass_signature';\nimport SignaturePacket from './signature';\nimport PacketList from './packetlist';\nimport { MessageGrammarValidator } from './grammar';\n\n// A Compressed Data packet can contain the following packet types\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n\n/**\n * Implementation of the Compressed Data Packet (Tag 8)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.6|RFC4880 5.6}:\n * The Compressed Data packet contains compressed data.  Typically,\n * this packet is found as the contents of an encrypted packet, or following\n * a Signature or One-Pass Signature packet, and contains a literal data packet.\n */\nclass CompressedDataPacket {\n  static get tag() {\n    return enums.packet.compressedData;\n  }\n\n  /**\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(config = defaultConfig) {\n    /**\n     * List of packets\n     * @type {PacketList}\n     */\n    this.packets = null;\n    /**\n     * Compression algorithm\n     * @type {enums.compression}\n     */\n    this.algorithm = config.preferredCompressionAlgorithm;\n\n    /**\n     * Compressed packet data\n     * @type {Uint8Array | ReadableStream<Uint8Array>}\n     */\n    this.compressed = null;\n  }\n\n  /**\n   * Parsing function for the packet.\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes - Payload of a tag 8 packet\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  async read(bytes, config = defaultConfig) {\n    await streamParse(bytes, async reader => {\n\n      // One octet that gives the algorithm used to compress the packet.\n      this.algorithm = await reader.readByte();\n\n      // Compressed data, which makes up the remainder of the packet.\n      this.compressed = reader.remainder();\n\n      await this.decompress(config);\n    });\n  }\n\n\n  /**\n   * Return the compressed packet.\n   * @returns {Uint8Array | ReadableStream<Uint8Array>} Binary compressed packet.\n   */\n  write() {\n    if (this.compressed === null) {\n      this.compress();\n    }\n\n    return util.concat([new Uint8Array([this.algorithm]), this.compressed]);\n  }\n\n\n  /**\n   * Decompression method for decompressing the compressed data\n   * read by read_packet\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  async decompress(config = defaultConfig) {\n    const compressionName = enums.read(enums.compression, this.algorithm);\n    const decompressionFn = decompress_fns[compressionName]; // bzip decompression is async\n    if (!decompressionFn) {\n      throw new Error(`${compressionName} decompression not supported`);\n    }\n\n    // Decompressing a Compressed Data packet MUST also yield a valid OpenPGP Message\n    this.packets = await PacketList.fromBinary(await decompressionFn(this.compressed), allowedPackets, config, new MessageGrammarValidator());\n  }\n\n  /**\n   * Compress the packet data (member decompressedData)\n   */\n  compress() {\n    const compressionName = enums.read(enums.compression, this.algorithm);\n    const compressionFn = compress_fns[compressionName];\n    if (!compressionFn) {\n      throw new Error(`${compressionName} compression not supported`);\n    }\n\n    this.compressed = compressionFn(this.packets.write());\n  }\n}\n\nexport default CompressedDataPacket;\n\n//////////////////////////\n//                      //\n//   Helper functions   //\n//                      //\n//////////////////////////\n\n/**\n * Zlib processor relying on Compression Stream API if available, or falling back to fflate otherwise.\n * @param {function(): CompressionStream|function(): DecompressionStream} compressionStreamInstantiator\n * @param {FunctionConstructor} ZlibStreamedConstructor - fflate constructor\n * @returns {ReadableStream<Uint8Array>} compressed or decompressed data\n */\nfunction zlib(compressionStreamInstantiator, ZlibStreamedConstructor) {\n  return data => {\n    if (!util.isStream(data) || isArrayStream(data)) {\n      return streamFromAsync(() => streamReadToEnd(data).then(inputData => {\n        return new Promise((resolve, reject) => {\n          const zlibStream = new ZlibStreamedConstructor();\n          const processedChunks = [];\n          zlibStream.ondata = (processedData, final) => {\n            processedChunks.push(processedData);\n            if (final) {\n              resolve(util.concatUint8Array(processedChunks));\n            }\n          };\n          try {\n            zlibStream.push(inputData, true); // only one chunk to push\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }));\n    }\n\n    // Use Compression Streams API if available (see https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API)\n    if (compressionStreamInstantiator) {\n      try {\n        const compressorOrDecompressor = compressionStreamInstantiator();\n        return data.pipeThrough(compressorOrDecompressor);\n      } catch (err) {\n        // If format is unsupported in Compression/DecompressionStream, then a TypeError in thrown, and we fallback to fflate.\n        if (err.name !== 'TypeError') {\n          throw err;\n        }\n      }\n    }\n\n    // JS fallback\n    const inputReader = data.getReader();\n    const zlibStream = new ZlibStreamedConstructor();\n\n    return new ReadableStream({\n      async start(controller) {\n        zlibStream.ondata = async (value, isLast) => {\n          controller.enqueue(value);\n          if (isLast) {\n            controller.close();\n          }\n        };\n\n        while (true) {\n          const { done, value } = await inputReader.read();\n          if (done) {\n            zlibStream.push(new Uint8Array(), true);\n            return;\n          } else if (value.length) {\n            zlibStream.push(value);\n          }\n        }\n      }\n    });\n  };\n}\n\nfunction bzip2Decompress() {\n  return async function(data) {\n    const { decode: bunzipDecode } = await import('@openpgp/seek-bzip');\n    return streamFromAsync(async () => bunzipDecode(await streamReadToEnd(data)));\n  };\n}\n\n/**\n * Get Compression Stream API instatiators if the constructors are implemented.\n * NB: the return instatiator functions will throw when called if the provided `compressionFormat` is not supported\n * (supported formats cannot be determined in advance).\n * @param {'deflate-raw'|'deflate'|'gzip'|string} compressionFormat\n * @returns {{ compressor: function(): CompressionStream | false, decompressor: function(): DecompressionStream | false }}\n */\nconst getCompressionStreamInstantiators = compressionFormat => ({\n  compressor: typeof CompressionStream !== 'undefined' && (() => new CompressionStream(compressionFormat)),\n  decompressor: typeof DecompressionStream !== 'undefined' && (() => new DecompressionStream(compressionFormat))\n});\n\nconst compress_fns = {\n  zip: /*#__PURE__*/ zlib(getCompressionStreamInstantiators('deflate-raw').compressor, Deflate),\n  zlib: /*#__PURE__*/ zlib(getCompressionStreamInstantiators('deflate').compressor, Zlib)\n};\n\nconst decompress_fns = {\n  uncompressed: data => data,\n  zip: /*#__PURE__*/ zlib(getCompressionStreamInstantiators('deflate-raw').decompressor, Inflate),\n  zlib: /*#__PURE__*/ zlib(getCompressionStreamInstantiators('deflate').decompressor, Unzlib),\n  bzip2: /*#__PURE__*/ bzip2Decompress() // NB: async due to dynamic lib import\n};\n\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { slice as streamSlice, passiveClone as streamPassiveClone, readToEnd as streamReadToEnd, concat as streamConcat, fromAsync as streamFromAsync, getReader as streamGetReader, getWriter as streamGetWriter, clone as streamClone, pipe as streamPipe, transformPair as streamTransformPair, isArrayStream, parse as streamParse } from '@openpgp/web-stream-tools';\nimport { cipherMode, getRandomBytes, getCipherParams, computeDigest } from '../crypto';\nimport computeHKDF from '../crypto/hkdf';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\nimport LiteralDataPacket from './literal_data';\nimport CompressedDataPacket from './compressed_data';\nimport OnePassSignaturePacket from './one_pass_signature';\nimport SignaturePacket from './signature';\nimport PacketList from './packetlist';\nimport { UnsupportedError } from './packet';\nimport { MessageGrammarValidator } from './grammar';\n\n// A SEIP packet can contain the following packet types\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  CompressedDataPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n\n/**\n * Implementation of the Sym. Encrypted Integrity Protected Data Packet (Tag 18)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.13|RFC4880 5.13}:\n * The Symmetrically Encrypted Integrity Protected Data packet is\n * a variant of the Symmetrically Encrypted Data packet. It is a new feature\n * created for OpenPGP that addresses the problem of detecting a modification to\n * encrypted data. It is used in combination with a Modification Detection Code\n * packet.\n */\nclass SymEncryptedIntegrityProtectedDataPacket {\n  static get tag() {\n    return enums.packet.symEncryptedIntegrityProtectedData;\n  }\n\n  static fromObject({ version, aeadAlgorithm }) {\n    if (version !== 1 && version !== 2) {\n      throw new Error('Unsupported SEIPD version');\n    }\n\n    const seip = new SymEncryptedIntegrityProtectedDataPacket();\n    seip.version = version;\n    if (version === 2) {\n      seip.aeadAlgorithm = aeadAlgorithm;\n    }\n\n    return seip;\n  }\n\n  constructor() {\n    this.version = null;\n\n    // The following 4 fields are for V2 only.\n    /** @type {enums.symmetric} */\n    this.cipherAlgorithm = null;\n    /** @type {enums.aead} */\n    this.aeadAlgorithm = null;\n    this.chunkSizeByte = null;\n    this.salt = null;\n\n    this.encrypted = null;\n    this.packets = null;\n  }\n\n  async read(bytes) {\n    await streamParse(bytes, async reader => {\n      this.version = await reader.readByte();\n      // - A one-octet version number with value 1 or 2.\n      if (this.version !== 1 && this.version !== 2) {\n        throw new UnsupportedError(`Version ${this.version} of the SEIP packet is unsupported.`);\n      }\n\n      if (this.version === 2) {\n        // - A one-octet cipher algorithm.\n        this.cipherAlgorithm = await reader.readByte();\n        // - A one-octet AEAD algorithm.\n        this.aeadAlgorithm = await reader.readByte();\n        // - A one-octet chunk size.\n        this.chunkSizeByte = await reader.readByte();\n        // - Thirty-two octets of salt. The salt is used to derive the message key and must be unique.\n        this.salt = await reader.readBytes(32);\n      }\n\n      // For V1:\n      // - Encrypted data, the output of the selected symmetric-key cipher\n      //   operating in Cipher Feedback mode with shift amount equal to the\n      //   block size of the cipher (CFB-n where n is the block size).\n      // For V2:\n      // - Encrypted data, the output of the selected symmetric-key cipher operating in the given AEAD mode.\n      // - A final, summary authentication tag for the AEAD mode.\n      this.encrypted = reader.remainder();\n    });\n  }\n\n  write() {\n    if (this.version === 2) {\n      return util.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.salt, this.encrypted]);\n    }\n    return util.concat([new Uint8Array([this.version]), this.encrypted]);\n  }\n\n  /**\n   * Encrypt the payload in the packet.\n   * @param {enums.symmetric} sessionKeyAlgorithm - The symmetric encryption algorithm to use\n   * @param {Uint8Array} key - The key of cipher blocksize length to be used\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Boolean>}\n   * @throws {Error} on encryption failure\n   * @async\n   */\n  async encrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    // We check that the session key size matches the one expected by the symmetric algorithm.\n    // This is especially important for SEIPDv2 session keys, as a key derivation step is run where the resulting key will always match the expected cipher size,\n    // but we want to ensure that the input key isn't e.g. too short.\n    // The check is done here, instead of on encrypted session key (ESK) encryption, because v6 ESK packets do not store the session key algorithm,\n    // which is instead included in the SEIPDv2 data.\n    const { blockSize, keySize } = getCipherParams(sessionKeyAlgorithm);\n    if (key.length !== keySize) {\n      throw new Error('Unexpected session key size');\n    }\n\n    let bytes = this.packets.write();\n    if (isArrayStream(bytes)) bytes = await streamReadToEnd(bytes);\n\n    if (this.version === 2) {\n      this.cipherAlgorithm = sessionKeyAlgorithm;\n\n      this.salt = getRandomBytes(32);\n      this.chunkSizeByte = config.aeadChunkSizeByte;\n      this.encrypted = await runAEAD(this, 'encrypt', key, bytes);\n    } else {\n      const prefix = await cipherMode.cfb.getPrefixRandom(sessionKeyAlgorithm);\n      const mdc = new Uint8Array([0xD3, 0x14]); // modification detection code packet\n\n      const tohash = util.concat([prefix, bytes, mdc]);\n      const hash = await computeDigest(enums.hash.sha1, streamPassiveClone(tohash));\n      const plaintext = util.concat([tohash, hash]);\n\n      this.encrypted = await cipherMode.cfb.encrypt(sessionKeyAlgorithm, key, plaintext, new Uint8Array(blockSize), config);\n    }\n    return true;\n  }\n\n  /**\n   * Decrypts the encrypted data contained in the packet.\n   * @param {enums.symmetric} sessionKeyAlgorithm - The selected symmetric encryption algorithm to be used\n   * @param {Uint8Array} key - The key of cipher blocksize length to be used\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Boolean>}\n   * @throws {Error} on decryption failure\n   * @async\n   */\n  async decrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    // We check that the session key size matches the one expected by the symmetric algorithm.\n    // This is especially important for SEIPDv2 session keys, as a key derivation step is run where the resulting key will always match the expected cipher size,\n    // but we want to ensure that the input key isn't e.g. too short.\n    // The check is done here, instead of on encrypted session key (ESK) decryption, because v6 ESK packets do not store the session key algorithm,\n    // which is instead included in the SEIPDv2 data.\n    if (key.length !== getCipherParams(sessionKeyAlgorithm).keySize) {\n      throw new Error('Unexpected session key size');\n    }\n\n    let encrypted = streamClone(this.encrypted);\n    if (isArrayStream(encrypted)) encrypted = await streamReadToEnd(encrypted);\n\n    let packetbytes;\n    let delayErrors = false;\n    if (this.version === 2) {\n      if (this.cipherAlgorithm !== sessionKeyAlgorithm) {\n        // sanity check\n        throw new Error('Unexpected session key algorithm');\n      }\n      packetbytes = await runAEAD(this, 'decrypt', key, encrypted);\n    } else {\n      const { blockSize } = getCipherParams(sessionKeyAlgorithm);\n      const decrypted = await cipherMode.cfb.decrypt(sessionKeyAlgorithm, key, encrypted, new Uint8Array(blockSize));\n\n      // there must be a modification detection code packet as the\n      // last packet and everything gets hashed except the hash itself\n      const realHash = streamSlice(streamPassiveClone(decrypted), -20);\n      const tohash = streamSlice(decrypted, 0, -20);\n      const verifyHash = Promise.all([\n        streamReadToEnd(await computeDigest(enums.hash.sha1, streamPassiveClone(tohash))),\n        streamReadToEnd(realHash)\n      ]).then(([hash, mdc]) => {\n        if (!util.equalsUint8Array(hash, mdc)) {\n          throw new Error('Modification detected.');\n        }\n        // this last chunk comes at the end of the stream passed to Packetlist.read's streamTransformPair,\n        // which can thus be 'done' only after the MDC has been checked.\n        return new Uint8Array();\n      });\n      const bytes = streamSlice(tohash, blockSize + 2); // Remove random prefix\n      packetbytes = streamSlice(bytes, 0, -2); // Remove MDC packet\n      packetbytes = streamConcat([packetbytes, streamFromAsync(() => verifyHash)]);\n      if (util.isStream(encrypted) && config.allowUnauthenticatedStream) {\n        delayErrors = true;\n      } else {\n        packetbytes = await streamReadToEnd(packetbytes);\n      }\n    }\n\n    // - Decrypting a version 1 Symmetrically Encrypted and Integrity Protected Data packet\n    // MUST yield a valid OpenPGP Message.\n    // - Decrypting a version 2 Symmetrically Encrypted and Integrity Protected Data packet\n    // MUST yield a valid Optionally Padded Message.\n    this.packets = await PacketList.fromBinary(packetbytes, allowedPackets, config, new MessageGrammarValidator(), delayErrors);\n    return true;\n  }\n}\n\nexport default SymEncryptedIntegrityProtectedDataPacket;\n\n/**\n * En/decrypt the payload.\n * @param {encrypt|decrypt} fn - Whether to encrypt or decrypt\n * @param {Uint8Array} key - The session key used to en/decrypt the payload\n * @param {Uint8Array | ReadableStream<Uint8Array>} data - The data to en/decrypt\n * @returns {Promise<Uint8Array | ReadableStream<Uint8Array>>}\n * @async\n */\nexport async function runAEAD(packet, fn, key, data) {\n  const isSEIPDv2 = packet instanceof SymEncryptedIntegrityProtectedDataPacket && packet.version === 2;\n  const isAEADP = !isSEIPDv2 && packet.constructor.tag === enums.packet.aeadEncryptedData; // no `instanceof` to avoid importing the corresponding class (circular import)\n  if (!isSEIPDv2 && !isAEADP) throw new Error('Unexpected packet type');\n\n  // we allow `experimentalGCM` for AEADP for backwards compatibility, since v5 keys from OpenPGP.js v5 might be declaring\n  // that preference, as the `gcm` ID had not been standardized at the time.\n  // NB: AEADP are never automatically generate as part of message encryption by OpenPGP.js, the packet must be manually created.\n  const mode = cipherMode.getAEADMode(packet.aeadAlgorithm, isAEADP);\n  const tagLengthIfDecrypting = fn === 'decrypt' ? mode.tagLength : 0;\n  const tagLengthIfEncrypting = fn === 'encrypt' ? mode.tagLength : 0;\n  const chunkSize = 2 ** (packet.chunkSizeByte + 6) + tagLengthIfDecrypting; // ((uint64_t)1 << (c + 6))\n  const chunkIndexSizeIfAEADEP = isAEADP ? 8 : 0;\n  const adataBuffer = new ArrayBuffer(13 + chunkIndexSizeIfAEADEP);\n  const adataArray = new Uint8Array(adataBuffer, 0, 5 + chunkIndexSizeIfAEADEP);\n  const adataTagArray = new Uint8Array(adataBuffer);\n  const adataView = new DataView(adataBuffer);\n  const chunkIndexArray = new Uint8Array(adataBuffer, 5, 8);\n  adataArray.set([0xC0 | packet.constructor.tag, packet.version, packet.cipherAlgorithm, packet.aeadAlgorithm, packet.chunkSizeByte], 0);\n  let chunkIndex = 0;\n  let latestPromise = Promise.resolve();\n  let cryptedBytes = 0;\n  let queuedBytes = 0;\n  let iv;\n  let ivView;\n  if (isSEIPDv2) {\n    const { keySize } = getCipherParams(packet.cipherAlgorithm);\n    const { ivLength } = mode;\n    const info = new Uint8Array(adataBuffer, 0, 5);\n    const derived = await computeHKDF(enums.hash.sha256, key, packet.salt, info, keySize + ivLength);\n    key = derived.subarray(0, keySize);\n    iv = derived.subarray(keySize); // The last 8 bytes of HKDF output are unneeded, but this avoids one copy.\n    iv.fill(0, iv.length - 8);\n    ivView = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);\n  } else { // AEADEncryptedDataPacket\n    iv = packet.iv;\n    // ivView is unused in this case\n  }\n  const modeInstance = await mode(packet.cipherAlgorithm, key);\n  return streamTransformPair(data, async (readable, writable) => {\n    if (util.isStream(readable) !== 'array') {\n      const buffer = new TransformStream({}, {\n        highWaterMark: util.getHardwareConcurrency() * 2 ** (packet.chunkSizeByte + 6),\n        size: array => array.length\n      });\n      streamPipe(buffer.readable, writable);\n      writable = buffer.writable;\n    }\n    const reader = streamGetReader(readable);\n    const writer = streamGetWriter(writable);\n    try {\n      while (true) {\n        let chunk = await reader.readBytes(chunkSize + tagLengthIfDecrypting) || new Uint8Array();\n        const finalChunk = chunk.subarray(chunk.length - tagLengthIfDecrypting);\n        chunk = chunk.subarray(0, chunk.length - tagLengthIfDecrypting);\n        let cryptedPromise;\n        let done;\n        let nonce;\n        if (isSEIPDv2) { // SEIPD V2\n          nonce = iv;\n        } else { // AEADEncryptedDataPacket\n          nonce = iv.slice();\n          for (let i = 0; i < 8; i++) {\n            nonce[iv.length - 8 + i] ^= chunkIndexArray[i];\n          }\n        }\n        if (!chunkIndex || chunk.length) {\n          reader.unshift(finalChunk);\n          cryptedPromise = modeInstance[fn](chunk, nonce, adataArray);\n          cryptedPromise.catch(() => {});\n          queuedBytes += chunk.length - tagLengthIfDecrypting + tagLengthIfEncrypting;\n        } else {\n          // After the last chunk, we either encrypt a final, empty\n          // data chunk to get the final authentication tag or\n          // validate that final authentication tag.\n          adataView.setInt32(5 + chunkIndexSizeIfAEADEP + 4, cryptedBytes); // Should be setInt64(5 + chunkIndexSizeIfAEADEP, ...)\n          cryptedPromise = modeInstance[fn](finalChunk, nonce, adataTagArray);\n          cryptedPromise.catch(() => {});\n          queuedBytes += tagLengthIfEncrypting;\n          done = true;\n        }\n        cryptedBytes += chunk.length - tagLengthIfDecrypting;\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        latestPromise = latestPromise.then(() => cryptedPromise).then(async crypted => {\n          await writer.ready;\n          await writer.write(crypted);\n          queuedBytes -= crypted.length;\n        }).catch(err => writer.abort(err));\n        if (done || queuedBytes > writer.desiredSize) {\n          await latestPromise; // Respect backpressure\n        }\n        if (!done) {\n          if (isSEIPDv2) { // SEIPD V2\n            ivView.setInt32(iv.length - 4, ++chunkIndex); // Should be setInt64(iv.length - 8, ...)\n          } else { // AEADEncryptedDataPacket\n            adataView.setInt32(5 + 4, ++chunkIndex); // Should be setInt64(5, ...)\n          }\n        } else {\n          await writer.close();\n          break;\n        }\n      }\n    } catch (e) {\n      await writer.ready.catch(() => {});\n      await writer.abort(e);\n    }\n  });\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2016 Tankred Hase\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { clone as streamClone, parse as streamParse } from '@openpgp/web-stream-tools';\nimport { cipherMode, getRandomBytes } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\nimport { UnsupportedError } from './packet';\nimport { runAEAD } from './sym_encrypted_integrity_protected_data';\n\nimport LiteralDataPacket from './literal_data';\nimport CompressedDataPacket from './compressed_data';\nimport OnePassSignaturePacket from './one_pass_signature';\nimport SignaturePacket from './signature';\nimport PacketList from './packetlist';\nimport { MessageGrammarValidator } from './grammar';\n\n// An AEAD-encrypted Data packet can contain the following packet types\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  CompressedDataPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n\nconst VERSION = 1; // A one-octet version number of the data packet.\n\n/**\n * Implementation of the Symmetrically Encrypted Authenticated Encryption with\n * Additional Data (AEAD) Protected Data Packet\n *\n * {@link https://tools.ietf.org/html/draft-ford-openpgp-format-00#section-2.1}:\n * AEAD Protected Data Packet\n */\nclass AEADEncryptedDataPacket {\n  static get tag() {\n    return enums.packet.aeadEncryptedData;\n  }\n\n  constructor() {\n    this.version = VERSION;\n    /** @type {enums.symmetric} */\n    this.cipherAlgorithm = null;\n    /** @type {enums.aead} */\n    this.aeadAlgorithm = enums.aead.eax;\n    this.chunkSizeByte = null;\n    this.iv = null;\n    this.encrypted = null;\n    this.packets = null;\n  }\n\n  /**\n   * Parse an encrypted payload of bytes in the order: version, IV, ciphertext (see specification)\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes\n   * @throws {Error} on parsing failure\n   */\n  async read(bytes) {\n    await streamParse(bytes, async reader => {\n      const version = await reader.readByte();\n      if (version !== VERSION) { // The only currently defined value is 1.\n        throw new UnsupportedError(`Version ${version} of the AEAD-encrypted data packet is not supported.`);\n      }\n      this.cipherAlgorithm = await reader.readByte();\n      this.aeadAlgorithm = await reader.readByte();\n      this.chunkSizeByte = await reader.readByte();\n\n      const mode = cipherMode.getAEADMode(this.aeadAlgorithm, true);\n      this.iv = await reader.readBytes(mode.ivLength);\n      this.encrypted = reader.remainder();\n    });\n  }\n\n  /**\n   * Write the encrypted payload of bytes in the order: version, IV, ciphertext (see specification)\n   * @returns {Uint8Array | ReadableStream<Uint8Array>} The encrypted payload.\n   */\n  write() {\n    return util.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.iv, this.encrypted]);\n  }\n\n  /**\n   * Decrypt the encrypted payload.\n   * @param {enums.symmetric} sessionKeyAlgorithm - The session key's cipher algorithm\n   * @param {Uint8Array} key - The session key used to encrypt the payload\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if decryption was not successful\n   * @async\n   */\n  async decrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    this.packets = await PacketList.fromBinary(\n      await runAEAD(this, 'decrypt', key, streamClone(this.encrypted)),\n      allowedPackets,\n      config,\n      new MessageGrammarValidator()\n    );\n  }\n\n  /**\n   * Encrypt the packet payload.\n   * @param {enums.symmetric} sessionKeyAlgorithm - The session key's cipher algorithm\n   * @param {Uint8Array} key - The session key used to encrypt the payload\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if encryption was not successful\n   * @async\n   */\n  async encrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    this.cipherAlgorithm = sessionKeyAlgorithm;\n\n    const { ivLength } = cipherMode.getAEADMode(this.aeadAlgorithm, true);\n    this.iv = getRandomBytes(ivLength); // generate new random IV\n    this.chunkSizeByte = config.aeadChunkSizeByte;\n    const data = this.packets.write();\n    this.encrypted = await runAEAD(this, 'encrypt', key, data);\n  }\n}\n\nexport default AEADEncryptedDataPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport KeyID from '../type/keyid';\nimport { parseEncSessionKeyParams, publicKeyEncrypt, publicKeyDecrypt, getCipherParams, serializeParams } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport { UnsupportedError } from './packet';\n\n/**\n * Public-Key Encrypted Session Key Packets (Tag 1)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.1|RFC4880 5.1}:\n * A Public-Key Encrypted Session Key packet holds the session key\n * used to encrypt a message. Zero or more Public-Key Encrypted Session Key\n * packets and/or Symmetric-Key Encrypted Session Key packets may precede a\n * Symmetrically Encrypted Data Packet, which holds an encrypted message. The\n * message is encrypted with the session key, and the session key is itself\n * encrypted and stored in the Encrypted Session Key packet(s). The\n * Symmetrically Encrypted Data Packet is preceded by one Public-Key Encrypted\n * Session Key packet for each OpenPGP key to which the message is encrypted.\n * The recipient of the message finds a session key that is encrypted to their\n * public key, decrypts the session key, and then uses the session key to\n * decrypt the message.\n */\nclass PublicKeyEncryptedSessionKeyPacket {\n  static get tag() {\n    return enums.packet.publicKeyEncryptedSessionKey;\n  }\n\n  constructor() {\n    this.version = null;\n\n    // For version 3, but also used internally by v6 in e.g. `getEncryptionKeyIDs()`\n    this.publicKeyID = new KeyID();\n\n    // For version 6:\n    this.publicKeyVersion = null;\n    this.publicKeyFingerprint = null;\n\n    // For all versions:\n    this.publicKeyAlgorithm = null;\n\n    this.sessionKey = null;\n    /**\n     * Algorithm to encrypt the message with\n     * @type {enums.symmetric}\n     */\n    this.sessionKeyAlgorithm = null;\n\n    /** @type {Object} */\n    this.encrypted = {};\n  }\n\n  static fromObject({\n    version, encryptionKeyPacket, anonymousRecipient, sessionKey, sessionKeyAlgorithm\n  }) {\n    const pkesk = new PublicKeyEncryptedSessionKeyPacket();\n\n    if (version !== 3 && version !== 6) {\n      throw new Error('Unsupported PKESK version');\n    }\n\n    pkesk.version = version;\n\n    if (version === 6) {\n      pkesk.publicKeyVersion = anonymousRecipient ? null : encryptionKeyPacket.version;\n      pkesk.publicKeyFingerprint = anonymousRecipient ? null : encryptionKeyPacket.getFingerprintBytes();\n    }\n\n    pkesk.publicKeyID = anonymousRecipient ? KeyID.wildcard() : encryptionKeyPacket.getKeyID();\n    pkesk.publicKeyAlgorithm = encryptionKeyPacket.algorithm;\n    pkesk.sessionKey = sessionKey;\n    pkesk.sessionKeyAlgorithm = sessionKeyAlgorithm;\n\n    return pkesk;\n  }\n\n  /**\n   * Parsing function for a publickey encrypted session key packet (tag 1).\n   *\n   * @param {Uint8Array} bytes - Payload of a tag 1 packet\n   */\n  read(bytes) {\n    let offset = 0;\n    this.version = bytes[offset++];\n    if (this.version !== 3 && this.version !== 6) {\n      throw new UnsupportedError(`Version ${this.version} of the PKESK packet is unsupported.`);\n    }\n    if (this.version === 6) {\n      // A one-octet size of the following two fields:\n      // - A one octet key version number.\n      // - The fingerprint of the public key or subkey to which the session key is encrypted.\n      // The size may also be zero.\n      const versionAndFingerprintLength = bytes[offset++];\n      if (versionAndFingerprintLength) {\n        this.publicKeyVersion = bytes[offset++];\n        const fingerprintLength = versionAndFingerprintLength - 1;\n        this.publicKeyFingerprint = bytes.subarray(offset, offset + fingerprintLength); offset += fingerprintLength;\n        if (this.publicKeyVersion >= 5) {\n          // For v5/6 the Key ID is the high-order 64 bits of the fingerprint.\n          this.publicKeyID.read(this.publicKeyFingerprint);\n        } else {\n          // For v4 The Key ID is the low-order 64 bits of the fingerprint.\n          this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8));\n        }\n      } else {\n        // The size may also be zero, and the key version and\n        // fingerprint omitted for an \"anonymous recipient\"\n        this.publicKeyID = KeyID.wildcard();\n      }\n    } else {\n      offset += this.publicKeyID.read(bytes.subarray(offset, offset + 8));\n    }\n    this.publicKeyAlgorithm = bytes[offset++];\n    this.encrypted = parseEncSessionKeyParams(this.publicKeyAlgorithm, bytes.subarray(offset));\n    if (this.publicKeyAlgorithm === enums.publicKey.x25519 || this.publicKeyAlgorithm === enums.publicKey.x448) {\n      if (this.version === 3) {\n        this.sessionKeyAlgorithm = enums.write(enums.symmetric, this.encrypted.C.algorithm);\n      } else if (this.encrypted.C.algorithm !== null) {\n        throw new Error('Unexpected cleartext symmetric algorithm');\n      }\n    }\n  }\n\n  /**\n   * Create a binary representation of a tag 1 packet\n   *\n   * @returns {Uint8Array} The Uint8Array representation.\n   */\n  write() {\n    const arr = [\n      new Uint8Array([this.version])\n    ];\n\n    if (this.version === 6) {\n      if (this.publicKeyFingerprint !== null) {\n        arr.push(new Uint8Array([\n          this.publicKeyFingerprint.length + 1,\n          this.publicKeyVersion]\n        ));\n        arr.push(this.publicKeyFingerprint);\n      } else {\n        arr.push(new Uint8Array([0]));\n      }\n    } else {\n      arr.push(this.publicKeyID.write());\n    }\n\n    arr.push(\n      new Uint8Array([this.publicKeyAlgorithm]),\n      serializeParams(this.publicKeyAlgorithm, this.encrypted)\n    );\n\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n   * Encrypt session key packet\n   * @param {PublicKeyPacket} key - Public key\n   * @throws {Error} if encryption failed\n   * @async\n   */\n  async encrypt(key) {\n    const algo = enums.write(enums.publicKey, this.publicKeyAlgorithm);\n    // No symmetric encryption algorithm identifier is passed to the public-key algorithm for a\n    // v6 PKESK packet, as it is included in the v2 SEIPD packet.\n    const sessionKeyAlgorithm = this.version === 3 ? this.sessionKeyAlgorithm : null;\n    const fingerprint = key.version === 5 ? key.getFingerprintBytes().subarray(0, 20) : key.getFingerprintBytes();\n    const encoded = encodeSessionKey(this.version, algo, sessionKeyAlgorithm, this.sessionKey);\n    this.encrypted = await publicKeyEncrypt(\n      algo, sessionKeyAlgorithm, key.publicParams, encoded, fingerprint);\n  }\n\n  /**\n   * Decrypts the session key (only for public key encrypted session key packets (tag 1)\n   * @param {SecretKeyPacket} key - decrypted private key\n   * @param {Object} [randomSessionKey] - Bogus session key to use in case of sensitive decryption error, or if the decrypted session key is of a different type/size.\n   *                                      This is needed for constant-time processing. Expected object of the form: { sessionKey: Uint8Array, sessionKeyAlgorithm: enums.symmetric }\n   * @throws {Error} if decryption failed, unless `randomSessionKey` is given\n   * @async\n   */\n  async decrypt(key, randomSessionKey) {\n    // check that session key algo matches the secret key algo\n    if (this.publicKeyAlgorithm !== key.algorithm) {\n      throw new Error('Decryption error');\n    }\n\n    const randomPayload = randomSessionKey ?\n      encodeSessionKey(this.version, this.publicKeyAlgorithm, randomSessionKey.sessionKeyAlgorithm, randomSessionKey.sessionKey) :\n      null;\n    const fingerprint = key.version === 5 ? key.getFingerprintBytes().subarray(0, 20) : key.getFingerprintBytes();\n    const decryptedData = await publicKeyDecrypt(this.publicKeyAlgorithm, key.publicParams, key.privateParams, this.encrypted, fingerprint, randomPayload);\n\n    const { sessionKey, sessionKeyAlgorithm } = decodeSessionKey(this.version, this.publicKeyAlgorithm, decryptedData, randomSessionKey);\n\n    if (this.version === 3) {\n      // v3 Montgomery curves have cleartext cipher algo\n      const hasEncryptedAlgo = this.publicKeyAlgorithm !== enums.publicKey.x25519 && this.publicKeyAlgorithm !== enums.publicKey.x448;\n      this.sessionKeyAlgorithm = hasEncryptedAlgo ? sessionKeyAlgorithm : this.sessionKeyAlgorithm;\n\n      if (sessionKey.length !== getCipherParams(this.sessionKeyAlgorithm).keySize) {\n        throw new Error('Unexpected session key size');\n      }\n    }\n    this.sessionKey = sessionKey;\n  }\n}\n\nexport default PublicKeyEncryptedSessionKeyPacket;\n\n\nfunction encodeSessionKey(version, keyAlgo, cipherAlgo, sessionKeyData) {\n  switch (keyAlgo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.elgamal:\n    case enums.publicKey.ecdh:\n      // add checksum\n      return util.concatUint8Array([\n        new Uint8Array(version === 6 ? [] : [cipherAlgo]),\n        sessionKeyData,\n        util.writeChecksum(sessionKeyData.subarray(sessionKeyData.length % 8))\n      ]);\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448:\n      return sessionKeyData;\n    default:\n      throw new Error('Unsupported public key algorithm');\n  }\n}\n\n\nfunction decodeSessionKey(version, keyAlgo, decryptedData, randomSessionKey) {\n  switch (keyAlgo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.elgamal:\n    case enums.publicKey.ecdh: {\n      // verify checksum in constant time\n      const result = decryptedData.subarray(0, decryptedData.length - 2);\n      const checksum = decryptedData.subarray(decryptedData.length - 2);\n      const computedChecksum = util.writeChecksum(result.subarray(result.length % 8));\n      const isValidChecksum = computedChecksum[0] === checksum[0] & computedChecksum[1] === checksum[1];\n      const decryptedSessionKey = version === 6 ?\n        { sessionKeyAlgorithm: null, sessionKey: result } :\n        { sessionKeyAlgorithm: result[0], sessionKey: result.subarray(1) };\n      if (randomSessionKey) {\n        // We must not leak info about the validity of the decrypted checksum or cipher algo.\n        // The decrypted session key must be of the same algo and size as the random session key, otherwise we discard it and use the random data.\n        const isValidPayload = isValidChecksum &\n          decryptedSessionKey.sessionKeyAlgorithm === randomSessionKey.sessionKeyAlgorithm &\n          decryptedSessionKey.sessionKey.length === randomSessionKey.sessionKey.length;\n        return {\n          sessionKey: util.selectUint8Array(isValidPayload, decryptedSessionKey.sessionKey, randomSessionKey.sessionKey),\n          sessionKeyAlgorithm: version === 6 ? null : util.selectUint8(\n            isValidPayload,\n            decryptedSessionKey.sessionKeyAlgorithm,\n            randomSessionKey.sessionKeyAlgorithm\n          )\n        };\n      } else {\n        const isValidPayload = isValidChecksum && (\n          version === 6 || enums.read(enums.symmetric, decryptedSessionKey.sessionKeyAlgorithm));\n        if (isValidPayload) {\n          return decryptedSessionKey;\n        } else {\n          throw new Error('Decryption error');\n        }\n      }\n    }\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448:\n      return {\n        sessionKeyAlgorithm: null,\n        sessionKey: decryptedData\n      };\n    default:\n      throw new Error('Unsupported public key algorithm');\n  }\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { newS2KFromConfig, newS2KFromType } from '../type/s2k';\nimport defaultConfig from '../config';\nimport { cipherMode, generateSessionKey, getCipherParams, getRandomBytes } from '../crypto';\nimport computeHKDF from '../crypto/hkdf';\nimport enums from '../enums';\nimport util from '../util';\nimport { UnsupportedError } from './packet';\n\n/**\n * Symmetric-Key Encrypted Session Key Packets (Tag 3)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.3|RFC4880 5.3}:\n * The Symmetric-Key Encrypted Session Key packet holds the\n * symmetric-key encryption of a session key used to encrypt a message.\n * Zero or more Public-Key Encrypted Session Key packets and/or\n * Symmetric-Key Encrypted Session Key packets may precede a\n * Symmetrically Encrypted Data packet that holds an encrypted message.\n * The message is encrypted with a session key, and the session key is\n * itself encrypted and stored in the Encrypted Session Key packet or\n * the Symmetric-Key Encrypted Session Key packet.\n */\nclass SymEncryptedSessionKeyPacket {\n  static get tag() {\n    return enums.packet.symEncryptedSessionKey;\n  }\n\n  /**\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(config = defaultConfig) {\n    this.version = config.aeadProtect ? 6 : 4;\n    this.sessionKey = null;\n    /**\n     * Algorithm to encrypt the session key with\n     * @type {enums.symmetric}\n     */\n    this.sessionKeyEncryptionAlgorithm = null;\n    /**\n     * Algorithm to encrypt the message with\n     * @type {enums.symmetric}\n     */\n    this.sessionKeyAlgorithm = null;\n    /**\n     * AEAD mode to encrypt the session key with (if AEAD protection is enabled)\n     * @type {enums.aead}\n     */\n    this.aeadAlgorithm = enums.write(enums.aead, config.preferredAEADAlgorithm);\n    this.encrypted = null;\n    this.s2k = null;\n    this.iv = null;\n  }\n\n  /**\n   * Parsing function for a symmetric encrypted session key packet (tag 3).\n   *\n   * @param {Uint8Array} bytes - Payload of a tag 3 packet\n   */\n  read(bytes) {\n    let offset = 0;\n\n    // A one-octet version number with value 4, 5 or 6.\n    this.version = bytes[offset++];\n    if (this.version !== 4 && this.version !== 5 && this.version !== 6) {\n      throw new UnsupportedError(`Version ${this.version} of the SKESK packet is unsupported.`);\n    }\n\n    if (this.version === 6) {\n      // A one-octet scalar octet count of the following 5 fields.\n      offset++;\n    }\n\n    // A one-octet number describing the symmetric algorithm used.\n    const algo = bytes[offset++];\n\n    if (this.version >= 5) {\n      // A one-octet AEAD algorithm.\n      this.aeadAlgorithm = bytes[offset++];\n\n      if (this.version === 6) {\n        // A one-octet scalar octet count of the following field.\n        offset++;\n      }\n    }\n\n    // A string-to-key (S2K) specifier, length as defined above.\n    const s2kType = bytes[offset++];\n    this.s2k = newS2KFromType(s2kType);\n    offset += this.s2k.read(bytes.subarray(offset, bytes.length));\n\n    if (this.version >= 5) {\n      const mode = cipherMode.getAEADMode(this.aeadAlgorithm, true);\n\n      // A starting initialization vector of size specified by the AEAD\n      // algorithm.\n      this.iv = bytes.subarray(offset, offset += mode.ivLength);\n    }\n\n    // The encrypted session key itself, which is decrypted with the\n    // string-to-key object. This is optional in version 4.\n    if (this.version >= 5 || offset < bytes.length) {\n      this.encrypted = bytes.subarray(offset, bytes.length);\n      this.sessionKeyEncryptionAlgorithm = algo;\n    } else {\n      this.sessionKeyAlgorithm = algo;\n    }\n  }\n\n  /**\n   * Create a binary representation of a tag 3 packet\n   *\n   * @returns {Uint8Array} The Uint8Array representation.\n  */\n  write() {\n    const algo = this.encrypted === null ?\n      this.sessionKeyAlgorithm :\n      this.sessionKeyEncryptionAlgorithm;\n\n    let bytes;\n\n    const s2k = this.s2k.write();\n    if (this.version === 6) {\n      const s2kLen = s2k.length;\n      const fieldsLen = 3 + s2kLen + this.iv.length;\n      bytes = util.concatUint8Array([new Uint8Array([this.version, fieldsLen, algo, this.aeadAlgorithm, s2kLen]), s2k, this.iv, this.encrypted]);\n    } else if (this.version === 5) {\n      bytes = util.concatUint8Array([new Uint8Array([this.version, algo, this.aeadAlgorithm]), s2k, this.iv, this.encrypted]);\n    } else {\n      bytes = util.concatUint8Array([new Uint8Array([this.version, algo]), s2k]);\n\n      if (this.encrypted !== null) {\n        bytes = util.concatUint8Array([bytes, this.encrypted]);\n      }\n    }\n\n    return bytes;\n  }\n\n  /**\n   * Decrypts the session key with the given passphrase\n   * @param {String} passphrase - The passphrase in string form\n   * @throws {Error} if decryption was not successful\n   * @async\n   */\n  async decrypt(passphrase) {\n    const algo = this.sessionKeyEncryptionAlgorithm !== null ?\n      this.sessionKeyEncryptionAlgorithm :\n      this.sessionKeyAlgorithm;\n\n    const { blockSize, keySize } = getCipherParams(algo);\n    const key = await this.s2k.produceKey(passphrase, keySize);\n\n    if (this.version >= 5) {\n      const mode = cipherMode.getAEADMode(this.aeadAlgorithm, true);\n      const adata = new Uint8Array([0xC0 | SymEncryptedSessionKeyPacket.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]);\n      const encryptionKey = this.version === 6 ? await computeHKDF(enums.hash.sha256, key, new Uint8Array(), adata, keySize) : key;\n      const modeInstance = await mode(algo, encryptionKey);\n      this.sessionKey = await modeInstance.decrypt(this.encrypted, this.iv, adata);\n    } else if (this.encrypted !== null) {\n      const decrypted = await cipherMode.cfb.decrypt(algo, key, this.encrypted, new Uint8Array(blockSize));\n\n      this.sessionKeyAlgorithm = enums.write(enums.symmetric, decrypted[0]);\n      this.sessionKey = decrypted.subarray(1, decrypted.length);\n      if (this.sessionKey.length !== getCipherParams(this.sessionKeyAlgorithm).keySize) {\n        throw new Error('Unexpected session key size');\n      }\n    } else {\n      // session key size is checked as part of SEIPDv2 decryption, where we know the expected symmetric algo\n      this.sessionKey = key;\n    }\n  }\n\n  /**\n   * Encrypts the session key with the given passphrase\n   * @param {String} passphrase - The passphrase in string form\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if encryption was not successful\n   * @async\n   */\n  async encrypt(passphrase, config = defaultConfig) {\n    const algo = this.sessionKeyEncryptionAlgorithm !== null ?\n      this.sessionKeyEncryptionAlgorithm :\n      this.sessionKeyAlgorithm;\n\n    this.sessionKeyEncryptionAlgorithm = algo;\n\n    this.s2k = newS2KFromConfig(config);\n    this.s2k.generateSalt();\n\n    const { blockSize, keySize } = getCipherParams(algo);\n    const key = await this.s2k.produceKey(passphrase, keySize);\n\n    if (this.sessionKey === null) {\n      this.sessionKey = generateSessionKey(this.sessionKeyAlgorithm);\n    }\n\n    if (this.version >= 5) {\n      const mode = cipherMode.getAEADMode(this.aeadAlgorithm);\n      this.iv = getRandomBytes(mode.ivLength); // generate new random IV\n      const adata = new Uint8Array([0xC0 | SymEncryptedSessionKeyPacket.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]);\n      const encryptionKey = this.version === 6 ? await computeHKDF(enums.hash.sha256, key, new Uint8Array(), adata, keySize) : key;\n      const modeInstance = await mode(algo, encryptionKey);\n      this.encrypted = await modeInstance.encrypt(this.sessionKey, this.iv, adata);\n    } else {\n      const toEncrypt = util.concatUint8Array([\n        new Uint8Array([this.sessionKeyAlgorithm]),\n        this.sessionKey\n      ]);\n      this.encrypted = await cipherMode.cfb.encrypt(algo, key, toEncrypt, new Uint8Array(blockSize), config);\n    }\n  }\n}\n\nexport default SymEncryptedSessionKeyPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport KeyID from '../type/keyid';\nimport defaultConfig from '../config';\nimport { computeDigest, parsePublicKeyParams, serializeParams } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport { UnsupportedError } from './packet';\n\n/**\n * Implementation of the Key Material Packet (Tag 5,6,7,14)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.5|RFC4480 5.5}:\n * A key material packet contains all the information about a public or\n * private key.  There are four variants of this packet type, and two\n * major versions.\n *\n * A Public-Key packet starts a series of packets that forms an OpenPGP\n * key (sometimes called an OpenPGP certificate).\n */\nclass PublicKeyPacket {\n  static get tag() {\n    return enums.packet.publicKey;\n  }\n\n  /**\n   * @param {Date} [date] - Creation date\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(date = new Date(), config = defaultConfig) {\n    /**\n     * Packet version\n     * @type {Integer}\n     */\n    this.version = config.v6Keys ? 6 : 4;\n    /**\n     * Key creation date.\n     * @type {Date}\n     */\n    this.created = util.normalizeDate(date);\n    /**\n     * Public key algorithm.\n     * @type {enums.publicKey}\n     */\n    this.algorithm = null;\n    /**\n     * Algorithm specific public params\n     * @type {Object}\n     */\n    this.publicParams = null;\n    /**\n     * Time until expiration in days (V3 only)\n     * @type {Integer}\n     */\n    this.expirationTimeV3 = 0;\n    /**\n     * Fingerprint bytes\n     * @type {Uint8Array}\n     */\n    this.fingerprint = null;\n    /**\n     * KeyID\n     * @type {module:type/keyid~KeyID}\n     */\n    this.keyID = null;\n  }\n\n  /**\n   * Create a PublicKeyPacket from a SecretKeyPacket\n   * @param {SecretKeyPacket} secretKeyPacket - key packet to convert\n   * @returns {PublicKeyPacket} public key packet\n   * @static\n   */\n  static fromSecretKeyPacket(secretKeyPacket) {\n    const keyPacket = new PublicKeyPacket();\n    const { version, created, algorithm, publicParams, keyID, fingerprint } = secretKeyPacket;\n    keyPacket.version = version;\n    keyPacket.created = created;\n    keyPacket.algorithm = algorithm;\n    keyPacket.publicParams = publicParams;\n    keyPacket.keyID = keyID;\n    keyPacket.fingerprint = fingerprint;\n    return keyPacket;\n  }\n\n  /**\n   * Internal Parser for public keys as specified in {@link https://tools.ietf.org/html/rfc4880#section-5.5.2|RFC 4880 section 5.5.2 Public-Key Packet Formats}\n   * @param {Uint8Array} bytes - Input array to read the packet from\n   * @returns {Object} This object with attributes set by the parser\n   * @async\n   */\n  async read(bytes, config = defaultConfig) {\n    let pos = 0;\n    // A one-octet version number (4, 5 or 6).\n    this.version = bytes[pos++];\n    if (this.version === 5 && !config.enableParsingV5Entities) {\n      throw new UnsupportedError('Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed');\n    }\n\n    if (this.version === 4 || this.version === 5 || this.version === 6) {\n      // - A four-octet number denoting the time that the key was created.\n      this.created = util.readDate(bytes.subarray(pos, pos + 4));\n      pos += 4;\n\n      // - A one-octet number denoting the public-key algorithm of this key.\n      this.algorithm = bytes[pos++];\n\n      if (this.version >= 5) {\n        // - A four-octet scalar octet count for the following key material.\n        pos += 4;\n      }\n\n      // - A series of values comprising the key material.\n      const { read, publicParams } = parsePublicKeyParams(this.algorithm, bytes.subarray(pos));\n      // The deprecated OIDs for Ed25519Legacy and Curve25519Legacy are used in legacy version 4 keys and signatures.\n      // Implementations MUST NOT accept or generate v6 key material using the deprecated OIDs.\n      if (\n        this.version === 6 &&\n        publicParams.oid && (\n          publicParams.oid.getName() === enums.curve.curve25519Legacy ||\n          publicParams.oid.getName() === enums.curve.ed25519Legacy\n        )\n      ) {\n        throw new Error('Legacy curve25519 cannot be used with v6 keys');\n      }\n      this.publicParams = publicParams;\n      pos += read;\n\n      // we set the fingerprint and keyID already to make it possible to put together the key packets directly in the Key constructor\n      await this.computeFingerprintAndKeyID();\n      return pos;\n    }\n    throw new UnsupportedError(`Version ${this.version} of the key packet is unsupported.`);\n  }\n\n  /**\n   * Creates an OpenPGP public key packet for the given key.\n   * @returns {Uint8Array} Bytes encoding the public key OpenPGP packet.\n   */\n  write() {\n    const arr = [];\n    // Version\n    arr.push(new Uint8Array([this.version]));\n    arr.push(util.writeDate(this.created));\n    // A one-octet number denoting the public-key algorithm of this key\n    arr.push(new Uint8Array([this.algorithm]));\n\n    const params = serializeParams(this.algorithm, this.publicParams);\n    if (this.version >= 5) {\n      // A four-octet scalar octet count for the following key material\n      arr.push(util.writeNumber(params.length, 4));\n    }\n    // Algorithm-specific params\n    arr.push(params);\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n   * Write packet in order to be hashed; either for a signature or a fingerprint\n   * @param {Integer} version - target version of signature or key\n   */\n  writeForHash(version) {\n    const bytes = this.writePublicKey();\n\n    const versionOctet = 0x95 + version;\n    const lengthOctets = version >= 5 ? 4 : 2;\n    return util.concatUint8Array([new Uint8Array([versionOctet]), util.writeNumber(bytes.length, lengthOctets), bytes]);\n  }\n\n  /**\n   * Check whether secret-key data is available in decrypted form. Returns null for public keys.\n   * @returns {Boolean|null}\n   */\n  isDecrypted() {\n    return null;\n  }\n\n  /**\n   * Returns the creation time of the key\n   * @returns {Date}\n   */\n  getCreationTime() {\n    return this.created;\n  }\n\n  /**\n   * Return the key ID of the key\n   * @returns {module:type/keyid~KeyID} The 8-byte key ID\n   */\n  getKeyID() {\n    return this.keyID;\n  }\n\n  /**\n   * Computes and set the key ID and fingerprint of the key\n   * @async\n   */\n  async computeFingerprintAndKeyID() {\n    await this.computeFingerprint();\n    this.keyID = new KeyID();\n\n    if (this.version >= 5) {\n      this.keyID.read(this.fingerprint.subarray(0, 8));\n    } else if (this.version === 4) {\n      this.keyID.read(this.fingerprint.subarray(12, 20));\n    } else {\n      throw new Error('Unsupported key version');\n    }\n  }\n\n  /**\n   * Computes and set the fingerprint of the key\n   */\n  async computeFingerprint() {\n    const toHash = this.writeForHash(this.version);\n\n    if (this.version >= 5) {\n      this.fingerprint = await computeDigest(enums.hash.sha256, toHash);\n    } else if (this.version === 4) {\n      this.fingerprint = await computeDigest(enums.hash.sha1, toHash);\n    } else {\n      throw new Error('Unsupported key version');\n    }\n  }\n\n  /**\n   * Returns the fingerprint of the key, as an array of bytes\n   * @returns {Uint8Array} A Uint8Array containing the fingerprint\n   */\n  getFingerprintBytes() {\n    return this.fingerprint;\n  }\n\n  /**\n   * Calculates and returns the fingerprint of the key, as a string\n   * @returns {String} A string containing the fingerprint in lowercase hex\n   */\n  getFingerprint() {\n    return util.uint8ArrayToHex(this.getFingerprintBytes());\n  }\n\n  /**\n   * Calculates whether two keys have the same fingerprint without actually calculating the fingerprint\n   * @returns {Boolean} Whether the two keys have the same version and public key data.\n   */\n  hasSameFingerprintAs(other) {\n    return this.version === other.version && util.equalsUint8Array(this.writePublicKey(), other.writePublicKey());\n  }\n\n  /**\n   * Returns algorithm information\n   * @returns {Object} An object of the form {algorithm: String, bits:int, curve:String}.\n   */\n  getAlgorithmInfo() {\n    const result = {};\n    result.algorithm = enums.read(enums.publicKey, this.algorithm);\n    // RSA, DSA or ElGamal public modulo\n    const modulo = this.publicParams.n || this.publicParams.p;\n    if (modulo) {\n      result.bits = util.uint8ArrayBitLength(modulo);\n    } else if (this.publicParams.oid) {\n      result.curve = this.publicParams.oid.getName();\n    }\n    return result;\n  }\n}\n\n/**\n * Alias of read()\n * @see PublicKeyPacket#read\n */\nPublicKeyPacket.prototype.readPublicKey = PublicKeyPacket.prototype.read;\n\n/**\n * Alias of write()\n * @see PublicKeyPacket#write\n */\nPublicKeyPacket.prototype.writePublicKey = PublicKeyPacket.prototype.write;\n\nexport default PublicKeyPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { readToEnd as streamReadToEnd, clone as streamClone } from '@openpgp/web-stream-tools';\nimport { cipherMode, getCipherParams } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\nimport LiteralDataPacket from './literal_data';\nimport CompressedDataPacket from './compressed_data';\nimport OnePassSignaturePacket from './one_pass_signature';\nimport SignaturePacket from './signature';\nimport PacketList from './packetlist';\n\n// A SE packet can contain the following packet types\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  CompressedDataPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n\n/**\n * Implementation of the Symmetrically Encrypted Data Packet (Tag 9)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.7|RFC4880 5.7}:\n * The Symmetrically Encrypted Data packet contains data encrypted with a\n * symmetric-key algorithm. When it has been decrypted, it contains other\n * packets (usually a literal data packet or compressed data packet, but in\n * theory other Symmetrically Encrypted Data packets or sequences of packets\n * that form whole OpenPGP messages).\n */\nclass SymmetricallyEncryptedDataPacket {\n  static get tag() {\n    return enums.packet.symmetricallyEncryptedData;\n  }\n\n  constructor() {\n    /**\n     * Encrypted secret-key data\n     */\n    this.encrypted = null;\n    /**\n     * Decrypted packets contained within.\n     * @type {PacketList}\n     */\n    this.packets = null;\n  }\n\n  read(bytes) {\n    this.encrypted = bytes;\n  }\n\n  write() {\n    return this.encrypted;\n  }\n\n  /**\n   * Decrypt the symmetrically-encrypted packet data\n   * See {@link https://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2} for algorithms.\n   * @param {module:enums.symmetric} sessionKeyAlgorithm - Symmetric key algorithm to use\n   * @param {Uint8Array} key - The key of cipher blocksize length to be used\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n\n   * @throws {Error} if decryption was not successful\n   * @async\n   */\n  async decrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    // If MDC errors are not being ignored, all missing MDC packets in symmetrically encrypted data should throw an error\n    if (!config.allowUnauthenticatedMessages) {\n      throw new Error('Message is not authenticated.');\n    }\n\n    const { blockSize } = getCipherParams(sessionKeyAlgorithm);\n    const encrypted = await streamReadToEnd(streamClone(this.encrypted));\n    const decrypted = await cipherMode.cfb.decrypt(sessionKeyAlgorithm, key,\n      encrypted.subarray(blockSize + 2),\n      encrypted.subarray(2, blockSize + 2)\n    );\n\n    // Decrypting a Symmetrically Encrypted Data packet MUST yield a valid OpenPGP Message.\n    // But due to the lack of authentication over the decrypted data,\n    // we do not run any grammarValidator, to avoid enabling a decryption oracle\n    // (plus, there is probably a higher chance that these messages have an expected structure).\n    this.packets = await PacketList.fromBinary(decrypted, allowedPackets, config);\n  }\n\n  /**\n   * Encrypt the symmetrically-encrypted packet data\n   * See {@link https://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2} for algorithms.\n   * @param {module:enums.symmetric} sessionKeyAlgorithm - Symmetric key algorithm to use\n   * @param {Uint8Array} key - The key of cipher blocksize length to be used\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if encryption was not successful\n   * @async\n   */\n  async encrypt(sessionKeyAlgorithm, key, config = defaultConfig) {\n    const data = this.packets.write();\n    const { blockSize } = getCipherParams(sessionKeyAlgorithm);\n\n    const prefix = await cipherMode.cfb.getPrefixRandom(sessionKeyAlgorithm);\n    const FRE = await cipherMode.cfb.encrypt(sessionKeyAlgorithm, key, prefix, new Uint8Array(blockSize), config);\n    const ciphertext = await cipherMode.cfb.encrypt(sessionKeyAlgorithm, key, data, FRE.subarray(2), config);\n    this.encrypted = util.concat([FRE, ciphertext]);\n  }\n}\n\nexport default SymmetricallyEncryptedDataPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport enums from '../enums';\n\n/**\n * Implementation of the strange \"Marker packet\" (Tag 10)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.8|RFC4880 5.8}:\n * An experimental version of PGP used this packet as the Literal\n * packet, but no released version of PGP generated Literal packets with this\n * tag. With PGP 5.x, this packet has been reassigned and is reserved for use as\n * the Marker packet.\n *\n * The body of this packet consists of:\n *   The three octets 0x50, 0x47, 0x50 (which spell \"PGP\" in UTF-8).\n *\n * Such a packet MUST be ignored when received. It may be placed at the\n * beginning of a message that uses features not available in PGP\n * version 2.6 in order to cause that version to report that newer\n * software is necessary to process the message.\n */\nclass MarkerPacket {\n  static get tag() {\n    return enums.packet.marker;\n  }\n\n  /**\n   * Parsing function for a marker data packet (tag 10).\n   * @param {Uint8Array} bytes - Payload of a tag 10 packet\n   * @returns {Boolean} whether the packet payload contains \"PGP\"\n   */\n  read(bytes) {\n    if (bytes[0] === 0x50 && // P\n        bytes[1] === 0x47 && // G\n        bytes[2] === 0x50) { // P\n      return true;\n    }\n    return false;\n  }\n\n  write() {\n    return new Uint8Array([0x50, 0x47, 0x50]);\n  }\n}\n\nexport default MarkerPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport PublicKeyPacket from './public_key';\nimport enums from '../enums';\n\n/**\n * A Public-Subkey packet (tag 14) has exactly the same format as a\n * Public-Key packet, but denotes a subkey.  One or more subkeys may be\n * associated with a top-level key.  By convention, the top-level key\n * provides signature services, and the subkeys provide encryption\n * services.\n * @extends PublicKeyPacket\n */\nclass PublicSubkeyPacket extends PublicKeyPacket {\n  static get tag() {\n    return enums.packet.publicSubkey;\n  }\n\n  /**\n   * @param {Date} [date] - Creation date\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(date, config) {\n    super(date, config);\n  }\n\n  /**\n   * Create a PublicSubkeyPacket from a SecretSubkeyPacket\n   * @param {SecretSubkeyPacket} secretSubkeyPacket - subkey packet to convert\n   * @returns {SecretSubkeyPacket} public key packet\n   * @static\n   */\n  static fromSecretSubkeyPacket(secretSubkeyPacket) {\n    const keyPacket = new PublicSubkeyPacket();\n    const { version, created, algorithm, publicParams, keyID, fingerprint } = secretSubkeyPacket;\n    keyPacket.version = version;\n    keyPacket.created = created;\n    keyPacket.algorithm = algorithm;\n    keyPacket.publicParams = publicParams;\n    keyPacket.keyID = keyID;\n    keyPacket.fingerprint = fingerprint;\n    return keyPacket;\n  }\n}\n\nexport default PublicSubkeyPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { readSimpleLength, writeSimpleLength } from './packet';\nimport enums from '../enums';\nimport util from '../util';\n\n/**\n * Implementation of the User Attribute Packet (Tag 17)\n *\n * The User Attribute packet is a variation of the User ID packet.  It\n * is capable of storing more types of data than the User ID packet,\n * which is limited to text.  Like the User ID packet, a User Attribute\n * packet may be certified by the key owner (\"self-signed\") or any other\n * key owner who cares to certify it.  Except as noted, a User Attribute\n * packet may be used anywhere that a User ID packet may be used.\n *\n * While User Attribute packets are not a required part of the OpenPGP\n * standard, implementations SHOULD provide at least enough\n * compatibility to properly handle a certification signature on the\n * User Attribute packet.  A simple way to do this is by treating the\n * User Attribute packet as a User ID packet with opaque contents, but\n * an implementation may use any method desired.\n */\nclass UserAttributePacket {\n  static get tag() {\n    return enums.packet.userAttribute;\n  }\n\n  constructor() {\n    this.attributes = [];\n  }\n\n  /**\n   * parsing function for a user attribute packet (tag 17).\n   * @param {Uint8Array} input - Payload of a tag 17 packet\n   */\n  read(bytes) {\n    let i = 0;\n    while (i < bytes.length) {\n      const len = readSimpleLength(bytes.subarray(i, bytes.length));\n      i += len.offset;\n\n      this.attributes.push(util.uint8ArrayToString(bytes.subarray(i, i + len.len)));\n      i += len.len;\n    }\n  }\n\n  /**\n   * Creates a binary representation of the user attribute packet\n   * @returns {Uint8Array} String representation.\n   */\n  write() {\n    const arr = [];\n    for (let i = 0; i < this.attributes.length; i++) {\n      arr.push(writeSimpleLength(this.attributes[i].length));\n      arr.push(util.stringToUint8Array(this.attributes[i]));\n    }\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n   * Compare for equality\n   * @param {UserAttributePacket} usrAttr\n   * @returns {Boolean} True if equal.\n   */\n  equals(usrAttr) {\n    if (!usrAttr || !(usrAttr instanceof UserAttributePacket)) {\n      return false;\n    }\n    return this.attributes.every(function(attr, index) {\n      return attr === usrAttr.attributes[index];\n    });\n  }\n}\n\nexport default UserAttributePacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport PublicKeyPacket from './public_key';\nimport { newS2KFromConfig, newS2KFromType } from '../type/s2k';\nimport { computeDigest, getCipherParams, parsePrivateKeyParams, serializeParams, generateParams, validateParams, getRandomBytes, cipherMode } from '../crypto';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\nimport { UnsupportedError, writeTag } from './packet';\nimport computeHKDF from '../crypto/hkdf';\n\n/**\n * A Secret-Key packet contains all the information that is found in a\n * Public-Key packet, including the public-key material, but also\n * includes the secret-key material after all the public-key fields.\n * @extends PublicKeyPacket\n */\nclass SecretKeyPacket extends PublicKeyPacket {\n  static get tag() {\n    return enums.packet.secretKey;\n  }\n\n  /**\n   * @param {Date} [date] - Creation date\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(date = new Date(), config = defaultConfig) {\n    super(date, config);\n    /**\n     * Secret-key data\n     */\n    this.keyMaterial = null;\n    /**\n     * Indicates whether secret-key data is encrypted. `this.isEncrypted === false` means data is available in decrypted form.\n     */\n    this.isEncrypted = null;\n    /**\n     * S2K usage\n     * @type {enums.symmetric}\n     */\n    this.s2kUsage = 0;\n    /**\n     * S2K object\n     * @type {type/s2k}\n     */\n    this.s2k = null;\n    /**\n     * Symmetric algorithm to encrypt the key with\n     * @type {enums.symmetric}\n     */\n    this.symmetric = null;\n    /**\n     * AEAD algorithm to encrypt the key with (if AEAD protection is enabled)\n     * @type {enums.aead}\n     */\n    this.aead = null;\n    /**\n     * Whether the key is encrypted using the legacy AEAD format proposal from RFC4880bis\n     * (i.e. it was encrypted with the flag `config.aeadProtect` in OpenPGP.js v5 or older).\n     * This value is only relevant to know how to decrypt the key:\n     * if AEAD is enabled, a v4 key is always re-encrypted using the standard AEAD mechanism.\n     * @type {Boolean}\n     * @private\n     */\n    this.isLegacyAEAD = null;\n    /**\n     * Decrypted private parameters, referenced by name\n     * @type {Object}\n     */\n    this.privateParams = null;\n    /**\n     * `true` for keys whose integrity is already confirmed, based on\n     * the AEAD encryption mechanism\n     * @type {Boolean}\n     * @private\n     */\n    this.usedModernAEAD = null;\n  }\n\n  // 5.5.3.  Secret-Key Packet Formats\n\n  /**\n   * Internal parser for private keys as specified in\n   * {@link https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-04#section-5.5.3|RFC4880bis-04 section 5.5.3}\n   * @param {Uint8Array} bytes - Input string to read the packet from\n   * @async\n   */\n  async read(bytes, config = defaultConfig) {\n    // - A Public-Key or Public-Subkey packet, as described above.\n    let i = await this.readPublicKey(bytes, config);\n    const startOfSecretKeyData = i;\n\n    // - One octet indicating string-to-key usage conventions.  Zero\n    //   indicates that the secret-key data is not encrypted.  255 or 254\n    //   indicates that a string-to-key specifier is being given.  Any\n    //   other value is a symmetric-key encryption algorithm identifier.\n    this.s2kUsage = bytes[i++];\n\n    // - Only for a version 5 packet, a one-octet scalar octet count of\n    //   the next 4 optional fields.\n    if (this.version === 5) {\n      i++;\n    }\n\n    // - Only for a version 6 packet where the secret key material is\n    //   encrypted (that is, where the previous octet is not zero), a one-\n    //   octet scalar octet count of the cumulative length of all the\n    //   following optional string-to-key parameter fields.\n    if (this.version === 6 && this.s2kUsage) {\n      i++;\n    }\n\n    try {\n      // - [Optional] If string-to-key usage octet was 255, 254, or 253, a\n      //   one-octet symmetric encryption algorithm.\n      if (this.s2kUsage === 255 || this.s2kUsage === 254 || this.s2kUsage === 253) {\n        this.symmetric = bytes[i++];\n\n        // - [Optional] If string-to-key usage octet was 253, a one-octet\n        //   AEAD algorithm.\n        if (this.s2kUsage === 253) {\n          this.aead = bytes[i++];\n        }\n\n        // - [Optional] Only for a version 6 packet, and if string-to-key usage\n        //   octet was 255, 254, or 253, an one-octet count of the following field.\n        if (this.version === 6) {\n          i++;\n        }\n\n        // - [Optional] If string-to-key usage octet was 255, 254, or 253, a\n        //   string-to-key specifier.  The length of the string-to-key\n        //   specifier is implied by its type, as described above.\n        const s2kType = bytes[i++];\n        this.s2k = newS2KFromType(s2kType);\n        i += this.s2k.read(bytes.subarray(i, bytes.length));\n\n        if (this.s2k.type === 'gnu-dummy') {\n          return;\n        }\n      } else if (this.s2kUsage) {\n        this.symmetric = this.s2kUsage;\n      }\n\n\n      if (this.s2kUsage) {\n        // OpenPGP.js up to v5 used to support encrypting v4 keys using AEAD as specified by draft RFC4880bis (https://www.ietf.org/archive/id/draft-ietf-openpgp-rfc4880bis-10.html#section-5.5.3-3.5).\n        // This legacy format is incompatible, but fundamentally indistinguishable, from that of the crypto-refresh for v4 keys (v5 keys are always in legacy format).\n        // While parsing the key may succeed (if IV and AES block sizes match), key decryption will always\n        // fail if the key was parsed according to the wrong format, since the keys are processed differently.\n        // Thus, for v4 keys, we rely on the caller to instruct us to process the key as legacy, via config flag.\n        this.isLegacyAEAD = this.s2kUsage === 253 && (\n          this.version === 5 || (this.version === 4 && config.parseAEADEncryptedV4KeysAsLegacy));\n        // - crypto-refresh: If string-to-key usage octet was 255, 254 [..], an initialization vector (IV)\n        // of the same length as the cipher's block size.\n        // - RFC4880bis (v5 keys, regardless of AEAD): an Initial Vector (IV) of the same length as the\n        //   cipher's block size. If string-to-key usage octet was 253 the IV is used as the nonce for the AEAD algorithm.\n        // If the AEAD algorithm requires a shorter nonce, the high-order bits of the IV are used and the remaining bits MUST be zero\n        if (this.s2kUsage !== 253 || this.isLegacyAEAD) {\n          this.iv = bytes.subarray(\n            i,\n            i + getCipherParams(this.symmetric).blockSize\n          );\n          this.usedModernAEAD = false;\n        } else {\n          // crypto-refresh: If string-to-key usage octet was 253 (that is, the secret data is AEAD-encrypted),\n          // an initialization vector (IV) of size specified by the AEAD algorithm (see Section 5.13.2), which\n          // is used as the nonce for the AEAD algorithm.\n          this.iv = bytes.subarray(\n            i,\n            i + cipherMode.getAEADMode(this.aead).ivLength\n          );\n          // the non-legacy AEAD encryption mechanism also authenticates public key params; no need for manual validation.\n          this.usedModernAEAD = true;\n        }\n\n        i += this.iv.length;\n      }\n    } catch (e) {\n      // if the s2k is unsupported, we still want to support encrypting and verifying with the given key\n      if (!this.s2kUsage) throw e; // always throw for decrypted keys\n      this.unparseableKeyMaterial = bytes.subarray(startOfSecretKeyData);\n      this.isEncrypted = true;\n    }\n\n    // - Only for a version 5 packet, a four-octet scalar octet count for\n    //   the following key material.\n    if (this.version === 5) {\n      i += 4;\n    }\n\n    // - Plain or encrypted multiprecision integers comprising the secret\n    //   key data.  These algorithm-specific fields are as described\n    //   below.\n    this.keyMaterial = bytes.subarray(i);\n    this.isEncrypted = !!this.s2kUsage;\n\n    if (!this.isEncrypted) {\n      let cleartext;\n      if (this.version === 6) {\n        cleartext = this.keyMaterial;\n      } else {\n        cleartext = this.keyMaterial.subarray(0, -2);\n        if (!util.equalsUint8Array(util.writeChecksum(cleartext), this.keyMaterial.subarray(-2))) {\n          throw new Error('Key checksum mismatch');\n        }\n      }\n      try {\n        const { read, privateParams } = parsePrivateKeyParams(this.algorithm, cleartext, this.publicParams);\n        if (read < cleartext.length) {\n          throw new Error('Error reading MPIs');\n        }\n        this.privateParams = privateParams;\n      } catch (err) {\n        if (err instanceof UnsupportedError) throw err;\n        // avoid throwing potentially sensitive errors\n        throw new Error('Error reading MPIs');\n      }\n    }\n  }\n\n  /**\n   * Creates an OpenPGP key packet for the given key.\n   * @returns {Uint8Array} A string of bytes containing the secret key OpenPGP packet.\n   */\n  write() {\n    const serializedPublicKey = this.writePublicKey();\n    if (this.unparseableKeyMaterial) {\n      return util.concatUint8Array([\n        serializedPublicKey,\n        this.unparseableKeyMaterial\n      ]);\n    }\n\n    const arr = [serializedPublicKey];\n    arr.push(new Uint8Array([this.s2kUsage]));\n\n    const optionalFieldsArr = [];\n    // - [Optional] If string-to-key usage octet was 255, 254, or 253, a\n    //   one- octet symmetric encryption algorithm.\n    if (this.s2kUsage === 255 || this.s2kUsage === 254 || this.s2kUsage === 253) {\n      optionalFieldsArr.push(this.symmetric);\n\n      // - [Optional] If string-to-key usage octet was 253, a one-octet\n      //   AEAD algorithm.\n      if (this.s2kUsage === 253) {\n        optionalFieldsArr.push(this.aead);\n      }\n\n      const s2k = this.s2k.write();\n\n      // - [Optional] Only for a version 6 packet, and if string-to-key usage\n      //   octet was 255, 254, or 253, an one-octet count of the following field.\n      if (this.version === 6) {\n        optionalFieldsArr.push(s2k.length);\n      }\n\n      // - [Optional] If string-to-key usage octet was 255, 254, or 253, a\n      //   string-to-key specifier.  The length of the string-to-key\n      //   specifier is implied by its type, as described above.\n      optionalFieldsArr.push(...s2k);\n    }\n\n    // - [Optional] If secret data is encrypted (string-to-key usage octet\n    //   not zero), an Initial Vector (IV) of the same length as the\n    //   cipher's block size.\n    if (this.s2kUsage && this.s2k.type !== 'gnu-dummy') {\n      optionalFieldsArr.push(...this.iv);\n    }\n\n    if (this.version === 5 || (this.version === 6 && this.s2kUsage)) {\n      arr.push(new Uint8Array([optionalFieldsArr.length]));\n    }\n    arr.push(new Uint8Array(optionalFieldsArr));\n\n    if (!this.isDummy()) {\n      if (!this.s2kUsage) {\n        this.keyMaterial = serializeParams(this.algorithm, this.privateParams);\n      }\n\n      if (this.version === 5) {\n        arr.push(util.writeNumber(this.keyMaterial.length, 4));\n      }\n      arr.push(this.keyMaterial);\n\n      if (!this.s2kUsage && this.version !== 6) {\n        arr.push(util.writeChecksum(this.keyMaterial));\n      }\n    }\n\n    return util.concatUint8Array(arr);\n  }\n\n  /**\n   * Check whether secret-key data is available in decrypted form.\n   * Returns false for gnu-dummy keys and null for public keys.\n   * @returns {Boolean|null}\n   */\n  isDecrypted() {\n    return this.isEncrypted === false;\n  }\n\n  /**\n   * Check whether the key includes secret key material.\n   * Some secret keys do not include it, and can thus only be used\n   * for public-key operations (encryption and verification).\n   * Such keys are:\n   * - GNU-dummy keys, where the secret material has been stripped away\n   * - encrypted keys with unsupported S2K or cipher\n   */\n  isMissingSecretKeyMaterial() {\n    return this.unparseableKeyMaterial !== undefined || this.isDummy();\n  }\n\n  /**\n   * Check whether this is a gnu-dummy key\n   * @returns {Boolean}\n   */\n  isDummy() {\n    return !!(this.s2k && this.s2k.type === 'gnu-dummy');\n  }\n\n  /**\n   * Remove private key material, converting the key to a dummy one.\n   * The resulting key cannot be used for signing/decrypting but can still verify signatures.\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  makeDummy(config = defaultConfig) {\n    if (this.isDummy()) {\n      return;\n    }\n    if (this.isDecrypted()) {\n      this.clearPrivateParams();\n    }\n    delete this.unparseableKeyMaterial;\n    this.isEncrypted = null;\n    this.keyMaterial = null;\n    this.s2k = newS2KFromType(enums.s2k.gnu, config);\n    this.s2k.algorithm = 0;\n    this.s2k.c = 0;\n    this.s2k.type = 'gnu-dummy';\n    this.s2kUsage = 254;\n    this.symmetric = enums.symmetric.aes256;\n    this.isLegacyAEAD = null;\n    this.usedModernAEAD = null;\n  }\n\n  /**\n   * Encrypt the payload. By default, we use aes256 and iterated, salted string\n   * to key specifier. If the key is in a decrypted state (isEncrypted === false)\n   * and the passphrase is empty or undefined, the key will be set as not encrypted.\n   * This can be used to remove passphrase protection after calling decrypt().\n   * @param {String} passphrase\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if encryption was not successful\n   * @async\n   */\n  async encrypt(passphrase, config = defaultConfig) {\n    if (this.isDummy()) {\n      return;\n    }\n\n    if (!this.isDecrypted()) {\n      throw new Error('Key packet is already encrypted');\n    }\n\n    if (!passphrase) {\n      throw new Error('A non-empty passphrase is required for key encryption.');\n    }\n\n    this.s2k = newS2KFromConfig(config);\n    this.s2k.generateSalt();\n    const cleartext = serializeParams(this.algorithm, this.privateParams);\n    this.symmetric = enums.symmetric.aes256;\n\n    const { blockSize } = getCipherParams(this.symmetric);\n\n    if (config.aeadProtect) {\n      this.s2kUsage = 253;\n      this.aead = config.preferredAEADAlgorithm;\n      const mode = cipherMode.getAEADMode(this.aead);\n      this.isLegacyAEAD = this.version === 5; // v4 is always re-encrypted with standard format instead.\n      this.usedModernAEAD = !this.isLegacyAEAD; // legacy AEAD does not guarantee integrity of public key material\n\n      const serializedPacketTag = writeTag(this.constructor.tag);\n      const key = await produceEncryptionKey(this.version, this.s2k, passphrase, this.symmetric, this.aead, serializedPacketTag, this.isLegacyAEAD);\n\n      const modeInstance = await mode(this.symmetric, key);\n      this.iv = this.isLegacyAEAD ? getRandomBytes(blockSize) : getRandomBytes(mode.ivLength);\n      const associateData = this.isLegacyAEAD ?\n        new Uint8Array() :\n        util.concatUint8Array([serializedPacketTag, this.writePublicKey()]);\n\n      this.keyMaterial = await modeInstance.encrypt(cleartext, this.iv.subarray(0, mode.ivLength), associateData);\n    } else {\n      this.s2kUsage = 254;\n      this.usedModernAEAD = false;\n      const key = await produceEncryptionKey(this.version, this.s2k, passphrase, this.symmetric);\n      this.iv = getRandomBytes(blockSize);\n      this.keyMaterial = await cipherMode.cfb.encrypt(this.symmetric, key, util.concatUint8Array([\n        cleartext,\n        await computeDigest(enums.hash.sha1, cleartext, config)\n      ]), this.iv, config);\n    }\n  }\n\n  /**\n   * Decrypts the private key params which are needed to use the key.\n   * Successful decryption does not imply key integrity, call validate() to confirm that.\n   * {@link SecretKeyPacket.isDecrypted} should be false, as\n   * otherwise calls to this function will throw an error.\n   * @param {String} passphrase - The passphrase for this private key as string\n   * @throws {Error} if the key is already decrypted, or if decryption was not successful\n   * @async\n   */\n  async decrypt(passphrase) {\n    if (this.isDummy()) {\n      return false;\n    }\n\n    if (this.unparseableKeyMaterial) {\n      throw new Error('Key packet cannot be decrypted: unsupported S2K or cipher algo');\n    }\n\n    if (this.isDecrypted()) {\n      throw new Error('Key packet is already decrypted.');\n    }\n\n    let key;\n    const serializedPacketTag = writeTag(this.constructor.tag); // relevant for AEAD only\n    if (this.s2kUsage === 254 || this.s2kUsage === 253) {\n      key = await produceEncryptionKey(\n        this.version, this.s2k, passphrase, this.symmetric, this.aead, serializedPacketTag, this.isLegacyAEAD);\n    } else if (this.s2kUsage === 255) {\n      throw new Error('Encrypted private key is authenticated using an insecure two-byte hash');\n    } else {\n      throw new Error('Private key is encrypted using an insecure S2K function: unsalted MD5');\n    }\n\n    let cleartext;\n    if (this.s2kUsage === 253) {\n      const mode = cipherMode.getAEADMode(this.aead, true);\n      const modeInstance = await mode(this.symmetric, key);\n      try {\n        const associateData = this.isLegacyAEAD ?\n          new Uint8Array() :\n          util.concatUint8Array([serializedPacketTag, this.writePublicKey()]);\n        cleartext = await modeInstance.decrypt(this.keyMaterial, this.iv.subarray(0, mode.ivLength), associateData);\n      } catch (err) {\n        if (err.message === 'Authentication tag mismatch') {\n          throw new Error('Incorrect key passphrase: ' + err.message);\n        }\n        throw err;\n      }\n    } else {\n      const cleartextWithHash = await cipherMode.cfb.decrypt(this.symmetric, key, this.keyMaterial, this.iv);\n\n      cleartext = cleartextWithHash.subarray(0, -20);\n      const hash = await computeDigest(enums.hash.sha1, cleartext);\n\n      if (!util.equalsUint8Array(hash, cleartextWithHash.subarray(-20))) {\n        throw new Error('Incorrect key passphrase');\n      }\n    }\n\n    try {\n      const { privateParams } = parsePrivateKeyParams(this.algorithm, cleartext, this.publicParams);\n      this.privateParams = privateParams;\n    } catch (err) {\n      throw new Error('Error reading MPIs');\n    }\n    this.isEncrypted = false;\n    this.keyMaterial = null;\n    this.s2kUsage = 0;\n    this.aead = null;\n    this.symmetric = null;\n    this.isLegacyAEAD = null;\n  }\n\n  /**\n   * Checks that the key parameters are consistent\n   * @throws {Error} if validation was not successful\n   * @async\n   */\n  async validate() {\n    if (this.isDummy()) {\n      return;\n    }\n\n    if (!this.isDecrypted()) {\n      throw new Error('Key is not decrypted');\n    }\n\n    if (this.usedModernAEAD) {\n      // key integrity confirmed by successful AEAD decryption\n      return;\n    }\n\n    let validParams;\n    try {\n      // this can throw if some parameters are undefined\n      validParams = await validateParams(this.algorithm, this.publicParams, this.privateParams);\n    } catch (_) {\n      validParams = false;\n    }\n    if (!validParams) {\n      throw new Error('Key is invalid');\n    }\n  }\n\n  async generate(bits, curve) {\n    // The deprecated OIDs for Ed25519Legacy and Curve25519Legacy are used in legacy version 4 keys and signatures.\n    // Implementations MUST NOT accept or generate v6 key material using the deprecated OIDs.\n    if (this.version === 6 && (\n      (this.algorithm === enums.publicKey.ecdh && curve === enums.curve.curve25519Legacy) ||\n      this.algorithm === enums.publicKey.eddsaLegacy\n    )) {\n      throw new Error(`Cannot generate v6 keys of type 'ecc' with curve ${curve}. Generate a key of type 'curve25519' instead`);\n    }\n    const { privateParams, publicParams } = await generateParams(this.algorithm, bits, curve);\n    this.privateParams = privateParams;\n    this.publicParams = publicParams;\n    this.isEncrypted = false;\n  }\n\n  /**\n   * Clear private key parameters\n   */\n  clearPrivateParams() {\n    if (this.isMissingSecretKeyMaterial()) {\n      return;\n    }\n\n    Object.keys(this.privateParams).forEach(name => {\n      const param = this.privateParams[name];\n      param.fill(0);\n      delete this.privateParams[name];\n    });\n    this.privateParams = null;\n    this.isEncrypted = true;\n  }\n}\n\n/**\n * Derive encryption key\n * @param {Number} keyVersion - key derivation differs for v5 keys\n * @param {module:type/s2k} s2k\n * @param {String} passphrase\n * @param {module:enums.symmetric} cipherAlgo\n * @param {module:enums.aead} [aeadMode] - for AEAD-encrypted keys only (excluding v5)\n * @param {Uint8Array} [serializedPacketTag] - for AEAD-encrypted keys only (excluding v5)\n * @param {Boolean} [isLegacyAEAD] - for AEAD-encrypted keys from RFC4880bis (v4 and v5 only)\n * @returns encryption key\n */\nasync function produceEncryptionKey(keyVersion, s2k, passphrase, cipherAlgo, aeadMode, serializedPacketTag, isLegacyAEAD) {\n  if (s2k.type === 'argon2' && !aeadMode) {\n    throw new Error('Using Argon2 S2K without AEAD is not allowed');\n  }\n  if (s2k.type === 'simple' && keyVersion === 6) {\n    throw new Error('Using Simple S2K with version 6 keys is not allowed');\n  }\n  const { keySize } = getCipherParams(cipherAlgo);\n  const derivedKey = await s2k.produceKey(passphrase, keySize);\n  if (!aeadMode || keyVersion === 5 || isLegacyAEAD) {\n    return derivedKey;\n  }\n  const info = util.concatUint8Array([\n    serializedPacketTag,\n    new Uint8Array([keyVersion, cipherAlgo, aeadMode])\n  ]);\n  return computeHKDF(enums.hash.sha256, derivedKey, new Uint8Array(), info, keySize);\n}\n\nexport default SecretKeyPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\n\n/**\n * Implementation of the User ID Packet (Tag 13)\n *\n * A User ID packet consists of UTF-8 text that is intended to represent\n * the name and email address of the key holder.  By convention, it\n * includes an RFC 2822 [RFC2822] mail name-addr, but there are no\n * restrictions on its content.  The packet length in the header\n * specifies the length of the User ID.\n */\nclass UserIDPacket {\n  static get tag() {\n    return enums.packet.userID;\n  }\n\n  constructor() {\n    /** A string containing the user id. Usually in the form\n     * John Doe <john@example.com>\n     * @type {String}\n     */\n    this.userID = '';\n\n    this.name = '';\n    this.email = '';\n    this.comment = '';\n  }\n\n  /**\n   * Create UserIDPacket instance from object\n   * @param {Object} userID - Object specifying userID name, email and comment\n   * @returns {UserIDPacket}\n   * @static\n   */\n  static fromObject(userID) {\n    if (util.isString(userID) ||\n      (userID.name && !util.isString(userID.name)) ||\n      (userID.email && !util.isEmailAddress(userID.email)) ||\n      (userID.comment && !util.isString(userID.comment))) {\n      throw new Error('Invalid user ID format');\n    }\n    const packet = new UserIDPacket();\n    Object.assign(packet, userID);\n    const components = [];\n    if (packet.name) components.push(packet.name);\n    if (packet.comment) components.push(`(${packet.comment})`);\n    if (packet.email) components.push(`<${packet.email}>`);\n    packet.userID = components.join(' ');\n    return packet;\n  }\n\n  /**\n   * Parsing function for a user id packet (tag 13).\n   * @param {Uint8Array} input - Payload of a tag 13 packet\n   */\n  read(bytes, config = defaultConfig) {\n    const userID = util.decodeUTF8(bytes);\n    if (userID.length > config.maxUserIDLength) {\n      throw new Error('User ID string is too long');\n    }\n\n    /**\n     * We support the conventional cases described in https://www.ietf.org/id/draft-dkg-openpgp-userid-conventions-00.html#section-4.1,\n     * as well comments placed between the name (if present) and the bracketed email address:\n     * - name (comment) <email>\n     * - email\n     * In the first case, the `email` is the only required part, and it must contain the `@` symbol.\n     * The `name` and `comment` parts can include any letters, whitespace, and symbols, except for `(` and `)`,\n     * since they interfere with `comment` parsing.\n     */\n\n    const isValidEmail = str => /^[^\\s@]+@[^\\s@]+$/.test(str); // enforce single @ and no whitespace\n    const firstBracket = userID.indexOf('<');\n    const lastBracket = userID.lastIndexOf('>');\n    if (\n      firstBracket !== -1 &&\n      lastBracket !== -1 &&\n      lastBracket > firstBracket\n    ) {\n      const potentialEmail = userID.substring(firstBracket + 1, lastBracket);\n      if (isValidEmail(potentialEmail)) {\n        this.email = potentialEmail;\n        const beforeEmail = userID.substring(0, firstBracket).trim();\n        const firstParen = beforeEmail.indexOf('(');\n        const lastParen = beforeEmail.lastIndexOf(')');\n        if (firstParen !== -1 && lastParen !== -1 && lastParen > firstParen) {\n          this.comment = beforeEmail\n            .substring(firstParen + 1, lastParen)\n            .trim();\n          this.name = beforeEmail.substring(0, firstParen).trim();\n        } else {\n          this.name = beforeEmail;\n          this.comment = '';\n        }\n      }\n    } else if (isValidEmail(userID.trim())) {\n      // unbracketed email case\n      this.email = userID.trim();\n      this.name = '';\n      this.comment = '';\n    }\n\n    this.userID = userID;\n  }\n\n  /**\n   * Creates a binary representation of the user id packet\n   * @returns {Uint8Array} Binary representation.\n   */\n  write() {\n    return util.encodeUTF8(this.userID);\n  }\n\n  equals(otherUserID) {\n    return otherUserID && otherUserID.userID === this.userID;\n  }\n}\n\nexport default UserIDPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport SecretKeyPacket from './secret_key';\nimport enums from '../enums';\nimport defaultConfig from '../config';\n\n/**\n * A Secret-Subkey packet (tag 7) is the subkey analog of the Secret\n * Key packet and has exactly the same format.\n * @extends SecretKeyPacket\n */\nclass SecretSubkeyPacket extends SecretKeyPacket {\n  static get tag() {\n    return enums.packet.secretSubkey;\n  }\n\n  /**\n   * @param {Date} [date] - Creation date\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  constructor(date = new Date(), config = defaultConfig) {\n    super(date, config);\n  }\n}\n\nexport default SecretSubkeyPacket;\n","import enums from '../enums';\nimport { UnsupportedError } from './packet';\n\n/**\n * Implementation of the Trust Packet (Tag 12)\n *\n * {@link https://tools.ietf.org/html/rfc4880#section-5.10|RFC4880 5.10}:\n * The Trust packet is used only within keyrings and is not normally\n * exported.  Trust packets contain data that record the user's\n * specifications of which key holders are trustworthy introducers,\n * along with other information that implementing software uses for\n * trust information.  The format of Trust packets is defined by a given\n * implementation.\n *\n * Trust packets SHOULD NOT be emitted to output streams that are\n * transferred to other users, and they SHOULD be ignored on any input\n * other than local keyring files.\n */\nclass TrustPacket {\n  static get tag() {\n    return enums.packet.trust;\n  }\n\n  /**\n   * Parsing function for a trust packet (tag 12).\n   * Currently not implemented as we ignore trust packets\n   */\n  read() {\n    throw new UnsupportedError('Trust packets are not supported');\n  }\n\n  write() {\n    throw new UnsupportedError('Trust packets are not supported');\n  }\n}\n\nexport default TrustPacket;\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2022 Proton AG\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { getRandomBytes } from '../crypto';\nimport enums from '../enums';\n\n/**\n * Implementation of the Padding Packet\n *\n * {@link https://datatracker.ietf.org/doc/html/draft-ietf-openpgp-crypto-refresh#name-padding-packet-tag-21}:\n * Padding Packet\n */\nclass PaddingPacket {\n  static get tag() {\n    return enums.packet.padding;\n  }\n\n  constructor() {\n    this.padding = null;\n  }\n\n  /**\n   * Read a padding packet\n   * @param {Uint8Array | ReadableStream<Uint8Array>} bytes\n   */\n  read(bytes) { // eslint-disable-line @typescript-eslint/no-unused-vars\n    // Padding packets are ignored, so this function is never called.\n  }\n\n  /**\n   * Write the padding packet\n   * @returns {Uint8Array} The padding packet.\n   */\n  write() {\n    return this.padding;\n  }\n\n  /**\n   * Create random padding.\n   * @param {Number} length - The length of padding to be generated.\n   * @throws {Error} if padding generation was not successful\n   * @async\n   */\n  async createPadding(length) {\n    this.padding = await getRandomBytes(length);\n  }\n}\n\nexport default PaddingPacket;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor, unarmor } from './encoding/armor';\nimport { PacketList, SignaturePacket } from './packet';\nimport enums from './enums';\nimport util from './util';\nimport defaultConfig from './config';\n\n// A Signature can contain the following packets\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP signature.\n */\nexport class Signature {\n  /**\n   * @param {PacketList} packetlist - The signature packets\n   */\n  constructor(packetlist) {\n    this.packets = packetlist || new PacketList();\n  }\n\n  /**\n   * Returns binary encoded signature\n   * @returns {ReadableStream<Uint8Array>} Binary signature.\n   */\n  write() {\n    return this.packets.write();\n  }\n\n  /**\n   * Returns ASCII armored text of signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    // An ASCII-armored sequence of Signature packets that only includes v6 Signature packets MUST NOT contain a CRC24 footer.\n    const emitChecksum = this.packets.some(packet => packet.constructor.tag === SignaturePacket.tag && packet.version !== 6);\n    return armor(enums.armor.signature, this.write(), undefined, undefined, undefined, emitChecksum, config);\n  }\n\n  /**\n   * Returns an array of KeyIDs of all of the issuers who created this signature\n   * @returns {Array<KeyID>} The Key IDs of the signing keys\n   */\n  getSigningKeyIDs() {\n    return this.packets.map(packet => packet.issuerKeyID);\n  }\n}\n\n/**\n * reads an (optionally armored) OpenPGP signature and returns a signature object\n * @param {Object} options\n * @param {String} [options.armoredSignature] - Armored signature to be parsed\n * @param {Uint8Array} [options.binarySignature] - Binary signature to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Signature>} New signature object.\n * @async\n * @static\n */\nexport async function readSignature({ armoredSignature, binarySignature, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  let input = armoredSignature || binarySignature;\n  if (!input) {\n    throw new Error('readSignature: must pass options object containing `armoredSignature` or `binarySignature`');\n  }\n  if (armoredSignature && !util.isString(armoredSignature)) {\n    throw new Error('readSignature: options.armoredSignature must be a string');\n  }\n  if (binarySignature && !util.isUint8Array(binarySignature)) {\n    throw new Error('readSignature: options.binarySignature must be a Uint8Array');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (armoredSignature) {\n    const { type, data } = await unarmor(input, config);\n    if (type !== enums.armor.signature) {\n      throw new Error('Armored text not of type signature');\n    }\n    input = data;\n  }\n  const packetlist = await PacketList.fromBinary(input, allowedPackets, config);\n  return new Signature(packetlist);\n}\n","/**\n * @fileoverview Provides helpers methods for key module\n * @module key/helper\n */\n\nimport {\n  SecretKeyPacket,\n  SecretSubkeyPacket,\n  SignaturePacket\n} from '../packet';\nimport enums from '../enums';\nimport { getPreferredCurveHashAlgo, getHashByteLength } from '../crypto';\nimport util from '../util';\nimport defaultConfig from '../config';\n\nexport async function generateSecretSubkey(options, config) {\n  const secretSubkeyPacket = new SecretSubkeyPacket(options.date, config);\n  secretSubkeyPacket.packets = null;\n  secretSubkeyPacket.algorithm = enums.write(enums.publicKey, options.algorithm);\n  await secretSubkeyPacket.generate(options.rsaBits, options.curve);\n  await secretSubkeyPacket.computeFingerprintAndKeyID();\n  return secretSubkeyPacket;\n}\n\nexport async function generateSecretKey(options, config) {\n  const secretKeyPacket = new SecretKeyPacket(options.date, config);\n  secretKeyPacket.packets = null;\n  secretKeyPacket.algorithm = enums.write(enums.publicKey, options.algorithm);\n  await secretKeyPacket.generate(options.rsaBits, options.curve, options.config);\n  await secretKeyPacket.computeFingerprintAndKeyID();\n  return secretKeyPacket;\n}\n\n/**\n * Returns the valid and non-expired signature that has the latest creation date, while ignoring signatures created in the future.\n * @param {Array<SignaturePacket>} signatures - List of signatures\n * @param {PublicKeyPacket|PublicSubkeyPacket} publicKey - Public key packet to verify the signature\n * @param {module:enums.signature} signatureType - Signature type to determine how to hash the data (NB: for userID signatures,\n *                          `enums.signatures.certGeneric` should be given regardless of the actual trust level)\n * @param {Date} date - Use the given date instead of the current time\n * @param {Object} config - full configuration\n * @returns {Promise<SignaturePacket>} The latest valid signature.\n * @async\n */\nexport async function getLatestValidSignature(signatures, publicKey, signatureType, dataToVerify, date = new Date(), config) {\n  let latestValid;\n  let exception;\n  for (let i = signatures.length - 1; i >= 0; i--) {\n    try {\n      if (\n        (!latestValid || signatures[i].created >= latestValid.created)\n      ) {\n        await signatures[i].verify(publicKey, signatureType, dataToVerify, date, undefined, config);\n        latestValid = signatures[i];\n      }\n    } catch (e) {\n      exception = e;\n    }\n  }\n  if (!latestValid) {\n    throw util.wrapError(\n      `Could not find valid ${enums.read(enums.signature, signatureType)} signature in key ${publicKey.getKeyID().toHex()}`\n        .replace('certGeneric ', 'self-')\n        .replace(/([a-z])([A-Z])/g, (_, $1, $2) => $1 + ' ' + $2.toLowerCase()),\n      exception);\n  }\n  return latestValid;\n}\n\nexport function isDataExpired(keyPacket, signature, date = new Date()) {\n  const normDate = util.normalizeDate(date);\n  if (normDate !== null) {\n    const expirationTime = getKeyExpirationTime(keyPacket, signature);\n    return !(keyPacket.created <= normDate && normDate < expirationTime);\n  }\n  return false;\n}\n\n/**\n * Create Binding signature to the key according to the {@link https://tools.ietf.org/html/rfc4880#section-5.2.1}\n * @param {SecretSubkeyPacket} subkey - Subkey key packet\n * @param {SecretKeyPacket} primaryKey - Primary key packet\n * @param {Object} options\n * @param {Object} config - Full configuration\n */\nexport async function createBindingSignature(subkey, primaryKey, options, config) {\n  const dataToSign = {};\n  dataToSign.key = primaryKey;\n  dataToSign.bind = subkey;\n  const signatureProperties = { signatureType: enums.signature.subkeyBinding };\n  if (options.sign) {\n    signatureProperties.keyFlags = [enums.keyFlags.signData];\n    signatureProperties.embeddedSignature = await createSignaturePacket(dataToSign, [], subkey, {\n      signatureType: enums.signature.keyBinding\n    }, options.date, undefined, undefined, undefined, config);\n  } else {\n    signatureProperties.keyFlags = [enums.keyFlags.encryptCommunication | enums.keyFlags.encryptStorage];\n  }\n  if (options.keyExpirationTime > 0) {\n    signatureProperties.keyExpirationTime = options.keyExpirationTime;\n    signatureProperties.keyNeverExpires = false;\n  }\n  const subkeySignaturePacket = await createSignaturePacket(dataToSign, [], primaryKey, signatureProperties, options.date, undefined, undefined, undefined, config);\n  return subkeySignaturePacket;\n}\n\n/**\n * Returns the preferred signature hash algorithm for a set of keys.\n * @param {Array<Key>} [targetKeys] - The keys to get preferences from\n * @param {SecretKeyPacket|SecretSubkeyPacket} signingKeyPacket - key packet used for signing\n * @param {Date} [date] - Use the given date for verification instead of the current time\n * @param {Object} [targetUserID] - User IDs corresponding to `targetKeys` to get preferences from\n * @param {Object} config - full configuration\n * @returns {Promise<enums.hash>}\n * @async\n */\nexport async function getPreferredHashAlgo(targetKeys, signingKeyPacket, date = new Date(), targetUserIDs = [], config) {\n  /**\n   * If `preferredSenderAlgo` appears in the prefs of all recipients, we pick it; otherwise, we use the\n   * strongest supported algo (`defaultAlgo` is always implicitly supported by all keys).\n   * if no keys are available, `preferredSenderAlgo` is returned.\n   * For ECC signing key, the curve preferred hash is taken into account as well (see logic below).\n   */\n  const defaultAlgo = enums.hash.sha256; // MUST implement\n  const preferredSenderAlgo = config.preferredHashAlgorithm;\n\n  const supportedAlgosPerTarget = await Promise.all(targetKeys.map(async (key, i) => {\n    const selfCertification = await key.getPrimarySelfSignature(date, targetUserIDs[i], config);\n    const targetPrefs = selfCertification.preferredHashAlgorithms;\n    return targetPrefs || [];\n  }));\n  const supportedAlgosMap = new Map(); // use Map over object to preserve numeric keys\n  for (const supportedAlgos of supportedAlgosPerTarget) {\n    for (const hashAlgo of supportedAlgos) {\n      try {\n        // ensure that `hashAlgo` is recognized/implemented by us, otherwise e.g. `getHashByteLength` will throw later on\n        const supportedAlgo = enums.write(enums.hash, hashAlgo);\n        supportedAlgosMap.set(\n          supportedAlgo,\n          supportedAlgosMap.has(supportedAlgo) ? supportedAlgosMap.get(supportedAlgo) + 1 : 1\n        );\n      } catch {}\n    }\n  }\n  const isSupportedHashAlgo = hashAlgo => targetKeys.length === 0 || supportedAlgosMap.get(hashAlgo) === targetKeys.length || hashAlgo === defaultAlgo;\n  const getStrongestSupportedHashAlgo = () => {\n    if (supportedAlgosMap.size === 0) {\n      return defaultAlgo;\n    }\n    const sortedHashAlgos = Array.from(supportedAlgosMap.keys())\n      .filter(hashAlgo => isSupportedHashAlgo(hashAlgo))\n      .sort((algoA, algoB) => getHashByteLength(algoA) - getHashByteLength(algoB));\n    const strongestHashAlgo = sortedHashAlgos[0];\n    // defaultAlgo is always implicitly supported, and might be stronger than the rest\n    return getHashByteLength(strongestHashAlgo) >= getHashByteLength(defaultAlgo) ? strongestHashAlgo : defaultAlgo;\n  };\n\n  const eccAlgos = new Set([\n    enums.publicKey.ecdsa,\n    enums.publicKey.eddsaLegacy,\n    enums.publicKey.ed25519,\n    enums.publicKey.ed448\n  ]);\n\n  if (eccAlgos.has(signingKeyPacket.algorithm)) {\n    // For ECC, the returned hash algo MUST be at least as strong as `preferredCurveHashAlgo`, see:\n    // - ECDSA: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.2-5\n    // - EdDSALegacy: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.3-3\n    // - Ed25519: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.4-4\n    // - Ed448: https://www.rfc-editor.org/rfc/rfc9580.html#section-5.2.3.5-4\n    // Hence, we return the `preferredHashAlgo` as long as it's supported and strong enough;\n    // Otherwise, we look at the strongest supported algo, and ultimately fallback to the curve\n    // preferred algo, even if not supported by all targets.\n    const preferredCurveAlgo = getPreferredCurveHashAlgo(signingKeyPacket.algorithm, signingKeyPacket.publicParams.oid);\n\n    const preferredSenderAlgoIsSupported = isSupportedHashAlgo(preferredSenderAlgo);\n    const preferredSenderAlgoStrongerThanCurveAlgo = getHashByteLength(preferredSenderAlgo) >= getHashByteLength(preferredCurveAlgo);\n\n    if (preferredSenderAlgoIsSupported && preferredSenderAlgoStrongerThanCurveAlgo) {\n      return preferredSenderAlgo;\n    } else {\n      const strongestSupportedAlgo = getStrongestSupportedHashAlgo();\n      return getHashByteLength(strongestSupportedAlgo) >= getHashByteLength(preferredCurveAlgo) ?\n        strongestSupportedAlgo :\n        preferredCurveAlgo;\n    }\n  }\n\n  // `preferredSenderAlgo` may be weaker than the default, but we do not guard against this,\n  // since it was manually set by the sender.\n  return isSupportedHashAlgo(preferredSenderAlgo) ? preferredSenderAlgo : getStrongestSupportedHashAlgo();\n}\n\n/**\n * Returns the preferred compression algorithm for a set of keys\n * @param {Array<Key>} [keys] - Set of keys\n * @param {Date} [date] - Use the given date for verification instead of the current time\n * @param {Array} [userIDs] - User IDs\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<module:enums.compression>} Preferred compression algorithm\n * @async\n */\nexport async function getPreferredCompressionAlgo(keys = [], date = new Date(), userIDs = [], config = defaultConfig) {\n  const defaultAlgo = enums.compression.uncompressed;\n  const preferredSenderAlgo = config.preferredCompressionAlgorithm;\n\n  // if preferredSenderAlgo appears in the prefs of all recipients, we pick it\n  // otherwise we use the default algo\n  // if no keys are available, preferredSenderAlgo is returned\n  const senderAlgoSupport = await Promise.all(keys.map(async function(key, i) {\n    const selfCertification = await key.getPrimarySelfSignature(date, userIDs[i], config);\n    const recipientPrefs = selfCertification.preferredCompressionAlgorithms;\n    return !!recipientPrefs && recipientPrefs.indexOf(preferredSenderAlgo) >= 0;\n  }));\n  return senderAlgoSupport.every(Boolean) ? preferredSenderAlgo : defaultAlgo;\n}\n\n/**\n * Returns the preferred symmetric and AEAD algorithm (if any) for a set of keys\n * @param {Array<Key>} [keys] - Set of keys\n * @param {Date} [date] - Use the given date for verification instead of the current time\n * @param {Array} [userIDs] - User IDs\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<{ symmetricAlgo: module:enums.symmetric, aeadAlgo: module:enums.aead | undefined }>} Object containing the preferred symmetric algorithm, and the preferred AEAD algorithm, or undefined if CFB is preferred\n * @async\n */\nexport async function getPreferredCipherSuite(keys = [], date = new Date(), userIDs = [], config = defaultConfig) {\n  const selfSigs = await Promise.all(keys.map((key, i) => key.getPrimarySelfSignature(date, userIDs[i], config)));\n  const withAEAD = keys.length ?\n    selfSigs.every(selfSig => selfSig.features && (selfSig.features[0] & enums.features.seipdv2)) :\n    config.aeadProtect;\n\n  if (withAEAD) {\n    const defaultCipherSuite = { symmetricAlgo: enums.symmetric.aes128, aeadAlgo: enums.aead.ocb };\n    const desiredCipherSuites = [\n      { symmetricAlgo: config.preferredSymmetricAlgorithm, aeadAlgo: config.preferredAEADAlgorithm },\n      { symmetricAlgo: config.preferredSymmetricAlgorithm, aeadAlgo: enums.aead.ocb },\n      { symmetricAlgo: enums.symmetric.aes128, aeadAlgo: config.preferredAEADAlgorithm }\n    ];\n    for (const desiredCipherSuite of desiredCipherSuites) {\n      if (selfSigs.every(selfSig => selfSig.preferredCipherSuites && selfSig.preferredCipherSuites.some(\n        cipherSuite => cipherSuite[0] === desiredCipherSuite.symmetricAlgo && cipherSuite[1] === desiredCipherSuite.aeadAlgo\n      ))) {\n        return desiredCipherSuite;\n      }\n    }\n    return defaultCipherSuite;\n  }\n  const defaultSymAlgo = enums.symmetric.aes128;\n  const desiredSymAlgo = config.preferredSymmetricAlgorithm;\n  return {\n    symmetricAlgo: selfSigs.every(selfSig => selfSig.preferredSymmetricAlgorithms && selfSig.preferredSymmetricAlgorithms.includes(desiredSymAlgo)) ?\n      desiredSymAlgo :\n      defaultSymAlgo,\n    aeadAlgo: undefined\n  };\n}\n\n/**\n * Create signature packet\n * @param {Object} dataToSign - Contains packets to be signed\n * @param {Array<Key>} recipientKeys - keys to get preferences from\n * @param  {SecretKeyPacket|\n *          SecretSubkeyPacket}              signingKeyPacket secret key packet for signing\n * @param {Object} [signatureProperties] - Properties to write on the signature packet before signing\n * @param {Date} [date] - Override the creationtime of the signature\n * @param {Object} [userID] - User ID\n * @param {Array} [notations] - Notation Data to add to the signature, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n * @param {Object} [detached] - Whether to create a detached signature packet\n * @param {Object} config - full configuration\n * @returns {Promise<SignaturePacket>} Signature packet.\n */\nexport async function createSignaturePacket(dataToSign, recipientKeys, signingKeyPacket, signatureProperties, date, recipientUserIDs, notations = [], detached = false, config) {\n  if (signingKeyPacket.isDummy()) {\n    throw new Error('Cannot sign with a gnu-dummy key.');\n  }\n  if (!signingKeyPacket.isDecrypted()) {\n    throw new Error('Signing key is not decrypted.');\n  }\n  const signaturePacket = new SignaturePacket();\n  Object.assign(signaturePacket, signatureProperties);\n  signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;\n  signaturePacket.hashAlgorithm = await getPreferredHashAlgo(recipientKeys, signingKeyPacket, date, recipientUserIDs, config);\n  signaturePacket.rawNotations = [...notations];\n  await signaturePacket.sign(signingKeyPacket, dataToSign, date, detached, config);\n  return signaturePacket;\n}\n\n/**\n * Merges signatures from source[attr] to dest[attr]\n * @param {Object} source\n * @param {Object} dest\n * @param {String} attr\n * @param {Date} [date] - date to use for signature expiration check, instead of the current time\n * @param {Function} [checkFn] - signature only merged if true\n */\nexport async function mergeSignatures(source, dest, attr, date = new Date(), checkFn) {\n  source = source[attr];\n  if (source) {\n    if (!dest[attr].length) {\n      dest[attr] = source;\n    } else {\n      await Promise.all(source.map(async function(sourceSig) {\n        if (!sourceSig.isExpired(date) && (!checkFn || await checkFn(sourceSig)) &&\n            !dest[attr].some(function(destSig) {\n              return util.equalsUint8Array(destSig.writeParams(), sourceSig.writeParams());\n            })) {\n          dest[attr].push(sourceSig);\n        }\n      }));\n    }\n  }\n}\n\n/**\n * Checks if a given certificate or binding signature is revoked\n * @param  {SecretKeyPacket|\n *          PublicKeyPacket}        primaryKey   The primary key packet\n * @param {Object} dataToVerify - The data to check\n * @param {Array<SignaturePacket>} revocations - The revocation signatures to check\n * @param {SignaturePacket} signature - The certificate or signature to check\n * @param  {PublicSubkeyPacket|\n *          SecretSubkeyPacket|\n *          PublicKeyPacket|\n *          SecretKeyPacket} key, optional The key packet to verify the signature, instead of the primary key\n * @param {Date} date - Use the given date instead of the current time\n * @param {Object} config - Full configuration\n * @returns {Promise<Boolean>} True if the signature revokes the data.\n * @async\n */\nexport async function isDataRevoked(primaryKey, signatureType, dataToVerify, revocations, signature, key, date = new Date(), config) {\n  key = key || primaryKey;\n  const revocationKeyIDs = [];\n  await Promise.all(revocations.map(async function(revocationSignature) {\n    try {\n      if (\n        // Note: a third-party revocation signature could legitimately revoke a\n        // self-signature if the signature has an authorized revocation key.\n        // However, we don't support passing authorized revocation keys, nor\n        // verifying such revocation signatures. Instead, we indicate an error\n        // when parsing a key with an authorized revocation key, and ignore\n        // third-party revocation signatures here. (It could also be revoking a\n        // third-party key certification, which should only affect\n        // `verifyAllCertifications`.)\n        !signature || revocationSignature.issuerKeyID.equals(signature.issuerKeyID)\n      ) {\n        const isHardRevocation = ![\n          enums.reasonForRevocation.keyRetired,\n          enums.reasonForRevocation.keySuperseded,\n          enums.reasonForRevocation.userIDInvalid\n        ].includes(revocationSignature.reasonForRevocationFlag);\n\n        await revocationSignature.verify(\n          key, signatureType, dataToVerify, isHardRevocation ? null : date, false, config\n        );\n\n        // TODO get an identifier of the revoked object instead\n        revocationKeyIDs.push(revocationSignature.issuerKeyID);\n      }\n    } catch (e) {}\n  }));\n  // TODO further verify that this is the signature that should be revoked\n  if (signature) {\n    signature.revoked = revocationKeyIDs.some(keyID => keyID.equals(signature.issuerKeyID)) ? true :\n      signature.revoked || false;\n    return signature.revoked;\n  }\n  return revocationKeyIDs.length > 0;\n}\n\n/**\n * Returns key expiration time based on the given certification signature.\n * The expiration time of the signature is ignored.\n * @param {PublicSubkeyPacket|PublicKeyPacket} keyPacket - key to check\n * @param {SignaturePacket} signature - signature to process\n * @returns {Date|Infinity} expiration time or infinity if the key does not expire\n */\nexport function getKeyExpirationTime(keyPacket, signature) {\n  let expirationTime;\n  // check V4 expiration time\n  if (signature.keyNeverExpires === false) {\n    expirationTime = keyPacket.created.getTime() + signature.keyExpirationTime * 1000;\n  }\n  return expirationTime ? new Date(expirationTime) : Infinity;\n}\n\nexport function sanitizeKeyOptions(options, subkeyDefaults = {}) {\n  options.type = options.type || subkeyDefaults.type;\n  options.curve = options.curve || subkeyDefaults.curve;\n  options.rsaBits = options.rsaBits || subkeyDefaults.rsaBits;\n  options.keyExpirationTime = options.keyExpirationTime !== undefined ? options.keyExpirationTime : subkeyDefaults.keyExpirationTime;\n  options.passphrase = util.isString(options.passphrase) ? options.passphrase : subkeyDefaults.passphrase;\n  options.date = options.date || subkeyDefaults.date;\n\n  options.sign = options.sign || false;\n\n  switch (options.type) {\n    case 'ecc': // NB: this case also handles legacy eddsa and x25519 keys, based on `options.curve`\n      try {\n        options.curve = enums.write(enums.curve, options.curve);\n      } catch (e) {\n        throw new Error('Unknown curve');\n      }\n      if (options.curve === enums.curve.ed25519Legacy || options.curve === enums.curve.curve25519Legacy ||\n        options.curve === 'ed25519' || options.curve === 'curve25519') { // keep support for curve names without 'Legacy' addition, for now\n        options.curve = options.sign ? enums.curve.ed25519Legacy : enums.curve.curve25519Legacy;\n      }\n      if (options.sign) {\n        options.algorithm = options.curve === enums.curve.ed25519Legacy ? enums.publicKey.eddsaLegacy : enums.publicKey.ecdsa;\n      } else {\n        options.algorithm = enums.publicKey.ecdh;\n      }\n      break;\n    case 'curve25519':\n      options.algorithm = options.sign ? enums.publicKey.ed25519 : enums.publicKey.x25519;\n      break;\n    case 'curve448':\n      options.algorithm = options.sign ? enums.publicKey.ed448 : enums.publicKey.x448;\n      break;\n    case 'rsa':\n      options.algorithm = enums.publicKey.rsaEncryptSign;\n      break;\n    default:\n      throw new Error(`Unsupported key type ${options.type}`);\n  }\n  return options;\n}\n\nexport function validateSigningKeyPacket(keyPacket, signature, config) {\n  switch (keyPacket.algorithm) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign:\n    case enums.publicKey.dsa:\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.eddsaLegacy:\n    case enums.publicKey.ed25519:\n    case enums.publicKey.ed448:\n      if (!signature.keyFlags && !config.allowMissingKeyFlags) {\n        throw new Error('None of the key flags is set: consider passing `config.allowMissingKeyFlags`');\n      }\n      return !signature.keyFlags ||\n        (signature.keyFlags[0] & enums.keyFlags.signData) !== 0;\n    default:\n      return false;\n  }\n}\n\nexport function validateEncryptionKeyPacket(keyPacket, signature, config) {\n  switch (keyPacket.algorithm) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.elgamal:\n    case enums.publicKey.ecdh:\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448:\n      if (!signature.keyFlags && !config.allowMissingKeyFlags) {\n        throw new Error('None of the key flags is set: consider passing `config.allowMissingKeyFlags`');\n      }\n      return !signature.keyFlags ||\n        (signature.keyFlags[0] & enums.keyFlags.encryptCommunication) !== 0 ||\n        (signature.keyFlags[0] & enums.keyFlags.encryptStorage) !== 0;\n    default:\n      return false;\n  }\n}\n\nexport function validateDecryptionKeyPacket(keyPacket, signature, config) {\n  if (!signature.keyFlags && !config.allowMissingKeyFlags) {\n    throw new Error('None of the key flags is set: consider passing `config.allowMissingKeyFlags`');\n  }\n\n  switch (keyPacket.algorithm) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.elgamal:\n    case enums.publicKey.ecdh:\n    case enums.publicKey.x25519:\n    case enums.publicKey.x448: {\n      const isValidSigningKeyPacket = !signature.keyFlags || (signature.keyFlags[0] & enums.keyFlags.signData) !== 0;\n      if (isValidSigningKeyPacket && config.allowInsecureDecryptionWithSigningKeys) {\n        // This is only relevant for RSA keys, all other signing algorithms cannot decrypt\n        return true;\n      }\n\n      return !signature.keyFlags ||\n      (signature.keyFlags[0] & enums.keyFlags.encryptCommunication) !== 0 ||\n      (signature.keyFlags[0] & enums.keyFlags.encryptStorage) !== 0;\n    }\n    default:\n      return false;\n  }\n}\n\n/**\n * Check key against blacklisted algorithms and minimum strength requirements.\n * @param {SecretKeyPacket|PublicKeyPacket|\n *        SecretSubkeyPacket|PublicSubkeyPacket} keyPacket\n * @param {Config} config\n * @throws {Error} if the key packet does not meet the requirements\n */\nexport function checkKeyRequirements(keyPacket, config) {\n  const keyAlgo = enums.write(enums.publicKey, keyPacket.algorithm);\n  const algoInfo = keyPacket.getAlgorithmInfo();\n  if (config.rejectPublicKeyAlgorithms.has(keyAlgo)) {\n    throw new Error(`${algoInfo.algorithm} keys are considered too weak.`);\n  }\n  switch (keyAlgo) {\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign:\n    case enums.publicKey.rsaEncrypt:\n      if (algoInfo.bits < config.minRSABits) {\n        throw new Error(`RSA keys shorter than ${config.minRSABits} bits are considered too weak.`);\n      }\n      break;\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.eddsaLegacy:\n    case enums.publicKey.ecdh:\n      if (config.rejectCurves.has(algoInfo.curve)) {\n        throw new Error(`Support for ${algoInfo.algorithm} keys using curve ${algoInfo.curve} is disabled.`);\n      }\n      break;\n    default:\n      break;\n  }\n}\n","/**\n * @module key/User\n */\n\nimport enums from '../enums';\nimport util from '../util';\nimport { PacketList } from '../packet';\nimport { mergeSignatures, isDataRevoked, createSignaturePacket } from './helper';\nimport defaultConfig from '../config';\n\n/**\n * Class that represents an user ID or attribute packet and the relevant signatures.\n  * @param {UserIDPacket|UserAttributePacket} userPacket - packet containing the user info\n  * @param {Key} mainKey - reference to main Key object containing the primary key and subkeys that the user is associated with\n */\nclass User {\n  constructor(userPacket, mainKey) {\n    this.userID = userPacket.constructor.tag === enums.packet.userID ? userPacket : null;\n    this.userAttribute = userPacket.constructor.tag === enums.packet.userAttribute ? userPacket : null;\n    this.selfCertifications = [];\n    this.otherCertifications = [];\n    this.revocationSignatures = [];\n    this.mainKey = mainKey;\n  }\n\n  /**\n   * Transforms structured user data to packetlist\n   * @returns {PacketList}\n   */\n  toPacketList() {\n    const packetlist = new PacketList();\n    packetlist.push(this.userID || this.userAttribute);\n    packetlist.push(...this.revocationSignatures);\n    packetlist.push(...this.selfCertifications);\n    packetlist.push(...this.otherCertifications);\n    return packetlist;\n  }\n\n  /**\n   * Shallow clone\n   * @returns {User}\n   */\n  clone() {\n    const user = new User(this.userID || this.userAttribute, this.mainKey);\n    user.selfCertifications = [...this.selfCertifications];\n    user.otherCertifications = [...this.otherCertifications];\n    user.revocationSignatures = [...this.revocationSignatures];\n    return user;\n  }\n\n  /**\n   * Generate third-party certifications over this user and its primary key\n   * @param {Array<PrivateKey>} signingKeys - Decrypted private keys for signing\n   * @param {Date} [date] - Date to use as creation date of the certificate, instead of the current time\n   * @param {Object} config - Full configuration\n   * @returns {Promise<User>} New user with new certifications.\n   * @async\n   */\n  async certify(signingKeys, date, config) {\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToSign = {\n      userID: this.userID,\n      userAttribute: this.userAttribute,\n      key: primaryKey\n    };\n    const user = new User(dataToSign.userID || dataToSign.userAttribute, this.mainKey);\n    user.otherCertifications = await Promise.all(signingKeys.map(async function(privateKey) {\n      if (!privateKey.isPrivate()) {\n        throw new Error('Need private key for signing');\n      }\n      if (privateKey.hasSameFingerprintAs(primaryKey)) {\n        throw new Error(\"The user's own key can only be used for self-certifications\");\n      }\n      const signingKey = await privateKey.getSigningKey(undefined, date, undefined, config);\n      return createSignaturePacket(dataToSign, [privateKey], signingKey.keyPacket, {\n        // Most OpenPGP implementations use generic certification (0x10)\n        signatureType: enums.signature.certGeneric,\n        keyFlags: [enums.keyFlags.certifyKeys | enums.keyFlags.signData]\n      }, date, undefined, undefined, undefined, config);\n    }));\n    await user.update(this, date, config);\n    return user;\n  }\n\n  /**\n   * Checks if a given certificate of the user is revoked\n   * @param {SignaturePacket} certificate - The certificate to verify\n   * @param  {PublicSubkeyPacket|\n   *          SecretSubkeyPacket|\n   *          PublicKeyPacket|\n   *          SecretKeyPacket} [keyPacket] The key packet to verify the signature, instead of the primary key\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} config - Full configuration\n   * @returns {Promise<Boolean>} True if the certificate is revoked.\n   * @async\n   */\n  async isRevoked(certificate, keyPacket, date = new Date(), config = defaultConfig) {\n    const primaryKey = this.mainKey.keyPacket;\n    return isDataRevoked(primaryKey, enums.signature.certRevocation, {\n      key: primaryKey,\n      userID: this.userID,\n      userAttribute: this.userAttribute\n    }, this.revocationSignatures, certificate, keyPacket, date, config);\n  }\n\n  /**\n   * Verifies the user certificate.\n   * @param {SignaturePacket} certificate - A certificate of this user\n   * @param {Array<PublicKey>} verificationKeys - Array of keys to verify certificate signatures\n   * @param {Date} [date] - Use the given date instead of the current time\n   * @param {Object} config - Full configuration\n   * @returns {Promise<true|null>} true if the certificate could be verified, or null if the verification keys do not correspond to the certificate\n   * @throws if the user certificate is invalid.\n   * @async\n   */\n  async verifyCertificate(certificate, verificationKeys, date = new Date(), config) {\n    const that = this;\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToVerify = {\n      userID: this.userID,\n      userAttribute: this.userAttribute,\n      key: primaryKey\n    };\n    const { issuerKeyID } = certificate;\n    const issuerKeys = verificationKeys.filter(key => key.getKeys(issuerKeyID).length > 0);\n    if (issuerKeys.length === 0) {\n      return null;\n    }\n    await Promise.all(issuerKeys.map(async key => {\n      const signingKey = await key.getSigningKey(issuerKeyID, certificate.created, undefined, config);\n      if (certificate.revoked || await that.isRevoked(certificate, signingKey.keyPacket, date, config)) {\n        throw new Error('User certificate is revoked');\n      }\n      try {\n        await certificate.verify(signingKey.keyPacket, enums.signature.certGeneric, dataToVerify, date, undefined, config);\n      } catch (e) {\n        throw util.wrapError('User certificate is invalid', e);\n      }\n    }));\n    return true;\n  }\n\n  /**\n   * Verifies all user certificates\n   * @param {Array<PublicKey>} verificationKeys - Array of keys to verify certificate signatures\n   * @param {Date} [date] - Use the given date instead of the current time\n   * @param {Object} config - Full configuration\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   valid: Boolean | null\n   * }>>} List of signer's keyID and validity of signature.\n   *      Signature validity is null if the verification keys do not correspond to the certificate.\n   * @async\n   */\n  async verifyAllCertifications(verificationKeys, date = new Date(), config) {\n    const that = this;\n    const certifications = this.selfCertifications.concat(this.otherCertifications);\n    return Promise.all(certifications.map(async certification => ({\n      keyID: certification.issuerKeyID,\n      valid: await that.verifyCertificate(certification, verificationKeys, date, config).catch(() => false)\n    })));\n  }\n\n  /**\n   * Verify User. Checks for existence of self signatures, revocation signatures\n   * and validity of self signature.\n   * @param {Date} date - Use the given date instead of the current time\n   * @param {Object} config - Full configuration\n   * @returns {Promise<true>} Status of user.\n   * @throws {Error} if there are no valid self signatures.\n   * @async\n   */\n  async verify(date = new Date(), config) {\n    if (!this.selfCertifications.length) {\n      throw new Error('No self-certifications found');\n    }\n    const that = this;\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToVerify = {\n      userID: this.userID,\n      userAttribute: this.userAttribute,\n      key: primaryKey\n    };\n    // TODO replace when Promise.some or Promise.any are implemented\n    let exception;\n    for (let i = this.selfCertifications.length - 1; i >= 0; i--) {\n      try {\n        const selfCertification = this.selfCertifications[i];\n        if (selfCertification.revoked || await that.isRevoked(selfCertification, undefined, date, config)) {\n          throw new Error('Self-certification is revoked');\n        }\n        try {\n          await selfCertification.verify(primaryKey, enums.signature.certGeneric, dataToVerify, date, undefined, config);\n        } catch (e) {\n          throw util.wrapError('Self-certification is invalid', e);\n        }\n        return true;\n      } catch (e) {\n        exception = e;\n      }\n    }\n    throw exception;\n  }\n\n  /**\n   * Update user with new components from specified user\n   * @param {User} sourceUser - Source user to merge\n   * @param {Date} date - Date to verify the validity of signatures\n   * @param {Object} config - Full configuration\n   * @returns {Promise<undefined>}\n   * @async\n   */\n  async update(sourceUser, date, config) {\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToVerify = {\n      userID: this.userID,\n      userAttribute: this.userAttribute,\n      key: primaryKey\n    };\n    // self signatures\n    await mergeSignatures(sourceUser, this, 'selfCertifications', date, async function(srcSelfSig) {\n      try {\n        await srcSelfSig.verify(primaryKey, enums.signature.certGeneric, dataToVerify, date, false, config);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n    // other signatures\n    await mergeSignatures(sourceUser, this, 'otherCertifications', date);\n    // revocation signatures\n    await mergeSignatures(sourceUser, this, 'revocationSignatures', date, function(srcRevSig) {\n      return isDataRevoked(primaryKey, enums.signature.certRevocation, dataToVerify, [srcRevSig], undefined, undefined, date, config);\n    });\n  }\n\n  /**\n   * Revokes the user\n   * @param {SecretKeyPacket} primaryKey - decrypted private primary key for revocation\n   * @param {Object} reasonForRevocation - optional, object indicating the reason for revocation\n   * @param  {module:enums.reasonForRevocation} reasonForRevocation.flag optional, flag indicating the reason for revocation\n   * @param  {String} reasonForRevocation.string optional, string explaining the reason for revocation\n   * @param {Date} date - optional, override the creationtime of the revocation signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<User>} New user with revocation signature.\n   * @async\n   */\n  async revoke(\n    primaryKey,\n    {\n      flag: reasonForRevocationFlag = enums.reasonForRevocation.noReason,\n      string: reasonForRevocationString = ''\n    } = {},\n    date = new Date(),\n    config = defaultConfig\n  ) {\n    const dataToSign = {\n      userID: this.userID,\n      userAttribute: this.userAttribute,\n      key: primaryKey\n    };\n    const user = new User(dataToSign.userID || dataToSign.userAttribute, this.mainKey);\n    user.revocationSignatures.push(await createSignaturePacket(dataToSign, [], primaryKey, {\n      signatureType: enums.signature.certRevocation,\n      reasonForRevocationFlag: enums.write(enums.reasonForRevocation, reasonForRevocationFlag),\n      reasonForRevocationString\n    }, date, undefined, undefined, false, config));\n    await user.update(this);\n    return user;\n  }\n}\n\nexport default User;\n","/**\n * @module key/Subkey\n */\n\nimport enums from '../enums';\nimport * as helper from './helper';\nimport { PacketList } from '../packet';\nimport defaultConfig from '../config';\n\n/**\n * Class that represents a subkey packet and the relevant signatures.\n * @borrows PublicSubkeyPacket#getKeyID as Subkey#getKeyID\n * @borrows PublicSubkeyPacket#getFingerprint as Subkey#getFingerprint\n * @borrows PublicSubkeyPacket#hasSameFingerprintAs as Subkey#hasSameFingerprintAs\n * @borrows PublicSubkeyPacket#getAlgorithmInfo as Subkey#getAlgorithmInfo\n * @borrows PublicSubkeyPacket#getCreationTime as Subkey#getCreationTime\n * @borrows PublicSubkeyPacket#isDecrypted as Subkey#isDecrypted\n */\nclass Subkey {\n  /**\n   * @param {SecretSubkeyPacket|PublicSubkeyPacket} subkeyPacket - subkey packet to hold in the Subkey\n   * @param {Key} mainKey - reference to main Key object, containing the primary key packet corresponding to the subkey\n   */\n  constructor(subkeyPacket, mainKey) {\n    this.keyPacket = subkeyPacket;\n    this.bindingSignatures = [];\n    this.revocationSignatures = [];\n    this.mainKey = mainKey;\n  }\n\n  /**\n   * Transforms structured subkey data to packetlist\n   * @returns {PacketList}\n   */\n  toPacketList() {\n    const packetlist = new PacketList();\n    packetlist.push(this.keyPacket);\n    packetlist.push(...this.revocationSignatures);\n    packetlist.push(...this.bindingSignatures);\n    return packetlist;\n  }\n\n  /**\n   * Shallow clone\n   * @return {Subkey}\n   */\n  clone() {\n    const subkey = new Subkey(this.keyPacket, this.mainKey);\n    subkey.bindingSignatures = [...this.bindingSignatures];\n    subkey.revocationSignatures = [...this.revocationSignatures];\n    return subkey;\n  }\n\n  /**\n   * Checks if a binding signature of a subkey is revoked\n   * @param {SignaturePacket} signature - The binding signature to verify\n   * @param  {PublicSubkeyPacket|\n   *          SecretSubkeyPacket|\n   *          PublicKeyPacket|\n   *          SecretKeyPacket} key, optional The key to verify the signature\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Boolean>} True if the binding signature is revoked.\n   * @async\n   */\n  async isRevoked(signature, key, date = new Date(), config = defaultConfig) {\n    const primaryKey = this.mainKey.keyPacket;\n    return helper.isDataRevoked(\n      primaryKey, enums.signature.subkeyRevocation, {\n        key: primaryKey,\n        bind: this.keyPacket\n      }, this.revocationSignatures, signature, key, date, config\n    );\n  }\n\n  /**\n   * Verify subkey. Checks for revocation signatures, expiration time\n   * and valid binding signature.\n   * @param {Date} date - Use the given date instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<SignaturePacket>}\n   * @throws {Error}           if the subkey is invalid.\n   * @async\n   */\n  async verify(date = new Date(), config = defaultConfig) {\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToVerify = { key: primaryKey, bind: this.keyPacket };\n    // check subkey binding signatures\n    const bindingSignature = await helper.getLatestValidSignature(this.bindingSignatures, primaryKey, enums.signature.subkeyBinding, dataToVerify, date, config);\n    // check binding signature is not revoked\n    if (bindingSignature.revoked || await this.isRevoked(bindingSignature, null, date, config)) {\n      throw new Error('Subkey is revoked');\n    }\n    // check for expiration time\n    if (helper.isDataExpired(this.keyPacket, bindingSignature, date)) {\n      throw new Error('Subkey is expired');\n    }\n    return bindingSignature;\n  }\n\n  /**\n   * Returns the expiration time of the subkey or Infinity if key does not expire.\n   * Returns null if the subkey is invalid.\n   * @param {Date} date - Use the given date instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Date | Infinity | null>}\n   * @async\n   */\n  async getExpirationTime(date = new Date(), config = defaultConfig) {\n    const primaryKey = this.mainKey.keyPacket;\n    const dataToVerify = { key: primaryKey, bind: this.keyPacket };\n    let bindingSignature;\n    try {\n      bindingSignature = await helper.getLatestValidSignature(this.bindingSignatures, primaryKey, enums.signature.subkeyBinding, dataToVerify, date, config);\n    } catch (e) {\n      return null;\n    }\n    const keyExpiry = helper.getKeyExpirationTime(this.keyPacket, bindingSignature);\n    const sigExpiry = bindingSignature.getExpirationTime();\n    return keyExpiry < sigExpiry ? keyExpiry : sigExpiry;\n  }\n\n  /**\n   * Update subkey with new components from specified subkey\n   * @param {Subkey} subkey - Source subkey to merge\n   * @param {Date} [date] - Date to verify validity of signatures\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if update failed\n   * @async\n   */\n  async update(subkey, date = new Date(), config = defaultConfig) {\n    const primaryKey = this.mainKey.keyPacket;\n    if (!this.hasSameFingerprintAs(subkey)) {\n      throw new Error('Subkey update method: fingerprints of subkeys not equal');\n    }\n    // key packet\n    if (this.keyPacket.constructor.tag === enums.packet.publicSubkey &&\n        subkey.keyPacket.constructor.tag === enums.packet.secretSubkey) {\n      this.keyPacket = subkey.keyPacket;\n    }\n    // update missing binding signatures\n    const that = this;\n    const dataToVerify = { key: primaryKey, bind: that.keyPacket };\n    await helper.mergeSignatures(subkey, this, 'bindingSignatures', date, async function(srcBindSig) {\n      for (let i = 0; i < that.bindingSignatures.length; i++) {\n        if (that.bindingSignatures[i].issuerKeyID.equals(srcBindSig.issuerKeyID)) {\n          if (srcBindSig.created > that.bindingSignatures[i].created) {\n            that.bindingSignatures[i] = srcBindSig;\n          }\n          return false;\n        }\n      }\n      try {\n        await srcBindSig.verify(primaryKey, enums.signature.subkeyBinding, dataToVerify, date, undefined, config);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n    // revocation signatures\n    await helper.mergeSignatures(subkey, this, 'revocationSignatures', date, function(srcRevSig) {\n      return helper.isDataRevoked(primaryKey, enums.signature.subkeyRevocation, dataToVerify, [srcRevSig], undefined, undefined, date, config);\n    });\n  }\n\n  /**\n   * Revokes the subkey\n   * @param {SecretKeyPacket} primaryKey - decrypted private primary key for revocation\n   * @param {Object} reasonForRevocation - optional, object indicating the reason for revocation\n   * @param  {module:enums.reasonForRevocation} reasonForRevocation.flag optional, flag indicating the reason for revocation\n   * @param  {String} reasonForRevocation.string optional, string explaining the reason for revocation\n   * @param {Date} date - optional, override the creationtime of the revocation signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Subkey>} New subkey with revocation signature.\n   * @async\n   */\n  async revoke(\n    primaryKey,\n    {\n      flag: reasonForRevocationFlag = enums.reasonForRevocation.noReason,\n      string: reasonForRevocationString = ''\n    } = {},\n    date = new Date(),\n    config = defaultConfig\n  ) {\n    const dataToSign = { key: primaryKey, bind: this.keyPacket };\n    const subkey = new Subkey(this.keyPacket, this.mainKey);\n    subkey.revocationSignatures.push(await helper.createSignaturePacket(dataToSign, [], primaryKey, {\n      signatureType: enums.signature.subkeyRevocation,\n      reasonForRevocationFlag: enums.write(enums.reasonForRevocation, reasonForRevocationFlag),\n      reasonForRevocationString\n    }, date, undefined, undefined, false, config));\n    await subkey.update(this);\n    return subkey;\n  }\n\n  hasSameFingerprintAs(other) {\n    return this.keyPacket.hasSameFingerprintAs(other.keyPacket || other);\n  }\n}\n\n['getKeyID', 'getFingerprint', 'getAlgorithmInfo', 'getCreationTime', 'isDecrypted'].forEach(name => {\n  Subkey.prototype[name] =\n    function() {\n      return this.keyPacket[name]();\n    };\n});\n\nexport default Subkey;\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor, unarmor } from '../encoding/armor';\nimport {\n  PacketList,\n  SignaturePacket\n} from '../packet';\nimport defaultConfig from '../config';\nimport enums from '../enums';\nimport util from '../util';\nimport User from './user';\nimport Subkey from './subkey';\nimport * as helper from './helper';\nimport { UnparseablePacket } from '../packet/packet';\n\n// A key revocation certificate can contain the following packets\nconst allowedRevocationPackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\nconst mainKeyPacketTags = new Set([enums.packet.publicKey, enums.packet.privateKey]);\nconst keyPacketTags = new Set([\n  enums.packet.publicKey, enums.packet.privateKey,\n  enums.packet.publicSubkey, enums.packet.privateSubkey\n]);\n\n/**\n * Abstract class that represents an OpenPGP key. Must contain a primary key.\n * Can contain additional subkeys, signatures, user ids, user attributes.\n * @borrows PublicKeyPacket#getKeyID as Key#getKeyID\n * @borrows PublicKeyPacket#getFingerprint as Key#getFingerprint\n * @borrows PublicKeyPacket#hasSameFingerprintAs as Key#hasSameFingerprintAs\n * @borrows PublicKeyPacket#getAlgorithmInfo as Key#getAlgorithmInfo\n * @borrows PublicKeyPacket#getCreationTime as Key#getCreationTime\n */\nclass Key {\n  /**\n   * Transforms packetlist to structured key data\n   * @param {PacketList} packetlist - The packets that form a key\n   * @param {Set<enums.packet>} disallowedPackets - disallowed packet tags\n   */\n  packetListToStructure(packetlist, disallowedPackets = new Set()) {\n    let user;\n    let primaryKeyID;\n    let subkey;\n    let ignoreUntil;\n\n    for (const packet of packetlist) {\n\n      if (packet instanceof UnparseablePacket) {\n        const isUnparseableKeyPacket = keyPacketTags.has(packet.tag);\n        if (isUnparseableKeyPacket && !ignoreUntil) {\n          // Since non-key packets apply to the preceding key packet, if a (sub)key is Unparseable we must\n          // discard all non-key packets that follow, until another (sub)key packet is found.\n          if (mainKeyPacketTags.has(packet.tag)) {\n            ignoreUntil = mainKeyPacketTags;\n          } else {\n            ignoreUntil = keyPacketTags;\n          }\n        }\n        continue;\n      }\n\n      const tag = packet.constructor.tag;\n      if (ignoreUntil) {\n        if (!ignoreUntil.has(tag)) continue;\n        ignoreUntil = null;\n      }\n      if (disallowedPackets.has(tag)) {\n        throw new Error(`Unexpected packet type: ${tag}`);\n      }\n      switch (tag) {\n        case enums.packet.publicKey:\n        case enums.packet.secretKey:\n          if (this.keyPacket) {\n            throw new Error('Key block contains multiple keys');\n          }\n          this.keyPacket = packet;\n          primaryKeyID = this.getKeyID();\n          if (!primaryKeyID) {\n            throw new Error('Missing Key ID');\n          }\n          break;\n        case enums.packet.userID:\n        case enums.packet.userAttribute:\n          user = new User(packet, this);\n          this.users.push(user);\n          break;\n        case enums.packet.publicSubkey:\n        case enums.packet.secretSubkey:\n          user = null;\n          subkey = new Subkey(packet, this);\n          this.subkeys.push(subkey);\n          break;\n        case enums.packet.signature:\n          switch (packet.signatureType) {\n            case enums.signature.certGeneric:\n            case enums.signature.certPersona:\n            case enums.signature.certCasual:\n            case enums.signature.certPositive:\n              if (!user) {\n                util.printDebug('Dropping certification signatures without preceding user packet');\n                continue;\n              }\n              if (packet.issuerKeyID.equals(primaryKeyID)) {\n                user.selfCertifications.push(packet);\n              } else {\n                user.otherCertifications.push(packet);\n              }\n              break;\n            case enums.signature.certRevocation:\n              if (user) {\n                user.revocationSignatures.push(packet);\n              } else {\n                this.directSignatures.push(packet);\n              }\n              break;\n            case enums.signature.key:\n              this.directSignatures.push(packet);\n              break;\n            case enums.signature.subkeyBinding:\n              if (!subkey) {\n                util.printDebug('Dropping subkey binding signature without preceding subkey packet');\n                continue;\n              }\n              subkey.bindingSignatures.push(packet);\n              break;\n            case enums.signature.keyRevocation:\n              this.revocationSignatures.push(packet);\n              break;\n            case enums.signature.subkeyRevocation:\n              if (!subkey) {\n                util.printDebug('Dropping subkey revocation signature without preceding subkey packet');\n                continue;\n              }\n              subkey.revocationSignatures.push(packet);\n              break;\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Transforms structured key data to packetlist\n   * @returns {PacketList} The packets that form a key.\n   */\n  toPacketList() {\n    const packetlist = new PacketList();\n    packetlist.push(this.keyPacket);\n    packetlist.push(...this.revocationSignatures);\n    packetlist.push(...this.directSignatures);\n    this.users.map(user => packetlist.push(...user.toPacketList()));\n    this.subkeys.map(subkey => packetlist.push(...subkey.toPacketList()));\n    return packetlist;\n  }\n\n  /**\n   * Clones the key object. The copy is shallow, as it references the same packet objects as the original. However, if the top-level API is used, the two key instances are effectively independent.\n   * @param {Boolean} [clonePrivateParams=false] Only relevant for private keys: whether the secret key paramenters should be deeply copied. This is needed if e.g. `encrypt()` is to be called either on the clone or the original key.\n   * @returns {Promise<Key>} Clone of the key.\n   */\n  clone(clonePrivateParams = false) {\n    const key = new this.constructor(this.toPacketList());\n    if (clonePrivateParams) {\n      key.getKeys().forEach(k => {\n        // shallow clone the key packets\n        k.keyPacket = Object.create(\n          Object.getPrototypeOf(k.keyPacket),\n          Object.getOwnPropertyDescriptors(k.keyPacket)\n        );\n        if (!k.keyPacket.isDecrypted()) return;\n        // deep clone the private params, which are cleared during encryption\n        const privateParams = {};\n        Object.keys(k.keyPacket.privateParams).forEach(name => {\n          privateParams[name] = new Uint8Array(k.keyPacket.privateParams[name]);\n        });\n        k.keyPacket.privateParams = privateParams;\n      });\n    }\n    return key;\n  }\n\n  /**\n   * Returns an array containing all public or private subkeys matching keyID;\n   * If no keyID is given, returns all subkeys.\n   * @param {type/keyID} [keyID] - key ID to look for\n   * @returns {Array<Subkey>} array of subkeys\n   */\n  getSubkeys(keyID = null) {\n    const subkeys = this.subkeys.filter(subkey => (\n      !keyID || subkey.getKeyID().equals(keyID, true)\n    ));\n    return subkeys;\n  }\n\n  /**\n   * Returns an array containing all public or private keys matching keyID.\n   * If no keyID is given, returns all keys, starting with the primary key.\n   * @param {type/keyid~KeyID} [keyID] - key ID to look for\n   * @returns {Array<Key|Subkey>} array of keys\n   */\n  getKeys(keyID = null) {\n    const keys = [];\n    if (!keyID || this.getKeyID().equals(keyID, true)) {\n      keys.push(this);\n    }\n    return keys.concat(this.getSubkeys(keyID));\n  }\n\n  /**\n   * Returns key IDs of all keys\n   * @returns {Array<module:type/keyid~KeyID>}\n   */\n  getKeyIDs() {\n    return this.getKeys().map(key => key.getKeyID());\n  }\n\n  /**\n   * Returns userIDs\n   * @returns {Array<string>} Array of userIDs.\n   */\n  getUserIDs() {\n    return this.users.map(user => {\n      return user.userID ? user.userID.userID : null;\n    }).filter(userID => userID !== null);\n  }\n\n  /**\n   * Returns binary encoded key\n   * @returns {Uint8Array} Binary key.\n   */\n  write() {\n    return this.toPacketList().write();\n  }\n\n  /**\n   * Returns last created key or key by given keyID that is available for signing and verification\n   * @param  {module:type/keyid~KeyID} [keyID] - key ID of a specific key to retrieve\n   * @param  {Date} [date] - use the fiven date date to  to check key validity instead of the current date\n   * @param  {Object} [userID] - filter keys for the given user ID\n   * @param  {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key|Subkey>} signing key\n   * @throws if no valid signing key was found\n   * @async\n   */\n  async getSigningKey(keyID = null, date = new Date(), userID = {}, config = defaultConfig) {\n    await this.verifyPrimaryKey(date, userID, config);\n    const primaryKey = this.keyPacket;\n    try {\n      helper.checkKeyRequirements(primaryKey, config);\n    } catch (err) {\n      throw util.wrapError('Could not verify primary key', err);\n    }\n    // Prefer the most recently created valid subkey, or the subkey with\n    // the highest algorithm ID in case of equal creation timestamps.\n    const subkeys = this.subkeys.slice().sort((a, b) => (\n      b.keyPacket.created - a.keyPacket.created ||\n      b.keyPacket.algorithm - a.keyPacket.algorithm\n    ));\n    let exception;\n    for (const subkey of subkeys) {\n      if (!keyID || subkey.getKeyID().equals(keyID)) {\n        try {\n          await subkey.verify(date, config);\n          const dataToVerify = { key: primaryKey, bind: subkey.keyPacket };\n          const bindingSignature = await helper.getLatestValidSignature(\n            subkey.bindingSignatures, primaryKey, enums.signature.subkeyBinding, dataToVerify, date, config\n          );\n          if (!helper.validateSigningKeyPacket(subkey.keyPacket, bindingSignature, config)) {\n            continue;\n          }\n          if (!bindingSignature.embeddedSignature) {\n            throw new Error('Missing embedded signature');\n          }\n          // verify embedded signature\n          await helper.getLatestValidSignature(\n            [bindingSignature.embeddedSignature], subkey.keyPacket, enums.signature.keyBinding, dataToVerify, date, config\n          );\n          helper.checkKeyRequirements(subkey.keyPacket, config);\n          return subkey;\n        } catch (e) {\n          exception = e;\n        }\n      }\n    }\n\n    try {\n      const selfCertification = await this.getPrimarySelfSignature(date, userID, config);\n      if ((!keyID || primaryKey.getKeyID().equals(keyID)) &&\n          helper.validateSigningKeyPacket(primaryKey, selfCertification, config)) {\n        helper.checkKeyRequirements(primaryKey, config);\n        return this;\n      }\n    } catch (e) {\n      exception = e;\n    }\n    throw util.wrapError('Could not find valid signing key packet in key ' + this.getKeyID().toHex(), exception);\n  }\n\n  /**\n   * Returns last created key or key by given keyID that is available for encryption or decryption\n   * @param  {module:type/keyid~KeyID} [keyID] - key ID of a specific key to retrieve\n   * @param  {Date}   [date] - use the fiven date date to  to check key validity instead of the current date\n   * @param  {Object} [userID] - filter keys for the given user ID\n   * @param  {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key|Subkey>} encryption key\n   * @throws if no valid encryption key was found\n   * @async\n   */\n  async getEncryptionKey(keyID, date = new Date(), userID = {}, config = defaultConfig) {\n    await this.verifyPrimaryKey(date, userID, config);\n    const primaryKey = this.keyPacket;\n    try {\n      helper.checkKeyRequirements(primaryKey, config);\n    } catch (err) {\n      throw util.wrapError('Could not verify primary key', err);\n    }\n    // Prefer the most recently created valid subkey, or the subkey with\n    // the highest algorithm ID in case of equal creation timestamps.\n    const subkeys = this.subkeys.slice().sort((a, b) => (\n      b.keyPacket.created - a.keyPacket.created ||\n      b.keyPacket.algorithm - a.keyPacket.algorithm\n    ));\n    let exception;\n    for (const subkey of subkeys) {\n      if (!keyID || subkey.getKeyID().equals(keyID)) {\n        try {\n          await subkey.verify(date, config);\n          const dataToVerify = { key: primaryKey, bind: subkey.keyPacket };\n          const bindingSignature = await helper.getLatestValidSignature(subkey.bindingSignatures, primaryKey, enums.signature.subkeyBinding, dataToVerify, date, config);\n          if (helper.validateEncryptionKeyPacket(subkey.keyPacket, bindingSignature, config)) {\n            helper.checkKeyRequirements(subkey.keyPacket, config);\n            return subkey;\n          }\n        } catch (e) {\n          exception = e;\n        }\n      }\n    }\n\n    try {\n      // if no valid subkey for encryption, evaluate primary key\n      const selfCertification = await this.getPrimarySelfSignature(date, userID, config);\n      if ((!keyID || primaryKey.getKeyID().equals(keyID)) &&\n          helper.validateEncryptionKeyPacket(primaryKey, selfCertification, config)) {\n        helper.checkKeyRequirements(primaryKey, config);\n        return this;\n      }\n    } catch (e) {\n      exception = e;\n    }\n    throw util.wrapError('Could not find valid encryption key packet in key ' + this.getKeyID().toHex(), exception);\n  }\n\n  /**\n   * Checks if a signature on a key is revoked\n   * @param {SignaturePacket} signature - The signature to verify\n   * @param  {PublicSubkeyPacket|\n   *          SecretSubkeyPacket|\n   *          PublicKeyPacket|\n   *          SecretKeyPacket} key, optional The key to verify the signature\n   * @param {Date} [date] - Use the given date for verification, instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Boolean>} True if the certificate is revoked.\n   * @async\n   */\n  async isRevoked(signature, key, date = new Date(), config = defaultConfig) {\n    return helper.isDataRevoked(\n      this.keyPacket, enums.signature.keyRevocation, { key: this.keyPacket }, this.revocationSignatures, signature, key, date, config\n    );\n  }\n\n  /**\n   * Verify primary key. Checks for revocation signatures, expiration time\n   * and valid self signature. Throws if the primary key is invalid.\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [userID] - User ID\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} If key verification failed\n   * @async\n   */\n  async verifyPrimaryKey(date = new Date(), userID = {}, config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    // check for key revocation signatures\n    if (await this.isRevoked(null, null, date, config)) {\n      throw new Error('Primary key is revoked');\n    }\n    // check for valid, unrevoked, unexpired self signature\n    const selfCertification = await this.getPrimarySelfSignature(date, userID, config);\n    // check for expiration time in binding signatures\n    if (helper.isDataExpired(primaryKey, selfCertification, date)) {\n      throw new Error('Primary key is expired');\n    }\n    if (primaryKey.version !== 6) {\n      // check for expiration time in direct signatures (for V6 keys, the above already did so)\n      const directSignature = await helper.getLatestValidSignature(\n        this.directSignatures, primaryKey, enums.signature.key, { key: primaryKey }, date, config\n      ).catch(() => {}); // invalid signatures are discarded, to avoid breaking the key\n\n      if (directSignature && helper.isDataExpired(primaryKey, directSignature, date)) {\n        throw new Error('Primary key is expired');\n      }\n    }\n  }\n\n  /**\n   * Returns the expiration date of the primary key, considering self-certifications and direct-key signatures.\n   * Returns `Infinity` if the key doesn't expire, or `null` if the key is revoked or invalid.\n   * @param  {Object} [userID] - User ID to consider instead of the primary user\n   * @param  {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Date | Infinity | null>}\n   * @async\n   */\n  async getExpirationTime(userID, config = defaultConfig) {\n    let primaryKeyExpiry;\n    try {\n      const selfCertification = await this.getPrimarySelfSignature(null, userID, config);\n      const selfSigKeyExpiry = helper.getKeyExpirationTime(this.keyPacket, selfCertification);\n      const selfSigExpiry = selfCertification.getExpirationTime();\n      const directSignature = this.keyPacket.version !== 6 && // For V6 keys, the above already returns the direct-key signature.\n        await helper.getLatestValidSignature(\n          this.directSignatures, this.keyPacket, enums.signature.key, { key: this.keyPacket }, null, config\n        ).catch(() => {});\n      if (directSignature) {\n        const directSigKeyExpiry = helper.getKeyExpirationTime(this.keyPacket, directSignature);\n        // We do not support the edge case where the direct signature expires, since it would invalidate the corresponding key expiration,\n        // causing a discountinous validy period for the key\n        primaryKeyExpiry = Math.min(selfSigKeyExpiry, selfSigExpiry, directSigKeyExpiry);\n      } else {\n        primaryKeyExpiry = selfSigKeyExpiry < selfSigExpiry ? selfSigKeyExpiry : selfSigExpiry;\n      }\n    } catch (e) {\n      primaryKeyExpiry = null;\n    }\n\n    return util.normalizeDate(primaryKeyExpiry);\n  }\n\n\n  /**\n   * For V4 keys, returns the self-signature of the primary user.\n   * For V5 keys, returns the latest valid direct-key self-signature.\n   * This self-signature is to be used to check the key expiration,\n   * algorithm preferences, and so on.\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [userID] - User ID to get instead of the primary user for V4 keys, if it exists\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<SignaturePacket>} The primary self-signature\n   * @async\n   */\n  async getPrimarySelfSignature(date = new Date(), userID = {}, config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    if (primaryKey.version === 6) {\n      return helper.getLatestValidSignature(\n        this.directSignatures, primaryKey, enums.signature.key, { key: primaryKey }, date, config\n      );\n    }\n    const { selfCertification } = await this.getPrimaryUser(date, userID, config);\n    return selfCertification;\n  }\n\n  /**\n   * Returns primary user and most significant (latest valid) self signature\n   * - if multiple primary users exist, returns the one with the latest self signature\n   * - otherwise, returns the user with the latest self signature\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [userID] - User ID to get instead of the primary user, if it exists\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<{\n   *   user: User,\n   *   selfCertification: SignaturePacket\n   * }>} The primary user and the self signature\n   * @async\n   */\n  async getPrimaryUser(date = new Date(), userID = {}, config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    const users = [];\n    let exception;\n    for (let i = 0; i < this.users.length; i++) {\n      try {\n        const user = this.users[i];\n        if (!user.userID) {\n          continue;\n        }\n        if (\n          (userID.name !== undefined && user.userID.name !== userID.name) ||\n          (userID.email !== undefined && user.userID.email !== userID.email) ||\n          (userID.comment !== undefined && user.userID.comment !== userID.comment)\n        ) {\n          throw new Error('Could not find user that matches that user ID');\n        }\n        const dataToVerify = { userID: user.userID, key: primaryKey };\n        const selfCertification = await helper.getLatestValidSignature(user.selfCertifications, primaryKey, enums.signature.certGeneric, dataToVerify, date, config);\n        users.push({ index: i, user, selfCertification });\n      } catch (e) {\n        exception = e;\n      }\n    }\n    if (!users.length) {\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw exception || new Error('Could not find primary user');\n    }\n    await Promise.all(users.map(async function (a) {\n      return a.selfCertification.revoked || a.user.isRevoked(a.selfCertification, null, date, config);\n    }));\n    // sort by primary user flag and signature creation time\n    const primaryUser = users.sort(function(a, b) {\n      const A = a.selfCertification;\n      const B = b.selfCertification;\n      return B.revoked - A.revoked || A.isPrimaryUserID - B.isPrimaryUserID || A.created - B.created;\n    }).pop();\n    const { user, selfCertification: cert } = primaryUser;\n    if (cert.revoked || await user.isRevoked(cert, null, date, config)) {\n      throw new Error('Primary user is revoked');\n    }\n    return primaryUser;\n  }\n\n  /**\n   * Update key with new components from specified key with same key ID:\n   * users, subkeys, certificates are merged into the destination key,\n   * duplicates and expired signatures are ignored.\n   *\n   * If the source key is a private key and the destination key is public,\n   * a private key is returned.\n   * @param {Key} sourceKey - Source key to merge\n   * @param {Date} [date] - Date to verify validity of signatures and keys\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key>} updated key\n   * @async\n   */\n  async update(sourceKey, date = new Date(), config = defaultConfig) {\n    if (!this.hasSameFingerprintAs(sourceKey)) {\n      throw new Error('Primary key fingerprints must be equal to update the key');\n    }\n    if (!this.isPrivate() && sourceKey.isPrivate()) {\n      // check for equal subkey packets\n      const equal = (this.subkeys.length === sourceKey.subkeys.length) &&\n            (this.subkeys.every(destSubkey => {\n              return sourceKey.subkeys.some(srcSubkey => {\n                return destSubkey.hasSameFingerprintAs(srcSubkey);\n              });\n            }));\n      if (!equal) {\n        throw new Error('Cannot update public key with private key if subkeys mismatch');\n      }\n\n      return sourceKey.update(this, config);\n    }\n    // from here on, either:\n    // - destination key is private, source key is public\n    // - the keys are of the same type\n    // hence we don't need to convert the destination key type\n    const updatedKey = this.clone();\n    // revocation signatures\n    await helper.mergeSignatures(sourceKey, updatedKey, 'revocationSignatures', date, srcRevSig => {\n      return helper.isDataRevoked(updatedKey.keyPacket, enums.signature.keyRevocation, updatedKey, [srcRevSig], null, sourceKey.keyPacket, date, config);\n    });\n    // direct signatures\n    await helper.mergeSignatures(sourceKey, updatedKey, 'directSignatures', date);\n    // update users\n    await Promise.all(sourceKey.users.map(async srcUser => {\n      // multiple users with the same ID/attribute are not explicitly disallowed by the spec\n      // hence we support them, just in case\n      const usersToUpdate = updatedKey.users.filter(dstUser => (\n        (srcUser.userID && srcUser.userID.equals(dstUser.userID)) ||\n        (srcUser.userAttribute && srcUser.userAttribute.equals(dstUser.userAttribute))\n      ));\n      if (usersToUpdate.length > 0) {\n        await Promise.all(\n          usersToUpdate.map(userToUpdate => userToUpdate.update(srcUser, date, config))\n        );\n      } else {\n        const newUser = srcUser.clone();\n        newUser.mainKey = updatedKey;\n        updatedKey.users.push(newUser);\n      }\n    }));\n    // update subkeys\n    await Promise.all(sourceKey.subkeys.map(async srcSubkey => {\n      // multiple subkeys with same fingerprint might be preset\n      const subkeysToUpdate = updatedKey.subkeys.filter(dstSubkey => (\n        dstSubkey.hasSameFingerprintAs(srcSubkey)\n      ));\n      if (subkeysToUpdate.length > 0) {\n        await Promise.all(\n          subkeysToUpdate.map(subkeyToUpdate => subkeyToUpdate.update(srcSubkey, date, config))\n        );\n      } else {\n        const newSubkey = srcSubkey.clone();\n        newSubkey.mainKey = updatedKey;\n        updatedKey.subkeys.push(newSubkey);\n      }\n    }));\n\n    return updatedKey;\n  }\n\n  /**\n   * Get revocation certificate from a revoked key.\n   *   (To get a revocation certificate for an unrevoked key, call revoke() first.)\n   * @param {Date} date - Use the given date instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<String>} Armored revocation certificate.\n   * @async\n   */\n  async getRevocationCertificate(date = new Date(), config = defaultConfig) {\n    const dataToVerify = { key: this.keyPacket };\n    const revocationSignature = await helper.getLatestValidSignature(this.revocationSignatures, this.keyPacket, enums.signature.keyRevocation, dataToVerify, date, config);\n    const packetlist = new PacketList();\n    packetlist.push(revocationSignature);\n    // An ASCII-armored Transferable Public Key packet sequence of a v6 key MUST NOT contain a CRC24 footer.\n    const emitChecksum = this.keyPacket.version !== 6;\n    return armor(enums.armor.publicKey, packetlist.write(), null, null, 'This is a revocation certificate', emitChecksum, config);\n  }\n\n  /**\n   * Applies a revocation certificate to a key\n   * This adds the first signature packet in the armored text to the key,\n   * if it is a valid revocation signature.\n   * @param {String} revocationCertificate - armored revocation certificate\n   * @param {Date} [date] - Date to verify the certificate\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key>} Revoked key.\n   * @async\n   */\n  async applyRevocationCertificate(revocationCertificate, date = new Date(), config = defaultConfig) {\n    const input = await unarmor(revocationCertificate, config);\n    const packetlist = await PacketList.fromBinary(input.data, allowedRevocationPackets, config);\n    const revocationSignature = packetlist.findPacket(enums.packet.signature);\n    if (!revocationSignature || revocationSignature.signatureType !== enums.signature.keyRevocation) {\n      throw new Error('Could not find revocation signature packet');\n    }\n    if (!revocationSignature.issuerKeyID.equals(this.getKeyID())) {\n      throw new Error('Revocation signature does not match key');\n    }\n    try {\n      await revocationSignature.verify(this.keyPacket, enums.signature.keyRevocation, { key: this.keyPacket }, date, undefined, config);\n    } catch (e) {\n      throw util.wrapError('Could not verify revocation signature', e);\n    }\n    const key = this.clone();\n    key.revocationSignatures.push(revocationSignature);\n    return key;\n  }\n\n  /**\n   * Signs primary user of key\n   * @param {Array<PrivateKey>} privateKeys - decrypted private keys for signing\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [userID] - User ID to get instead of the primary user, if it exists\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key>} Key with new certificate signature.\n   * @async\n   */\n  async signPrimaryUser(privateKeys, date, userID, config = defaultConfig) {\n    const { index, user } = await this.getPrimaryUser(date, userID, config);\n    const userSign = await user.certify(privateKeys, date, config);\n    const key = this.clone();\n    key.users[index] = userSign;\n    return key;\n  }\n\n  /**\n   * Signs all users of key\n   * @param {Array<PrivateKey>} privateKeys - decrypted private keys for signing\n   * @param {Date} [date] - Use the given date for signing, instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Key>} Key with new certificate signature.\n   * @async\n   */\n  async signAllUsers(privateKeys, date = new Date(), config = defaultConfig) {\n    const key = this.clone();\n    key.users = await Promise.all(this.users.map(function(user) {\n      return user.certify(privateKeys, date, config);\n    }));\n    return key;\n  }\n\n  /**\n   * Verifies primary user of key\n   * - if no arguments are given, verifies the self certificates;\n   * - otherwise, verifies all certificates signed with given keys.\n   * @param {Array<PublicKey>} [verificationKeys] - array of keys to verify certificate signatures, instead of the primary key\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [userID] - User ID to get instead of the primary user, if it exists\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   valid: Boolean|null\n   * }>>} List of signer's keyID and validity of signature.\n   *      Signature validity is null if the verification keys do not correspond to the certificate.\n   * @async\n   */\n  async verifyPrimaryUser(verificationKeys, date = new Date(), userID, config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    const { user } = await this.getPrimaryUser(date, userID, config);\n    const results = verificationKeys ?\n      await user.verifyAllCertifications(verificationKeys, date, config) :\n      [{ keyID: primaryKey.getKeyID(), valid: await user.verify(date, config).catch(() => false) }];\n    return results;\n  }\n\n  /**\n   * Verifies all users of key\n   * - if no arguments are given, verifies the self certificates;\n   * - otherwise, verifies all certificates signed with given keys.\n   * @param {Array<PublicKey>} [verificationKeys] - array of keys to verify certificate signatures\n   * @param {Date} [date] - Use the given date for verification instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   userID: String,\n   *   keyID: module:type/keyid~KeyID,\n   *   valid: Boolean|null\n   * }>>} List of userID, signer's keyID and validity of signature.\n   *      Signature validity is null if the verification keys do not correspond to the certificate.\n   * @async\n   */\n  async verifyAllUsers(verificationKeys, date = new Date(), config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    const results = [];\n    await Promise.all(this.users.map(async user => {\n      const signatures = verificationKeys ?\n        await user.verifyAllCertifications(verificationKeys, date, config) :\n        [{ keyID: primaryKey.getKeyID(), valid: await user.verify(date, config).catch(() => false) }];\n\n      results.push(...signatures.map(\n        signature => ({\n          userID: user.userID ? user.userID.userID : null,\n          userAttribute: user.userAttribute,\n          keyID: signature.keyID,\n          valid: signature.valid\n        }))\n      );\n    }));\n    return results;\n  }\n}\n\n['getKeyID', 'getFingerprint', 'getAlgorithmInfo', 'getCreationTime', 'hasSameFingerprintAs'].forEach(name => {\n  Key.prototype[name] =\n  Subkey.prototype[name];\n});\n\nexport default Key;\n","// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor } from '../encoding/armor';\nimport defaultConfig from '../config';\nimport enums from '../enums';\nimport Key from './key';\n\n/**\n * Class that represents an OpenPGP Public Key\n */\nclass PublicKey extends Key {\n  /**\n   * @param {PacketList} packetlist - The packets that form this key\n   */\n  constructor(packetlist) {\n    super();\n    this.keyPacket = null;\n    this.revocationSignatures = [];\n    this.directSignatures = [];\n    this.users = [];\n    this.subkeys = [];\n    if (packetlist) {\n      this.packetListToStructure(packetlist, new Set([enums.packet.secretKey, enums.packet.secretSubkey]));\n      if (!this.keyPacket) {\n        throw new Error('Invalid key: missing public-key packet');\n      }\n    }\n  }\n\n  /**\n   * Returns true if this is a private key\n   * @returns {false}\n   */\n  isPrivate() {\n    return false;\n  }\n\n  /**\n   * Returns key as public key (shallow copy)\n   * @returns {PublicKey} New public Key\n   */\n  toPublic() {\n    return this;\n  }\n\n  /**\n   * Returns ASCII armored text of key\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    // An ASCII-armored Transferable Public Key packet sequence of a v6 key MUST NOT contain a CRC24 footer.\n    const emitChecksum = this.keyPacket.version !== 6;\n    return armor(enums.armor.publicKey, this.toPacketList().write(), undefined, undefined, undefined, emitChecksum, config);\n  }\n}\n\nexport default PublicKey;\n\n","import PublicKey from './public_key';\nimport { armor } from '../encoding/armor';\nimport {\n  PacketList,\n  PublicKeyPacket,\n  PublicSubkeyPacket\n} from '../packet';\nimport defaultConfig from '../config';\nimport enums from '../enums';\nimport * as helper from './helper';\n\n/**\n * Class that represents an OpenPGP Private key\n */\nclass PrivateKey extends PublicKey {\n  /**\n * @param {PacketList} packetlist - The packets that form this key\n */\n  constructor(packetlist) {\n    super();\n    this.packetListToStructure(packetlist, new Set([enums.packet.publicKey, enums.packet.publicSubkey]));\n    if (!this.keyPacket) {\n      throw new Error('Invalid key: missing private-key packet');\n    }\n  }\n\n  /**\n   * Returns true if this is a private key\n   * @returns {Boolean}\n   */\n  isPrivate() {\n    return true;\n  }\n\n  /**\n   * Returns key as public key (shallow copy)\n   * @returns {PublicKey} New public Key\n   */\n  toPublic() {\n    const packetlist = new PacketList();\n    const keyPackets = this.toPacketList();\n    for (const keyPacket of keyPackets) {\n      switch (keyPacket.constructor.tag) {\n        case enums.packet.secretKey: {\n          const pubKeyPacket = PublicKeyPacket.fromSecretKeyPacket(keyPacket);\n          packetlist.push(pubKeyPacket);\n          break;\n        }\n        case enums.packet.secretSubkey: {\n          const pubSubkeyPacket = PublicSubkeyPacket.fromSecretSubkeyPacket(keyPacket);\n          packetlist.push(pubSubkeyPacket);\n          break;\n        }\n        default:\n          packetlist.push(keyPacket);\n      }\n    }\n    return new PublicKey(packetlist);\n  }\n\n  /**\n   * Returns ASCII armored text of key\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    // An ASCII-armored Transferable Public Key packet sequence of a v6 key MUST NOT contain a CRC24 footer.\n    const emitChecksum = this.keyPacket.version !== 6;\n    return armor(enums.armor.privateKey, this.toPacketList().write(), undefined, undefined, undefined, emitChecksum, config);\n  }\n\n  /**\n   * Returns all keys that are available for decryption, matching the keyID when given\n   * This is useful to retrieve keys for session key decryption\n   * @param  {module:type/keyid~KeyID} keyID, optional\n   * @param  {Date}              date, optional\n   * @param  {String}            userID, optional\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<Key|Subkey>>} Array of decryption keys.\n   * @throws {Error} if no decryption key is found\n   * @async\n   */\n  async getDecryptionKeys(keyID, date = new Date(), userID = {}, config = defaultConfig) {\n    const primaryKey = this.keyPacket;\n    const keys = [];\n    let exception = null;\n    for (let i = 0; i < this.subkeys.length; i++) {\n      if (!keyID || this.subkeys[i].getKeyID().equals(keyID, true)) {\n        if (this.subkeys[i].keyPacket.isDummy()) {\n          exception = exception || new Error('Gnu-dummy key packets cannot be used for decryption');\n          continue;\n        }\n\n        try {\n          const dataToVerify = { key: primaryKey, bind: this.subkeys[i].keyPacket };\n          const bindingSignature = await helper.getLatestValidSignature(this.subkeys[i].bindingSignatures, primaryKey, enums.signature.subkeyBinding, dataToVerify, date, config);\n          if (helper.validateDecryptionKeyPacket(this.subkeys[i].keyPacket, bindingSignature, config)) {\n            keys.push(this.subkeys[i]);\n          }\n        } catch (e) {\n          exception = e;\n        }\n      }\n    }\n\n    // evaluate primary key\n    const selfCertification = await this.getPrimarySelfSignature(date, userID, config);\n    if ((!keyID || primaryKey.getKeyID().equals(keyID, true)) && helper.validateDecryptionKeyPacket(primaryKey, selfCertification, config)) {\n      if (primaryKey.isDummy()) {\n        exception = exception || new Error('Gnu-dummy key packets cannot be used for decryption');\n      } else {\n        keys.push(this);\n      }\n    }\n\n    if (keys.length === 0) {\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw exception || new Error('No decryption key packets found');\n    }\n\n    return keys;\n  }\n\n  /**\n   * Returns true if the primary key or any subkey is decrypted.\n   * A dummy key is considered encrypted.\n   */\n  isDecrypted() {\n    return this.getKeys().some(({ keyPacket }) => keyPacket.isDecrypted());\n  }\n\n  /**\n   * Check whether the private and public primary key parameters correspond\n   * Together with verification of binding signatures, this guarantees key integrity\n   * In case of gnu-dummy primary key, it is enough to validate any signing subkeys\n   *   otherwise all encryption subkeys are validated\n   * If only gnu-dummy keys are found, we cannot properly validate so we throw an error\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @throws {Error} if validation was not successful and the key cannot be trusted\n   * @async\n   */\n  async validate(config = defaultConfig) {\n    if (!this.isPrivate()) {\n      throw new Error('Cannot validate a public key');\n    }\n\n    let signingKeyPacket;\n    if (!this.keyPacket.isDummy()) {\n      signingKeyPacket = this.keyPacket;\n    } else {\n      /**\n       * It is enough to validate any signing keys\n       * since its binding signatures are also checked\n       */\n      const signingKey = await this.getSigningKey(null, null, undefined, { ...config, rejectPublicKeyAlgorithms: new Set(), minRSABits: 0 });\n      // This could again be a dummy key\n      if (signingKey && !signingKey.keyPacket.isDummy()) {\n        signingKeyPacket = signingKey.keyPacket;\n      }\n    }\n\n    if (signingKeyPacket) {\n      return signingKeyPacket.validate();\n    } else {\n      const keys = this.getKeys();\n      const allDummies = keys.map(key => key.keyPacket.isDummy()).every(Boolean);\n      if (allDummies) {\n        throw new Error('Cannot validate an all-gnu-dummy key');\n      }\n\n      return Promise.all(keys.map(async key => key.keyPacket.validate()));\n    }\n  }\n\n  /**\n   * Clear private key parameters\n   */\n  clearPrivateParams() {\n    this.getKeys().forEach(({ keyPacket }) => {\n      if (keyPacket.isDecrypted()) {\n        keyPacket.clearPrivateParams();\n      }\n    });\n  }\n\n  /**\n   * Revokes the key\n   * @param {Object} reasonForRevocation - optional, object indicating the reason for revocation\n   * @param  {module:enums.reasonForRevocation} reasonForRevocation.flag optional, flag indicating the reason for revocation\n   * @param  {String} reasonForRevocation.string optional, string explaining the reason for revocation\n   * @param {Date} date - optional, override the creationtime of the revocation signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<PrivateKey>} New key with revocation signature.\n   * @async\n   */\n  async revoke(\n    {\n      flag: reasonForRevocationFlag = enums.reasonForRevocation.noReason,\n      string: reasonForRevocationString = ''\n    } = {},\n    date = new Date(),\n    config = defaultConfig\n  ) {\n    if (!this.isPrivate()) {\n      throw new Error('Need private key for revoking');\n    }\n    const dataToSign = { key: this.keyPacket };\n    const key = this.clone();\n    key.revocationSignatures.push(await helper.createSignaturePacket(dataToSign, [], this.keyPacket, {\n      signatureType: enums.signature.keyRevocation,\n      reasonForRevocationFlag: enums.write(enums.reasonForRevocation, reasonForRevocationFlag),\n      reasonForRevocationString\n    }, date, undefined, undefined, undefined, config));\n    return key;\n  }\n\n\n  /**\n   * Generates a new OpenPGP subkey, and returns a clone of the Key object with the new subkey added.\n   * Supports RSA and ECC keys, as well as the newer Curve448 and Curve25519.\n   * Defaults to the algorithm and bit size/curve of the primary key. DSA primary keys default to RSA subkeys.\n   * @param {ecc|rsa|curve25519|curve448} options.type The subkey algorithm: ECC, RSA, Curve448 or Curve25519 (new format).\n   *                                                   Note: Curve448 and Curve25519 are not widely supported yet.\n   * @param {String}  options.curve      (optional) Elliptic curve for ECC keys\n   * @param {Integer} options.rsaBits    (optional) Number of bits for RSA subkeys\n   * @param {Number}  options.keyExpirationTime (optional) Number of seconds from the key creation time after which the key expires\n   * @param {Date}    options.date       (optional) Override the creation date of the key and the key signatures\n   * @param {Boolean} options.sign       (optional) Indicates whether the subkey should sign rather than encrypt. Defaults to false\n   * @param {Object}  options.config     (optional) custom configuration settings to overwrite those in [config]{@link module:config}\n   * @returns {Promise<PrivateKey>}\n   * @async\n   */\n  async addSubkey(options = {}) {\n    const config = { ...defaultConfig, ...options.config };\n    if (options.passphrase) {\n      throw new Error('Subkey could not be encrypted here, please encrypt whole key');\n    }\n    if (options.rsaBits < config.minRSABits) {\n      throw new Error(`rsaBits should be at least ${config.minRSABits}, got: ${options.rsaBits}`);\n    }\n    const secretKeyPacket = this.keyPacket;\n    if (secretKeyPacket.isDummy()) {\n      throw new Error('Cannot add subkey to gnu-dummy primary key');\n    }\n    if (!secretKeyPacket.isDecrypted()) {\n      throw new Error('Key is not decrypted');\n    }\n    const defaultOptions = secretKeyPacket.getAlgorithmInfo();\n    defaultOptions.type = getDefaultSubkeyType(defaultOptions.algorithm);\n    defaultOptions.rsaBits = defaultOptions.bits || 4096;\n    defaultOptions.curve = defaultOptions.curve || 'curve25519Legacy';\n    options = helper.sanitizeKeyOptions(options, defaultOptions);\n    // Every subkey for a v4 primary key MUST be a v4 subkey.\n    // Every subkey for a v6 primary key MUST be a v6 subkey.\n    // For v5 keys, since we dropped generation support, a v4 subkey is added.\n    // The config is always overwritten since we cannot tell if the defaultConfig was changed by the user.\n    const keyPacket = await helper.generateSecretSubkey(options, { ...config, v6Keys: this.keyPacket.version === 6 });\n    helper.checkKeyRequirements(keyPacket, config);\n    const bindingSignature = await helper.createBindingSignature(keyPacket, secretKeyPacket, options, config);\n    const packetList = this.toPacketList();\n    packetList.push(keyPacket, bindingSignature);\n    return new PrivateKey(packetList);\n  }\n}\n\nfunction getDefaultSubkeyType(algoName) {\n  const algo = enums.write(enums.publicKey, algoName);\n  // NB: no encryption-only algos, since they cannot be in primary keys\n  switch (algo) {\n    case enums.publicKey.rsaEncrypt:\n    case enums.publicKey.rsaEncryptSign:\n    case enums.publicKey.rsaSign:\n    case enums.publicKey.dsa:\n      return 'rsa';\n    case enums.publicKey.ecdsa:\n    case enums.publicKey.eddsaLegacy:\n      return 'ecc';\n    case enums.publicKey.ed25519:\n      return 'curve25519';\n    case enums.publicKey.ed448:\n      return 'curve448';\n    default:\n      throw new Error('Unsupported algorithm');\n  }\n}\n\nexport default PrivateKey;\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2015-2016 Decentral\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport {\n  PacketList,\n  UserIDPacket,\n  SignaturePacket,\n  PublicKeyPacket,\n  PublicSubkeyPacket,\n  SecretKeyPacket,\n  SecretSubkeyPacket,\n  UserAttributePacket\n} from '../packet';\nimport PrivateKey from './private_key';\nimport PublicKey from './public_key';\nimport * as helper from './helper';\nimport enums from '../enums';\nimport util from '../util';\nimport defaultConfig from '../config';\nimport { unarmor } from '../encoding/armor';\n\n// A Key can contain the following packets\nconst allowedKeyPackets = /*#__PURE__*/ util.constructAllowedPackets([\n  PublicKeyPacket,\n  PublicSubkeyPacket,\n  SecretKeyPacket,\n  SecretSubkeyPacket,\n  UserIDPacket,\n  UserAttributePacket,\n  SignaturePacket\n]);\n\n/**\n * Creates a PublicKey or PrivateKey depending on the packetlist in input\n * @param {PacketList} - packets to parse\n * @return {Key} parsed key\n * @throws if no key packet was found\n */\nfunction createKey(packetlist) {\n  for (const packet of packetlist) {\n    switch (packet.constructor.tag) {\n      case enums.packet.secretKey:\n        return new PrivateKey(packetlist);\n      case enums.packet.publicKey:\n        return new PublicKey(packetlist);\n    }\n  }\n  throw new Error('No key packet found');\n}\n\n\n/**\n * Generates a new OpenPGP key. Supports RSA and ECC keys, as well as the newer Curve448 and Curve25519 keys.\n * By default, primary and subkeys will be of same type.\n * @param {ecc|rsa|curve448|curve25519} options.type                  The primary key algorithm type: ECC, RSA, Curve448 or Curve25519 (new format).\n * @param {String}  options.curve                 Elliptic curve for ECC keys\n * @param {Integer} options.rsaBits               Number of bits for RSA keys\n * @param {Array<String|Object>} options.userIDs  User IDs as strings or objects: 'Jo Doe <info@jo.com>' or { name:'Jo Doe', email:'info@jo.com' }\n * @param {String}  options.passphrase            Passphrase used to encrypt the resulting private key\n * @param {Number}  options.keyExpirationTime     (optional) Number of seconds from the key creation time after which the key expires\n * @param {Date}    options.date                  Creation date of the key and the key signatures\n * @param {Object} config - Full configuration\n * @param {Array<Object>} options.subkeys         (optional) options for each subkey, default to main key options. e.g. [{sign: true, passphrase: '123'}]\n *                                                  sign parameter defaults to false, and indicates whether the subkey should sign rather than encrypt\n * @returns {Promise<{{ key: PrivateKey, revocationCertificate: String }}>}\n * @async\n * @static\n * @private\n */\nexport async function generate(options, config) {\n  options.sign = true; // primary key is always a signing key\n  options = helper.sanitizeKeyOptions(options);\n  options.subkeys = options.subkeys.map((subkey, index) => helper.sanitizeKeyOptions(options.subkeys[index], options));\n  let promises = [helper.generateSecretKey(options, config)];\n  promises = promises.concat(options.subkeys.map(options => helper.generateSecretSubkey(options, config)));\n  const packets = await Promise.all(promises);\n\n  const key = await wrapKeyObject(packets[0], packets.slice(1), options, config);\n  const revocationCertificate = await key.getRevocationCertificate(options.date, config);\n  key.revocationSignatures = [];\n  return { key, revocationCertificate };\n}\n\n/**\n * Reformats and signs an OpenPGP key with a given User ID. Currently only supports RSA keys.\n * @param {PrivateKey} options.privateKey         The private key to reformat\n * @param {Array<String|Object>} options.userIDs  User IDs as strings or objects: 'Jo Doe <info@jo.com>' or { name:'Jo Doe', email:'info@jo.com' }\n * @param {String} options.passphrase             Passphrase used to encrypt the resulting private key\n * @param {Number} options.keyExpirationTime      Number of seconds from the key creation time after which the key expires\n * @param {Date}   options.date                   Override the creation date of the key signatures\n * @param {Array<Object>} options.subkeys         (optional) options for each subkey, default to main key options. e.g. [{sign: true, passphrase: '123'}]\n * @param {Object} config - Full configuration\n *\n * @returns {Promise<{{ key: PrivateKey, revocationCertificate: String }}>}\n * @async\n * @static\n * @private\n */\nexport async function reformat(options, config) {\n  options = sanitize(options);\n  const { privateKey } = options;\n\n  if (!privateKey.isPrivate()) {\n    throw new Error('Cannot reformat a public key');\n  }\n\n  if (privateKey.keyPacket.isDummy()) {\n    throw new Error('Cannot reformat a gnu-dummy primary key');\n  }\n\n  const isDecrypted = privateKey.getKeys().every(({ keyPacket }) => keyPacket.isDecrypted());\n  if (!isDecrypted) {\n    throw new Error('Key is not decrypted');\n  }\n\n  const secretKeyPacket = privateKey.keyPacket;\n\n  if (!options.subkeys) {\n    options.subkeys = await Promise.all(privateKey.subkeys.map(async subkey => {\n      const secretSubkeyPacket = subkey.keyPacket;\n      const dataToVerify = { key: secretKeyPacket, bind: secretSubkeyPacket };\n      const bindingSignature = await (\n        helper.getLatestValidSignature(subkey.bindingSignatures, secretKeyPacket, enums.signature.subkeyBinding, dataToVerify, null, config)\n      ).catch(() => ({}));\n      return {\n        sign: bindingSignature.keyFlags && (bindingSignature.keyFlags[0] & enums.keyFlags.signData)\n      };\n    }));\n  }\n\n  const secretSubkeyPackets = privateKey.subkeys.map(subkey => subkey.keyPacket);\n  if (options.subkeys.length !== secretSubkeyPackets.length) {\n    throw new Error('Number of subkey options does not match number of subkeys');\n  }\n\n  options.subkeys = options.subkeys.map(subkeyOptions => sanitize(subkeyOptions, options));\n\n  const key = await wrapKeyObject(secretKeyPacket, secretSubkeyPackets, options, config);\n  const revocationCertificate = await key.getRevocationCertificate(options.date, config);\n  key.revocationSignatures = [];\n  return { key, revocationCertificate };\n\n  function sanitize(options, subkeyDefaults = {}) {\n    options.keyExpirationTime = options.keyExpirationTime || subkeyDefaults.keyExpirationTime;\n    options.passphrase = util.isString(options.passphrase) ? options.passphrase : subkeyDefaults.passphrase;\n    options.date = options.date || subkeyDefaults.date;\n\n    return options;\n  }\n}\n\n/**\n * Construct PrivateKey object from the given key packets, add certification signatures and set passphrase protection\n * The new key includes a revocation certificate that must be removed before returning the key, otherwise the key is considered revoked.\n * @param {SecretKeyPacket} secretKeyPacket\n * @param {SecretSubkeyPacket} secretSubkeyPackets\n * @param {Object} options\n * @param {Object} config - Full configuration\n * @returns {PrivateKey}\n */\nasync function wrapKeyObject(secretKeyPacket, secretSubkeyPackets, options, config) {\n  // set passphrase protection\n  if (options.passphrase) {\n    await secretKeyPacket.encrypt(options.passphrase, config);\n  }\n\n  await Promise.all(secretSubkeyPackets.map(async function(secretSubkeyPacket, index) {\n    const subkeyPassphrase = options.subkeys[index].passphrase;\n    if (subkeyPassphrase) {\n      await secretSubkeyPacket.encrypt(subkeyPassphrase, config);\n    }\n  }));\n\n  const packetlist = new PacketList();\n  packetlist.push(secretKeyPacket);\n\n  function createPreferredAlgos(algos, preferredAlgo) {\n    return [preferredAlgo, ...algos.filter(algo => algo !== preferredAlgo)];\n  }\n\n  function getKeySignatureProperties() {\n    const signatureProperties = {};\n    signatureProperties.keyFlags = [enums.keyFlags.certifyKeys | enums.keyFlags.signData];\n    const symmetricAlgorithms = createPreferredAlgos([\n      // prefer aes256, aes128, no aes192 (no Web Crypto support in Chrome: https://www.chromium.org/blink/webcrypto#TOC-AES-support)\n      enums.symmetric.aes256,\n      enums.symmetric.aes128\n    ], config.preferredSymmetricAlgorithm);\n    signatureProperties.preferredSymmetricAlgorithms = symmetricAlgorithms;\n    if (config.aeadProtect) {\n      const aeadAlgorithms = createPreferredAlgos([\n        enums.aead.gcm,\n        enums.aead.eax,\n        enums.aead.ocb\n      ], config.preferredAEADAlgorithm);\n      signatureProperties.preferredCipherSuites = aeadAlgorithms.flatMap(aeadAlgorithm => {\n        return symmetricAlgorithms.map(symmetricAlgorithm => {\n          return [symmetricAlgorithm, aeadAlgorithm];\n        });\n      });\n    }\n    signatureProperties.preferredHashAlgorithms = createPreferredAlgos([\n      enums.hash.sha512,\n      enums.hash.sha256,\n      enums.hash.sha3_512,\n      enums.hash.sha3_256\n    ], config.preferredHashAlgorithm);\n    signatureProperties.preferredCompressionAlgorithms = createPreferredAlgos([\n      enums.compression.uncompressed,\n      enums.compression.zlib,\n      enums.compression.zip\n    ], config.preferredCompressionAlgorithm);\n    // integrity protection always enabled\n    signatureProperties.features = [0];\n    signatureProperties.features[0] |= enums.features.modificationDetection;\n    if (config.aeadProtect) {\n      signatureProperties.features[0] |= enums.features.seipdv2;\n    }\n    if (options.keyExpirationTime > 0) {\n      signatureProperties.keyExpirationTime = options.keyExpirationTime;\n      signatureProperties.keyNeverExpires = false;\n    }\n    return signatureProperties;\n  }\n\n  if (secretKeyPacket.version === 6) { // add direct key signature with key prefs\n    const dataToSign = {\n      key: secretKeyPacket\n    };\n\n    const signatureProperties = getKeySignatureProperties();\n    signatureProperties.signatureType = enums.signature.key;\n\n    const signaturePacket = await helper.createSignaturePacket(dataToSign, [], secretKeyPacket, signatureProperties, options.date, undefined, undefined, undefined, config);\n    packetlist.push(signaturePacket);\n  }\n\n  await Promise.all(options.userIDs.map(async function(userID, index) {\n    const userIDPacket = UserIDPacket.fromObject(userID);\n    const dataToSign = {\n      userID: userIDPacket,\n      key: secretKeyPacket\n    };\n    const signatureProperties = secretKeyPacket.version !== 6 ? getKeySignatureProperties() : {};\n    signatureProperties.signatureType = enums.signature.certPositive;\n    if (index === 0) {\n      signatureProperties.isPrimaryUserID = true;\n    }\n\n    const signaturePacket = await helper.createSignaturePacket(dataToSign, [], secretKeyPacket, signatureProperties, options.date, undefined, undefined, undefined, config);\n\n    return { userIDPacket, signaturePacket };\n  })).then(list => {\n    list.forEach(({ userIDPacket, signaturePacket }) => {\n      packetlist.push(userIDPacket);\n      packetlist.push(signaturePacket);\n    });\n  });\n\n  await Promise.all(secretSubkeyPackets.map(async function(secretSubkeyPacket, index) {\n    const subkeyOptions = options.subkeys[index];\n    const subkeySignaturePacket = await helper.createBindingSignature(secretSubkeyPacket, secretKeyPacket, subkeyOptions, config);\n    return { secretSubkeyPacket, subkeySignaturePacket };\n  })).then(packets => {\n    packets.forEach(({ secretSubkeyPacket, subkeySignaturePacket }) => {\n      packetlist.push(secretSubkeyPacket);\n      packetlist.push(subkeySignaturePacket);\n    });\n  });\n\n  // Add revocation signature packet for creating a revocation certificate.\n  // This packet should be removed before returning the key.\n  const dataToSign = { key: secretKeyPacket };\n  packetlist.push(await helper.createSignaturePacket(dataToSign, [], secretKeyPacket, {\n    signatureType: enums.signature.keyRevocation,\n    reasonForRevocationFlag: enums.reasonForRevocation.noReason,\n    reasonForRevocationString: ''\n  }, options.date, undefined, undefined, undefined, config));\n\n  if (options.passphrase) {\n    secretKeyPacket.clearPrivateParams();\n  }\n\n  await Promise.all(secretSubkeyPackets.map(async function(secretSubkeyPacket, index) {\n    const subkeyPassphrase = options.subkeys[index].passphrase;\n    if (subkeyPassphrase) {\n      secretSubkeyPacket.clearPrivateParams();\n    }\n  }));\n\n  return new PrivateKey(packetlist);\n}\n\n/**\n * Reads an (optionally armored) OpenPGP key and returns a key object\n * @param {Object} options\n * @param {String} [options.armoredKey] - Armored key to be parsed\n * @param {Uint8Array} [options.binaryKey] - Binary key to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Key>} Key object.\n * @async\n * @static\n */\nexport async function readKey({ armoredKey, binaryKey, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  if (!armoredKey && !binaryKey) {\n    throw new Error('readKey: must pass options object containing `armoredKey` or `binaryKey`');\n  }\n  if (armoredKey && !util.isString(armoredKey)) {\n    throw new Error('readKey: options.armoredKey must be a string');\n  }\n  if (binaryKey && !util.isUint8Array(binaryKey)) {\n    throw new Error('readKey: options.binaryKey must be a Uint8Array');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  let input;\n  if (armoredKey) {\n    const { type, data } = await unarmor(armoredKey, config);\n    if (!(type === enums.armor.publicKey || type === enums.armor.privateKey)) {\n      throw new Error('Armored text not of type key');\n    }\n    input = data;\n  } else {\n    input = binaryKey;\n  }\n  const packetlist = await PacketList.fromBinary(input, allowedKeyPackets, config);\n  const keyIndex = packetlist.indexOfTag(enums.packet.publicKey, enums.packet.secretKey);\n  if (keyIndex.length === 0) {\n    throw new Error('No key packet found');\n  }\n  const firstKeyPacketList = packetlist.slice(keyIndex[0], keyIndex[1]);\n  return createKey(firstKeyPacketList);\n}\n\n/**\n * Reads an (optionally armored) OpenPGP private key and returns a PrivateKey object\n * @param {Object} options\n * @param {String} [options.armoredKey] - Armored key to be parsed\n * @param {Uint8Array} [options.binaryKey] - Binary key to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<PrivateKey>} Key object.\n * @async\n * @static\n */\nexport async function readPrivateKey({ armoredKey, binaryKey, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  if (!armoredKey && !binaryKey) {\n    throw new Error('readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`');\n  }\n  if (armoredKey && !util.isString(armoredKey)) {\n    throw new Error('readPrivateKey: options.armoredKey must be a string');\n  }\n  if (binaryKey && !util.isUint8Array(binaryKey)) {\n    throw new Error('readPrivateKey: options.binaryKey must be a Uint8Array');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  let input;\n  if (armoredKey) {\n    const { type, data } = await unarmor(armoredKey, config);\n    if (!(type === enums.armor.privateKey)) {\n      throw new Error('Armored text not of type private key');\n    }\n    input = data;\n  } else {\n    input = binaryKey;\n  }\n  const packetlist = await PacketList.fromBinary(input, allowedKeyPackets, config);\n  const keyIndex = packetlist.indexOfTag(enums.packet.publicKey, enums.packet.secretKey);\n  for (let i = 0; i < keyIndex.length; i++) {\n    if (packetlist[keyIndex[i]].constructor.tag === enums.packet.publicKey) {\n      continue;\n    }\n    const firstPrivateKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);\n    return new PrivateKey(firstPrivateKeyList);\n  }\n  throw new Error('No secret key packet found');\n}\n\n/**\n * Reads an (optionally armored) OpenPGP key block and returns a list of key objects\n * @param {Object} options\n * @param {String} [options.armoredKeys] - Armored keys to be parsed\n * @param {Uint8Array} [options.binaryKeys] - Binary keys to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Array<Key>>} Key objects.\n * @async\n * @static\n */\nexport async function readKeys({ armoredKeys, binaryKeys, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  let input = armoredKeys || binaryKeys;\n  if (!input) {\n    throw new Error('readKeys: must pass options object containing `armoredKeys` or `binaryKeys`');\n  }\n  if (armoredKeys && !util.isString(armoredKeys)) {\n    throw new Error('readKeys: options.armoredKeys must be a string');\n  }\n  if (binaryKeys && !util.isUint8Array(binaryKeys)) {\n    throw new Error('readKeys: options.binaryKeys must be a Uint8Array');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (armoredKeys) {\n    const { type, data } = await unarmor(armoredKeys, config);\n    if (type !== enums.armor.publicKey && type !== enums.armor.privateKey) {\n      throw new Error('Armored text not of type key');\n    }\n    input = data;\n  }\n  const keys = [];\n  const packetlist = await PacketList.fromBinary(input, allowedKeyPackets, config);\n  const keyIndex = packetlist.indexOfTag(enums.packet.publicKey, enums.packet.secretKey);\n  if (keyIndex.length === 0) {\n    throw new Error('No key packet found');\n  }\n  for (let i = 0; i < keyIndex.length; i++) {\n    const oneKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);\n    const newKey = createKey(oneKeyList);\n    keys.push(newKey);\n  }\n  return keys;\n}\n\n/**\n * Reads an (optionally armored) OpenPGP private key block and returns a list of PrivateKey objects\n * @param {Object} options\n * @param {String} [options.armoredKeys] - Armored keys to be parsed\n * @param {Uint8Array} [options.binaryKeys] - Binary keys to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Array<PrivateKey>>} Key objects.\n * @async\n * @static\n */\nexport async function readPrivateKeys({ armoredKeys, binaryKeys, config }) {\n  config = { ...defaultConfig, ...config };\n  let input = armoredKeys || binaryKeys;\n  if (!input) {\n    throw new Error('readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`');\n  }\n  if (armoredKeys && !util.isString(armoredKeys)) {\n    throw new Error('readPrivateKeys: options.armoredKeys must be a string');\n  }\n  if (binaryKeys && !util.isUint8Array(binaryKeys)) {\n    throw new Error('readPrivateKeys: options.binaryKeys must be a Uint8Array');\n  }\n  if (armoredKeys) {\n    const { type, data } = await unarmor(armoredKeys, config);\n    if (type !== enums.armor.privateKey) {\n      throw new Error('Armored text not of type private key');\n    }\n    input = data;\n  }\n  const keys = [];\n  const packetlist = await PacketList.fromBinary(input, allowedKeyPackets, config);\n  const keyIndex = packetlist.indexOfTag(enums.packet.publicKey, enums.packet.secretKey);\n  for (let i = 0; i < keyIndex.length; i++) {\n    if (packetlist[keyIndex[i]].constructor.tag === enums.packet.publicKey) {\n      continue;\n    }\n    const oneKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);\n    const newKey = new PrivateKey(oneKeyList);\n    keys.push(newKey);\n  }\n  if (keys.length === 0) {\n    throw new Error('No secret key packet found');\n  }\n  return keys;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { isArrayStream, cancel as streamCancel, readToEnd as streamReadToEnd, fromAsync as streamFromAsync, transformPair as streamTransformPair, getWriter as streamGetWriter, getReader as streamGetReader } from '@openpgp/web-stream-tools';\nimport { armor, unarmor } from './encoding/armor';\nimport { Argon2OutOfMemoryError } from './type/s2k';\nimport defaultConfig from './config';\nimport { generateSessionKey } from './crypto';\nimport enums from './enums';\nimport util from './util';\nimport { Signature } from './signature';\nimport { getPreferredCipherSuite, createSignaturePacket } from './key';\nimport {\n  PacketList,\n  LiteralDataPacket,\n  CompressedDataPacket,\n  AEADEncryptedDataPacket,\n  SymEncryptedIntegrityProtectedDataPacket,\n  SymmetricallyEncryptedDataPacket,\n  PublicKeyEncryptedSessionKeyPacket,\n  SymEncryptedSessionKeyPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n} from './packet';\nimport { MessageGrammarValidator } from './packet/grammar';\n\n// A Message can contain the following packets\nconst allowedMessagePackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  CompressedDataPacket,\n  AEADEncryptedDataPacket,\n  SymEncryptedIntegrityProtectedDataPacket,\n  SymmetricallyEncryptedDataPacket,\n  PublicKeyEncryptedSessionKeyPacket,\n  SymEncryptedSessionKeyPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n// A SKESK packet can contain the following packets\nconst allowedSymSessionKeyPackets = /*#__PURE__*/ util.constructAllowedPackets([SymEncryptedSessionKeyPacket]);\n// A detached signature can contain the following packets\nconst allowedDetachedSignaturePackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP message.\n * Can be an encrypted message, signed message, compressed message or literal message\n * See {@link https://tools.ietf.org/html/rfc4880#section-11.3}\n */\nexport class Message {\n  /**\n   * @param {PacketList} packetlist - The packets that form this message\n   */\n  constructor(packetlist) {\n    this.packets = packetlist || new PacketList();\n  }\n\n  /**\n   * Returns the key IDs of the keys to which the session key is encrypted\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getEncryptionKeyIDs() {\n    const keyIDs = [];\n    const pkESKeyPacketlist = this.packets.filterByTag(enums.packet.publicKeyEncryptedSessionKey);\n    pkESKeyPacketlist.forEach(function(packet) {\n      keyIDs.push(packet.publicKeyID);\n    });\n    return keyIDs;\n  }\n\n  /**\n   * Returns the key IDs of the keys that signed the message\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getSigningKeyIDs() {\n    const msg = this.unwrapCompressed();\n    // search for one pass signatures\n    const onePassSigList = msg.packets.filterByTag(enums.packet.onePassSignature);\n    if (onePassSigList.length > 0) {\n      return onePassSigList.map(packet => packet.issuerKeyID);\n    }\n    // if nothing found look for signature packets\n    const signatureList = msg.packets.filterByTag(enums.packet.signature);\n    return signatureList.map(packet => packet.issuerKeyID);\n  }\n\n  /**\n   * Decrypt the message. Either a private key, a session key, or a password must be specified.\n   * @param {Array<PrivateKey>} [decryptionKeys] - Private keys with decrypted secret data\n   * @param {Array<String>} [passwords] - Passwords used to decrypt\n   * @param {Array<Object>} [sessionKeys] - Session keys in the form: { data:Uint8Array, algorithm:String, [aeadAlgorithm:String] }\n   * @param {Date} [date] - Use the given date for key verification instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with decrypted content.\n   * @async\n   */\n  async decrypt(decryptionKeys, passwords, sessionKeys, date = new Date(), config = defaultConfig) {\n    const symEncryptedPacketlist = this.packets.filterByTag(\n      enums.packet.symmetricallyEncryptedData,\n      enums.packet.symEncryptedIntegrityProtectedData,\n      enums.packet.aeadEncryptedData\n    );\n\n    if (symEncryptedPacketlist.length === 0) {\n      throw new Error('No encrypted data found');\n    }\n\n    const symEncryptedPacket = symEncryptedPacketlist[0];\n    const expectedSymmetricAlgorithm = symEncryptedPacket.cipherAlgorithm;\n\n    const sessionKeyObjects = sessionKeys || await this.decryptSessionKeys(decryptionKeys, passwords, expectedSymmetricAlgorithm, date, config);\n\n    let exception = null;\n    const decryptedPromise = Promise.all(sessionKeyObjects.map(async ({ algorithm: algorithmName, data }) => {\n      if (!util.isUint8Array(data) || (!symEncryptedPacket.cipherAlgorithm && !util.isString(algorithmName))) {\n        throw new Error('Invalid session key for decryption.');\n      }\n\n      try {\n        const algo = symEncryptedPacket.cipherAlgorithm || enums.write(enums.symmetric, algorithmName);\n        await symEncryptedPacket.decrypt(algo, data, config);\n      } catch (e) {\n        util.printDebugError(e);\n        exception = e;\n      }\n    }));\n    // We don't await stream.cancel here because it only returns when the other copy is canceled too.\n    streamCancel(symEncryptedPacket.encrypted); // Don't keep copy of encrypted data in memory.\n    symEncryptedPacket.encrypted = null;\n    await decryptedPromise;\n\n    if (!symEncryptedPacket.packets || !symEncryptedPacket.packets.length) {\n      throw exception || new Error('Decryption failed.');\n    }\n\n    const resultMsg = new Message(symEncryptedPacket.packets);\n    symEncryptedPacket.packets = new PacketList(); // remove packets after decryption\n\n    return resultMsg;\n  }\n\n  /**\n   * Decrypt encrypted session keys either with private keys or passwords.\n   * @param {Array<PrivateKey>} [decryptionKeys] - Private keys with decrypted secret data\n   * @param {Array<String>} [passwords] - Passwords used to decrypt\n   * @param {enums.symmetric} [expectedSymmetricAlgorithm] - The symmetric algorithm the SEIPDv2 / AEAD packet is encrypted with (if applicable)\n   * @param {Date} [date] - Use the given date for key verification, instead of current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   data: Uint8Array,\n   *   algorithm: String\n   * }>>} array of object with potential sessionKey, algorithm pairs\n   * @async\n   */\n  async decryptSessionKeys(decryptionKeys, passwords, expectedSymmetricAlgorithm, date = new Date(), config = defaultConfig) {\n    let decryptedSessionKeyPackets = [];\n\n    let exception;\n    if (passwords) {\n      const skeskPackets = this.packets.filterByTag(enums.packet.symEncryptedSessionKey);\n      if (skeskPackets.length === 0) {\n        throw new Error('No symmetrically encrypted session key packet found.');\n      }\n      await Promise.all(passwords.map(async function(password, i) {\n        let packets;\n        if (i) {\n          packets = await PacketList.fromBinary(skeskPackets.write(), allowedSymSessionKeyPackets, config);\n        } else {\n          packets = skeskPackets;\n        }\n        await Promise.all(packets.map(async function(skeskPacket) {\n          try {\n            await skeskPacket.decrypt(password);\n            decryptedSessionKeyPackets.push(skeskPacket);\n          } catch (err) {\n            util.printDebugError(err);\n            if (err instanceof Argon2OutOfMemoryError) {\n              exception = err;\n            }\n          }\n        }));\n      }));\n    } else if (decryptionKeys) {\n      const pkeskPackets = this.packets.filterByTag(enums.packet.publicKeyEncryptedSessionKey);\n      if (pkeskPackets.length === 0) {\n        throw new Error('No public key encrypted session key packet found.');\n      }\n      await Promise.all(pkeskPackets.map(async function(pkeskPacket) {\n        await Promise.all(decryptionKeys.map(async function(decryptionKey) {\n          let decryptionKeyPackets;\n          try {\n            // do not check key expiration to allow decryption of old messages\n            decryptionKeyPackets = (await decryptionKey.getDecryptionKeys(pkeskPacket.publicKeyID, null, undefined, config)).map(key => key.keyPacket);\n          } catch (err) {\n            exception = err;\n            return;\n          }\n\n          let algos = [\n            enums.symmetric.aes256, // Old OpenPGP.js default fallback\n            enums.symmetric.aes128, // RFC4880bis fallback\n            enums.symmetric.tripledes, // RFC4880 fallback\n            enums.symmetric.cast5 // Golang OpenPGP fallback\n          ];\n          try {\n            const selfCertification = await decryptionKey.getPrimarySelfSignature(date, undefined, config); // TODO: Pass userID from somewhere.\n            if (selfCertification.preferredSymmetricAlgorithms) {\n              algos = algos.concat(selfCertification.preferredSymmetricAlgorithms);\n            }\n          } catch (e) {}\n\n          await Promise.all(decryptionKeyPackets.map(async function(decryptionKeyPacket) {\n            if (!decryptionKeyPacket.isDecrypted()) {\n              throw new Error('Decryption key is not decrypted.');\n            }\n\n            // To hinder CCA attacks against PKCS1, we carry out a constant-time decryption flow if the `constantTimePKCS1Decryption` config option is set.\n            const doConstantTimeDecryption = config.constantTimePKCS1Decryption && (\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaEncrypt ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaEncryptSign ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaSign ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.elgamal\n            );\n\n            if (doConstantTimeDecryption) {\n              // The goal is to not reveal whether PKESK decryption (specifically the PKCS1 decoding step) failed, hence, we always proceed to decrypt the message,\n              // either with the successfully decrypted session key, or with a randomly generated one.\n              // Since the SEIP/AEAD's symmetric algorithm and key size are stored in the encrypted portion of the PKESK, and the execution flow cannot depend on\n              // the decrypted payload, we always assume the message to be encrypted with one of the symmetric algorithms specified in `config.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms`:\n              // - If the PKESK decryption succeeds, and the session key cipher is in the supported set, then we try to decrypt the data with the decrypted session key as well as with the\n              // randomly generated keys of the remaining key types.\n              // - If the PKESK decryptions fails, or if it succeeds but support for the cipher is not enabled, then we discard the session key and try to decrypt the data using only the randomly\n              // generated session keys.\n              // NB: as a result, if the data is encrypted with a non-suported cipher, decryption will always fail.\n\n              const serialisedPKESK = pkeskPacket.write(); // make copies to be able to decrypt the PKESK packet multiple times\n              await Promise.all((\n                expectedSymmetricAlgorithm ?\n                  [expectedSymmetricAlgorithm] :\n                  Array.from(config.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)\n              ).map(async sessionKeyAlgorithm => {\n                const pkeskPacketCopy = new PublicKeyEncryptedSessionKeyPacket();\n                pkeskPacketCopy.read(serialisedPKESK);\n                const randomSessionKey = {\n                  sessionKeyAlgorithm,\n                  sessionKey: generateSessionKey(sessionKeyAlgorithm)\n                };\n                try {\n                  await pkeskPacketCopy.decrypt(decryptionKeyPacket, randomSessionKey);\n                  decryptedSessionKeyPackets.push(pkeskPacketCopy);\n                } catch (err) {\n                  // `decrypt` can still throw some non-security-sensitive errors\n                  util.printDebugError(err);\n                  exception = err;\n                }\n              }));\n\n            } else {\n              try {\n                await pkeskPacket.decrypt(decryptionKeyPacket);\n                const symmetricAlgorithm = expectedSymmetricAlgorithm || pkeskPacket.sessionKeyAlgorithm;\n                if (symmetricAlgorithm && !algos.includes(enums.write(enums.symmetric, symmetricAlgorithm))) {\n                  throw new Error('A non-preferred symmetric algorithm was used.');\n                }\n                decryptedSessionKeyPackets.push(pkeskPacket);\n              } catch (err) {\n                util.printDebugError(err);\n                exception = err;\n              }\n            }\n          }));\n        }));\n        streamCancel(pkeskPacket.encrypted); // Don't keep copy of encrypted data in memory.\n        pkeskPacket.encrypted = null;\n      }));\n    } else {\n      throw new Error('No key or password specified.');\n    }\n\n    if (decryptedSessionKeyPackets.length > 0) {\n      // Return only unique session keys\n      if (decryptedSessionKeyPackets.length > 1) {\n        const seen = new Set();\n        decryptedSessionKeyPackets = decryptedSessionKeyPackets.filter(item => {\n          const k = item.sessionKeyAlgorithm + util.uint8ArrayToString(item.sessionKey);\n          if (seen.has(k)) {\n            return false;\n          }\n          seen.add(k);\n          return true;\n        });\n      }\n\n      return decryptedSessionKeyPackets.map(packet => ({\n        data: packet.sessionKey,\n        algorithm: packet.sessionKeyAlgorithm && enums.read(enums.symmetric, packet.sessionKeyAlgorithm)\n      }));\n    }\n    throw exception || new Error('Session key decryption failed.');\n  }\n\n  /**\n   * Get literal data that is the body of the message\n   * @returns {(Uint8Array|null)} Literal body of the message as Uint8Array.\n   */\n  getLiteralData() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    return (literal && literal.getBytes()) || null;\n  }\n\n  /**\n   * Get filename from literal data packet\n   * @returns {(String|null)} Filename of literal data packet as string.\n   */\n  getFilename() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    return (literal && literal.getFilename()) || null;\n  }\n\n  /**\n   * Get literal data as text\n   * @returns {(String|null)} Literal body of the message interpreted as text.\n   */\n  getText() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    if (literal) {\n      return literal.getText();\n    }\n    return null;\n  }\n\n  /**\n   * Generate a new session key object, taking the algorithm preferences of the passed encryption keys into account, if any.\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) to select algorithm preferences for\n   * @param {Date} [date] - Date to select algorithm preferences at\n   * @param {Array<Object>} [userIDs] - User IDs to select algorithm preferences for\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<{ data: Uint8Array, algorithm: String, aeadAlgorithm: undefined|String }>} Object with session key data and algorithms.\n   * @async\n   */\n  static async generateSessionKey(encryptionKeys = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    const { symmetricAlgo, aeadAlgo } = await getPreferredCipherSuite(encryptionKeys, date, userIDs, config);\n    const symmetricAlgoName = enums.read(enums.symmetric, symmetricAlgo);\n    const aeadAlgoName = aeadAlgo ? enums.read(enums.aead, aeadAlgo) : undefined;\n\n    await Promise.all(encryptionKeys.map(key => key.getEncryptionKey()\n      .catch(() => null) // ignore key strength requirements\n      .then(maybeKey => {\n        if (maybeKey && (maybeKey.keyPacket.algorithm === enums.publicKey.x25519 || maybeKey.keyPacket.algorithm === enums.publicKey.x448) &&\n          !aeadAlgoName && !util.isAES(symmetricAlgo)) { // if AEAD is defined, then PKESK v6 are used, and the algo info is encrypted\n          throw new Error('Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.');\n        }\n      })\n    ));\n\n    const sessionKeyData = generateSessionKey(symmetricAlgo);\n    return { data: sessionKeyData, algorithm: symmetricAlgoName, aeadAlgorithm: aeadAlgoName };\n  }\n\n  /**\n   * Encrypt the message either with public keys, passwords, or both at once.\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) for message encryption\n   * @param {Array<String>} [passwords] - Password(s) for message encryption\n   * @param {Object} [sessionKey] - Session key in the form: { data:Uint8Array, algorithm:String, [aeadAlgorithm:String] }\n   * @param {Boolean} [wildcard] - Use a key ID of 0 instead of the public key IDs\n   * @param {Array<module:type/keyid~KeyID>} [encryptionKeyIDs] - Array of key IDs to use for encryption. Each encryptionKeyIDs[i] corresponds to keys[i]\n   * @param {Date} [date] - Override the creation date of the literal package\n   * @param {Array<Object>} [userIDs] - User IDs to encrypt for, e.g. [{ name:'Robert Receiver', email:'robert@openpgp.org' }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with encrypted content.\n   * @async\n   */\n  async encrypt(encryptionKeys, passwords, sessionKey, wildcard = false, encryptionKeyIDs = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    if (sessionKey) {\n      if (!util.isUint8Array(sessionKey.data) || !util.isString(sessionKey.algorithm)) {\n        throw new Error('Invalid session key for encryption.');\n      }\n    } else if (encryptionKeys && encryptionKeys.length) {\n      sessionKey = await Message.generateSessionKey(encryptionKeys, date, userIDs, config);\n    } else if (passwords && passwords.length) {\n      sessionKey = await Message.generateSessionKey(undefined, undefined, undefined, config);\n    } else {\n      throw new Error('No keys, passwords, or session key provided.');\n    }\n\n    const { data: sessionKeyData, algorithm: algorithmName, aeadAlgorithm: aeadAlgorithmName } = sessionKey;\n\n    const msg = await Message.encryptSessionKey(sessionKeyData, algorithmName, aeadAlgorithmName, encryptionKeys, passwords, wildcard, encryptionKeyIDs, date, userIDs, config);\n\n    const symEncryptedPacket = SymEncryptedIntegrityProtectedDataPacket.fromObject({\n      version: aeadAlgorithmName ? 2 : 1,\n      aeadAlgorithm: aeadAlgorithmName ? enums.write(enums.aead, aeadAlgorithmName) : null\n    });\n    symEncryptedPacket.packets = this.packets;\n\n    const algorithm = enums.write(enums.symmetric, algorithmName);\n    await symEncryptedPacket.encrypt(algorithm, sessionKeyData, config);\n\n    msg.packets.push(symEncryptedPacket);\n    symEncryptedPacket.packets = new PacketList(); // remove packets after encryption\n    return msg;\n  }\n\n  /**\n   * Encrypt a session key either with public keys, passwords, or both at once.\n   * @param {Uint8Array} sessionKey - session key for encryption\n   * @param {String} algorithmName - session key algorithm\n   * @param {String} [aeadAlgorithmName] - AEAD algorithm, e.g. 'eax' or 'ocb'\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) for message encryption\n   * @param {Array<String>} [passwords] - For message encryption\n   * @param {Boolean} [wildcard] - Use a key ID of 0 instead of the public key IDs\n   * @param {Array<module:type/keyid~KeyID>} [encryptionKeyIDs] - Array of key IDs to use for encryption. Each encryptionKeyIDs[i] corresponds to encryptionKeys[i]\n   * @param {Date} [date] - Override the date\n   * @param {Array} [userIDs] - User IDs to encrypt for, e.g. [{ name:'Robert Receiver', email:'robert@openpgp.org' }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with encrypted content.\n   * @async\n   */\n  static async encryptSessionKey(sessionKey, algorithmName, aeadAlgorithmName, encryptionKeys, passwords, wildcard = false, encryptionKeyIDs = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    const packetlist = new PacketList();\n    const symmetricAlgorithm = enums.write(enums.symmetric, algorithmName);\n    const aeadAlgorithm = aeadAlgorithmName && enums.write(enums.aead, aeadAlgorithmName);\n\n    if (encryptionKeys) {\n      const results = await Promise.all(encryptionKeys.map(async function(primaryKey, i) {\n        const encryptionKey = await primaryKey.getEncryptionKey(encryptionKeyIDs[i], date, userIDs, config);\n\n        const pkESKeyPacket = PublicKeyEncryptedSessionKeyPacket.fromObject({\n          version: aeadAlgorithm ? 6 : 3,\n          encryptionKeyPacket: encryptionKey.keyPacket,\n          anonymousRecipient: wildcard,\n          sessionKey,\n          sessionKeyAlgorithm: symmetricAlgorithm\n        });\n\n        await pkESKeyPacket.encrypt(encryptionKey.keyPacket);\n        delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption\n        return pkESKeyPacket;\n      }));\n      packetlist.push(...results);\n    }\n    if (passwords) {\n      const testDecrypt = async function(keyPacket, password) {\n        try {\n          await keyPacket.decrypt(password);\n          return 1;\n        } catch (e) {\n          return 0;\n        }\n      };\n\n      const sum = (accumulator, currentValue) => accumulator + currentValue;\n\n      const encryptPassword = async function(sessionKey, algorithm, aeadAlgorithm, password) {\n        const symEncryptedSessionKeyPacket = new SymEncryptedSessionKeyPacket(config);\n        symEncryptedSessionKeyPacket.sessionKey = sessionKey;\n        symEncryptedSessionKeyPacket.sessionKeyAlgorithm = algorithm;\n        if (aeadAlgorithm) {\n          symEncryptedSessionKeyPacket.aeadAlgorithm = aeadAlgorithm;\n        }\n        await symEncryptedSessionKeyPacket.encrypt(password, config);\n\n        if (config.passwordCollisionCheck) {\n          const results = await Promise.all(passwords.map(pwd => testDecrypt(symEncryptedSessionKeyPacket, pwd)));\n          if (results.reduce(sum) !== 1) {\n            return encryptPassword(sessionKey, algorithm, password);\n          }\n        }\n\n        delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption\n        return symEncryptedSessionKeyPacket;\n      };\n\n      const results = await Promise.all(passwords.map(pwd => encryptPassword(sessionKey, symmetricAlgorithm, aeadAlgorithm, pwd)));\n      packetlist.push(...results);\n    }\n\n    return new Message(packetlist);\n  }\n\n  /**\n   * Sign the message (the literal data packet of the message)\n   * @param {Array<PrivateKey>} signingKeys - private keys with decrypted secret key data for signing\n   * @param {Array<Key>} recipientKeys - recipient keys to get the signing preferences from\n   * @param {Signature} [signature] - Any existing detached signature to add to the message\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n   * @param {Date} [date] - Override the creation time of the signature\n   * @param {Array<UserID>} [signingUserIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with signed content.\n   * @async\n   */\n  async sign(signingKeys = [], recipientKeys = [], signature = null, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], notations = [], config = defaultConfig) {\n    const packetlist = new PacketList();\n\n    const literalDataPacket = this.packets.findPacket(enums.packet.literalData);\n    if (!literalDataPacket) {\n      throw new Error('No literal data packet to sign.');\n    }\n\n    const signaturePackets = await createSignaturePackets(literalDataPacket, signingKeys, recipientKeys, signature, signingKeyIDs, date, signingUserIDs, recipientUserIDs, notations, false, config); // this returns the existing signature packets as well\n    const onePassSignaturePackets = signaturePackets.map(\n      (signaturePacket, i) => OnePassSignaturePacket.fromSignaturePacket(signaturePacket, i === 0))\n      .reverse(); // innermost OPS refers to the first signature packet\n\n    packetlist.push(...onePassSignaturePackets);\n    packetlist.push(literalDataPacket);\n    packetlist.push(...signaturePackets);\n\n    return new Message(packetlist);\n  }\n\n  /**\n   * Compresses the message (the literal and -if signed- signature data packets of the message)\n   * @param {module:enums.compression} algo - compression algorithm\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Message} New message with compressed content.\n   */\n  compress(algo, config = defaultConfig) {\n    if (algo === enums.compression.uncompressed) {\n      return this;\n    }\n\n    const compressed = new CompressedDataPacket(config);\n    compressed.algorithm = algo;\n    compressed.packets = this.packets;\n\n    const packetList = new PacketList();\n    packetList.push(compressed);\n\n    return new Message(packetList);\n  }\n\n  /**\n   * Create a detached signature for the message (the literal data packet of the message)\n   * @param {Array<PrivateKey>} signingKeys - private keys with decrypted secret key data for signing\n   * @param {Array<Key>} recipientKeys - recipient keys to get the signing preferences from\n   * @param {Signature} [signature] - Any existing detached signature\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n   * @param {Date} [date] - Override the creation time of the signature\n   * @param {Array<UserID>} [signingUserIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Signature>} New detached signature of message content.\n   * @async\n   */\n  async signDetached(signingKeys = [], recipientKeys = [], signature = null, signingKeyIDs = [], recipientKeyIDs = [], date = new Date(), userIDs = [], notations = [], config = defaultConfig) {\n    const literalDataPacket = this.packets.findPacket(enums.packet.literalData);\n    if (!literalDataPacket) {\n      throw new Error('No literal data packet to sign.');\n    }\n    return new Signature(await createSignaturePackets(literalDataPacket, signingKeys, recipientKeys, signature, signingKeyIDs, recipientKeyIDs, date, userIDs, notations, true, config));\n  }\n\n  /**\n   * Verify message signatures\n   * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n   * @param {Date} [date] - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signatures.\n   * @async\n   */\n  async verify(verificationKeys, date = new Date(), config = defaultConfig) {\n    const msg = this.unwrapCompressed();\n    const literalDataList = msg.packets.filterByTag(enums.packet.literalData);\n    if (literalDataList.length !== 1) {\n      throw new Error('Can only verify message with one literal data packet.');\n    }\n    let packets = msg.packets;\n    if (isArrayStream(packets.stream)) {\n      packets = packets.concat(await streamReadToEnd(packets.stream, _ => _ || []));\n    }\n    const onePassSigList = packets.filterByTag(enums.packet.onePassSignature).reverse();\n    const signatureList = packets.filterByTag(enums.packet.signature);\n    if (onePassSigList.length && !signatureList.length && util.isStream(packets.stream) && !isArrayStream(packets.stream)) {\n      await Promise.all(onePassSigList.map(async onePassSig => {\n        onePassSig.correspondingSig = new Promise((resolve, reject) => {\n          onePassSig.correspondingSigResolve = resolve;\n          onePassSig.correspondingSigReject = reject;\n        });\n        onePassSig.signatureData = streamFromAsync(async () => (await onePassSig.correspondingSig).signatureData);\n        onePassSig.hashed = streamReadToEnd(await onePassSig.hash(onePassSig.signatureType, literalDataList[0], undefined, false));\n        onePassSig.hashed.catch(() => {});\n      }));\n      packets.stream = streamTransformPair(packets.stream, async (readable, writable) => {\n        const reader = streamGetReader(readable);\n        const writer = streamGetWriter(writable);\n        try {\n          for (let i = 0; i < onePassSigList.length; i++) {\n            const { value: signature } = await reader.read();\n            onePassSigList[i].correspondingSigResolve(signature);\n          }\n          await reader.readToEnd();\n          await writer.ready;\n          await writer.close();\n        } catch (e) {\n          onePassSigList.forEach(onePassSig => {\n            onePassSig.correspondingSigReject(e);\n          });\n          await writer.abort(e);\n        }\n      });\n      return createVerificationObjects(onePassSigList, literalDataList, verificationKeys, date, false, config);\n    }\n    return createVerificationObjects(signatureList, literalDataList, verificationKeys, date, false, config);\n  }\n\n  /**\n   * Verify detached message signature\n   * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n   * @param {Signature} signature\n   * @param {Date} date - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signature.\n   * @async\n   */\n  verifyDetached(signature, verificationKeys, date = new Date(), config = defaultConfig) {\n    const msg = this.unwrapCompressed();\n    const literalDataList = msg.packets.filterByTag(enums.packet.literalData);\n    if (literalDataList.length !== 1) {\n      throw new Error('Can only verify message with one literal data packet.');\n    }\n    const signatureList = signature.packets.filterByTag(enums.packet.signature); // drop UnparsablePackets\n    return createVerificationObjects(signatureList, literalDataList, verificationKeys, date, true, config);\n  }\n\n  /**\n   * Unwrap compressed message\n   * @returns {Message} Message Content of compressed message.\n   */\n  unwrapCompressed() {\n    const compressed = this.packets.filterByTag(enums.packet.compressedData);\n    if (compressed.length) {\n      return new Message(compressed[0].packets);\n    }\n    return this;\n  }\n\n  /**\n   * Append signature to unencrypted message object\n   * @param {String|Uint8Array} detachedSignature - The detached ASCII-armored or Uint8Array PGP signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  async appendSignature(detachedSignature, config = defaultConfig) {\n    await this.packets.read(\n      util.isUint8Array(detachedSignature) ? detachedSignature : (await unarmor(detachedSignature)).data,\n      allowedDetachedSignaturePackets,\n      config\n    );\n  }\n\n  /**\n   * Returns binary encoded message\n   * @returns {ReadableStream<Uint8Array>} Binary message.\n   */\n  write() {\n    return this.packets.write();\n  }\n\n  /**\n   * Returns ASCII armored text of message\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    const trailingPacket = this.packets[this.packets.length - 1];\n    // An ASCII-armored Encrypted Message packet sequence that ends in an v2 SEIPD packet MUST NOT contain a CRC24 footer.\n    // An ASCII-armored sequence of Signature packets that only includes v6 Signature packets MUST NOT contain a CRC24 footer.\n    const emitChecksum = trailingPacket.constructor.tag === SymEncryptedIntegrityProtectedDataPacket.tag ?\n      trailingPacket.version !== 2 :\n      this.packets.some(packet => packet.constructor.tag === SignaturePacket.tag && packet.version !== 6);\n    return armor(enums.armor.message, this.write(), null, null, null, emitChecksum, config);\n  }\n}\n\n/**\n * Create signature packets for the message\n * @param {LiteralDataPacket} literalDataPacket - the literal data packet to sign\n * @param {Array<PrivateKey>} [signingKeys] - private keys with decrypted secret key data for signing\n * @param {Array<Key>} [recipientKeys] - recipient keys to get the signing preferences from\n * @param {Signature} [signature] - Any existing detached signature to append\n * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n * @param {Date} [date] - Override the creationtime of the signature\n * @param {Array<UserID>} [signingUserIDs] - User IDs to sign to, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n * @param {Array} [signatureSalts] - A list of signature salts matching the number of signingKeys that should be used for v6 signatures\n * @param {Boolean} [detached] - Whether to create detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<PacketList>} List of signature packets.\n * @async\n * @private\n */\nexport async function createSignaturePackets(literalDataPacket, signingKeys, recipientKeys = [], signature = null, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], notations = [], detached = false, config = defaultConfig) {\n  const packetlist = new PacketList();\n\n  // If data packet was created from Uint8Array, use binary, otherwise use text\n  const signatureType = literalDataPacket.text === null ?\n    enums.signature.binary : enums.signature.text;\n\n  await Promise.all(signingKeys.map(async (primaryKey, i) => {\n    const signingUserID = signingUserIDs[i];\n    if (!primaryKey.isPrivate()) {\n      throw new Error('Need private key for signing');\n    }\n    const signingKey = await primaryKey.getSigningKey(signingKeyIDs[i], date, signingUserID, config);\n    return createSignaturePacket(literalDataPacket, recipientKeys.length ? recipientKeys : [primaryKey], signingKey.keyPacket, { signatureType }, date, recipientUserIDs, notations, detached, config);\n  })).then(signatureList => {\n    packetlist.push(...signatureList);\n  });\n\n  if (signature) {\n    const existingSigPacketlist = signature.packets.filterByTag(enums.packet.signature);\n    packetlist.push(...existingSigPacketlist);\n  }\n  return packetlist;\n}\n\n/**\n * Create object containing signer's keyID and validity of signature\n * @param {SignaturePacket} signature - Signature packet\n * @param {Array<LiteralDataPacket>} literalDataList - Array of literal data packets\n * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n * @param {Date} [date] - Check signature validity with respect to the given date\n * @param {Boolean} [detached] - Whether to verify detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<{\n *   keyID: module:type/keyid~KeyID,\n *   signature: Promise<Signature>,\n *   verified: Promise<true>\n * }>} signer's keyID and validity of signature\n * @async\n * @private\n */\nasync function createVerificationObject(signature, literalDataList, verificationKeys, date = new Date(), detached = false, config = defaultConfig) {\n  let primaryKey;\n  let unverifiedSigningKey;\n\n  for (const key of verificationKeys) {\n    const issuerKeys = key.getKeys(signature.issuerKeyID);\n    if (issuerKeys.length > 0) {\n      primaryKey = key;\n      unverifiedSigningKey = issuerKeys[0];\n      break;\n    }\n  }\n\n  const isOnePassSignature = signature instanceof OnePassSignaturePacket;\n  const signaturePacketPromise = isOnePassSignature ? signature.correspondingSig : signature;\n\n  const verifiedSig = {\n    keyID: signature.issuerKeyID,\n    verified: (async () => {\n      if (!unverifiedSigningKey) {\n        throw new Error(`Could not find signing key with key ID ${signature.issuerKeyID.toHex()}`);\n      }\n\n      await signature.verify(unverifiedSigningKey.keyPacket, signature.signatureType, literalDataList[0], date, detached, config);\n      const signaturePacket = await signaturePacketPromise;\n      if (unverifiedSigningKey.getCreationTime() > signaturePacket.created) {\n        throw new Error('Key is newer than the signature');\n      }\n      // We pass the signature creation time to check whether the key was expired at the time of signing.\n      // We check this after signature verification because for streamed one-pass signatures, the creation time is not available before\n      try {\n        await primaryKey.getSigningKey(unverifiedSigningKey.getKeyID(), signaturePacket.created, undefined, config);\n      } catch (e) {\n        // If a key was reformatted then the self-signatures of the signing key might be in the future compared to the message signature,\n        // making the key invalid at the time of signing.\n        // However, if the key is valid at the given `date`, we still allow using it provided the relevant `config` setting is enabled.\n        // Note: we do not support the edge case of a key that was reformatted and it has expired.\n        if (config.allowInsecureVerificationWithReformattedKeys && e.message.match(/Signature creation time is in the future/)) {\n          await primaryKey.getSigningKey(unverifiedSigningKey.getKeyID(), date, undefined, config);\n        } else {\n          throw e;\n        }\n      }\n      return true;\n    })(),\n    signature: (async () => {\n      const signaturePacket = await signaturePacketPromise;\n      const packetlist = new PacketList();\n      signaturePacket && packetlist.push(signaturePacket);\n      return new Signature(packetlist);\n    })()\n  };\n\n  // Mark potential promise rejections as \"handled\". This is needed because in\n  // some cases, we reject them before the user has a reasonable chance to\n  // handle them (e.g. `await readToEnd(result.data); await result.verified` and\n  // the data stream errors).\n  verifiedSig.signature.catch(() => {});\n  verifiedSig.verified.catch(() => {});\n\n  return verifiedSig;\n}\n\n/**\n * Create list of objects containing signer's keyID and validity of signature\n * @param {Array<SignaturePacket>} signatureList - Array of signature packets\n * @param {Array<LiteralDataPacket>} literalDataList - Array of literal data packets\n * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n * @param {Date} date - Verify the signature against the given date,\n *                    i.e. check signature creation time < date < expiration time\n * @param {Boolean} [detached] - Whether to verify detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<Array<{\n *   keyID: module:type/keyid~KeyID,\n *   signature: Promise<Signature>,\n *   verified: Promise<true>\n * }>>} list of signer's keyID and validity of signatures (one entry per signature packet in input)\n * @async\n * @private\n */\nexport async function createVerificationObjects(signatureList, literalDataList, verificationKeys, date = new Date(), detached = false, config = defaultConfig) {\n  return Promise.all(signatureList.filter(function(signature) {\n    return ['text', 'binary'].includes(enums.read(enums.signature, signature.signatureType));\n  }).map(async function(signature) {\n    return createVerificationObject(signature, literalDataList, verificationKeys, date, detached, config);\n  }));\n}\n\n/**\n * Reads an (optionally armored) OpenPGP message and returns a Message object\n * @param {Object} options\n * @param {String | ReadableStream<String>} [options.armoredMessage] - Armored message to be parsed\n * @param {Uint8Array | ReadableStream<Uint8Array>} [options.binaryMessage] - Binary to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Message>} New message object.\n * @async\n * @static\n */\nexport async function readMessage({ armoredMessage, binaryMessage, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  let input = armoredMessage || binaryMessage;\n  if (!input) {\n    throw new Error('readMessage: must pass options object containing `armoredMessage` or `binaryMessage`');\n  }\n  if (armoredMessage && !util.isString(armoredMessage) && !util.isStream(armoredMessage)) {\n    throw new Error('readMessage: options.armoredMessage must be a string or stream');\n  }\n  if (binaryMessage && !util.isUint8Array(binaryMessage) && !util.isStream(binaryMessage)) {\n    throw new Error('readMessage: options.binaryMessage must be a Uint8Array or stream');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const streamType = util.isStream(input);\n  if (armoredMessage) {\n    const { type, data } = await unarmor(input, config);\n    if (type !== enums.armor.message) {\n      throw new Error('Armored text not of type message');\n    }\n    input = data;\n  }\n  const packetlist = await PacketList.fromBinary(input, allowedMessagePackets, config, new MessageGrammarValidator());\n  const message = new Message(packetlist);\n  message.fromStream = streamType;\n  return message;\n}\n\n/**\n * Creates new message object from text or binary data.\n * @param {Object} options\n * @param {String | ReadableStream<String>} [options.text] - The text message contents\n * @param {Uint8Array | ReadableStream<Uint8Array>} [options.binary] - The binary message contents\n * @param {String} [options.filename=\"\"] - Name of the file (if any)\n * @param {Date} [options.date=current date] - Date of the message, or modification date of the file\n * @param {'utf8'|'binary'|'text'|'mime'} [options.format='utf8' if text is passed, 'binary' otherwise] - Data packet type\n * @returns {Promise<Message>} New message object.\n * @async\n * @static\n */\nexport async function createMessage({ text, binary, filename, date = new Date(), format = text !== undefined ? 'utf8' : 'binary', ...rest }) {\n  const input = text !== undefined ? text : binary;\n  if (input === undefined) {\n    throw new Error('createMessage: must pass options object containing `text` or `binary`');\n  }\n  if (text && !util.isString(text) && !util.isStream(text)) {\n    throw new Error('createMessage: options.text must be a string or stream');\n  }\n  if (binary && !util.isUint8Array(binary) && !util.isStream(binary)) {\n    throw new Error('createMessage: options.binary must be a Uint8Array or stream');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const streamType = util.isStream(input);\n  const literalDataPacket = new LiteralDataPacket(date);\n  if (text !== undefined) {\n    literalDataPacket.setText(input, enums.write(enums.literal, format));\n  } else {\n    literalDataPacket.setBytes(input, enums.write(enums.literal, format));\n  }\n  if (filename !== undefined) {\n    literalDataPacket.setFilename(filename);\n  }\n  const literalDataPacketlist = new PacketList();\n  literalDataPacketlist.push(literalDataPacket);\n  const message = new Message(literalDataPacketlist);\n  message.fromStream = streamType;\n  return message;\n}\n","// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor, unarmor } from './encoding/armor';\nimport enums from './enums';\nimport util from './util';\nimport { PacketList, LiteralDataPacket, SignaturePacket } from './packet';\nimport { Signature } from './signature';\nimport { createVerificationObjects, createSignaturePackets } from './message';\nimport defaultConfig from './config';\n\n// A Cleartext message can contain the following packets\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP cleartext signed message.\n * See {@link https://tools.ietf.org/html/rfc4880#section-7}\n */\nexport class CleartextMessage {\n  /**\n   * @param {String} text - The cleartext of the signed message\n   * @param {Signature} signature - The detached signature or an empty signature for unsigned messages\n   */\n  constructor(text, signature) {\n    // remove trailing whitespace and normalize EOL to canonical form <CR><LF>\n    this.text = util.removeTrailingSpaces(text).replace(/\\r?\\n/g, '\\r\\n');\n    if (signature && !(signature instanceof Signature)) {\n      throw new Error('Invalid signature input');\n    }\n    this.signature = signature || new Signature(new PacketList());\n  }\n\n  /**\n   * Returns the key IDs of the keys that signed the cleartext message\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getSigningKeyIDs() {\n    const keyIDs = [];\n    const signatureList = this.signature.packets;\n    signatureList.forEach(function(packet) {\n      keyIDs.push(packet.issuerKeyID);\n    });\n    return keyIDs;\n  }\n\n  /**\n   * Sign the cleartext message\n   * @param {Array<Key>} signingKeys - private keys with decrypted secret key data for signing\n   * @param {Array<Key>} recipientKeys - recipient keys to get the signing preferences from\n   * @param {Signature} [signature] - Any existing detached signature\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to privateKeys[i]\n   * @param {Date} [date] - The creation time of the signature that should be created\n   * @param {Array} [signingKeyIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<CleartextMessage>} New cleartext message with signed content.\n   * @async\n   */\n  async sign(signingKeys, recipientKeys = [], signature = null, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], notations = [], config = defaultConfig) {\n    const literalDataPacket = new LiteralDataPacket();\n    literalDataPacket.setText(this.text);\n    const newSignature = new Signature(await createSignaturePackets(literalDataPacket, signingKeys, recipientKeys, signature, signingKeyIDs, date, signingUserIDs, recipientUserIDs, notations, true, config));\n    return new CleartextMessage(this.text, newSignature);\n  }\n\n  /**\n   * Verify signatures of cleartext signed message\n   * @param {Array<Key>} keys - Array of keys to verify signatures\n   * @param {Date} [date] - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signature.\n   * @async\n   */\n  verify(keys, date = new Date(), config = defaultConfig) {\n    const signatureList = this.signature.packets.filterByTag(enums.packet.signature); // drop UnparsablePackets\n    const literalDataPacket = new LiteralDataPacket();\n    // we assume that cleartext signature is generated based on UTF8 cleartext\n    literalDataPacket.setText(this.text);\n    return createVerificationObjects(signatureList, [literalDataPacket], keys, date, true, config);\n  }\n\n  /**\n   * Get cleartext\n   * @returns {String} Cleartext of message.\n   */\n  getText() {\n    // normalize end of line to \\n\n    return this.text.replace(/\\r\\n/g, '\\n');\n  }\n\n  /**\n   * Returns ASCII armored text of cleartext signed message\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {String | ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    // emit header and checksum if one of the signatures has a version not 6\n    const emitHeaderAndChecksum = this.signature.packets.some(packet => packet.version !== 6);\n    const hash = emitHeaderAndChecksum ?\n      Array.from(new Set(this.signature.packets.map(\n        packet => enums.read(enums.hash, packet.hashAlgorithm).toUpperCase()\n      ))).join() :\n      null;\n\n    const body = {\n      hash,\n      text: this.text,\n      data: this.signature.packets.write()\n    };\n\n    // An ASCII-armored sequence of Signature packets that only includes v6 Signature packets MUST NOT contain a CRC24 footer.\n    return armor(enums.armor.signed, body, undefined, undefined, undefined, emitHeaderAndChecksum, config);\n  }\n}\n\n/**\n * Reads an OpenPGP cleartext signed message and returns a CleartextMessage object\n * @param {Object} options\n * @param {String} options.cleartextMessage - Text to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<CleartextMessage>} New cleartext message object.\n * @async\n * @static\n */\nexport async function readCleartextMessage({ cleartextMessage, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  if (!cleartextMessage) {\n    throw new Error('readCleartextMessage: must pass options object containing `cleartextMessage`');\n  }\n  if (!util.isString(cleartextMessage)) {\n    throw new Error('readCleartextMessage: options.cleartextMessage must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const input = await unarmor(cleartextMessage);\n  if (input.type !== enums.armor.signed) {\n    throw new Error('No cleartext signed message.');\n  }\n  const packetlist = await PacketList.fromBinary(input.data, allowedPackets, config);\n  verifyHeaders(input.headers, packetlist);\n  const signature = new Signature(packetlist);\n  return new CleartextMessage(input.text, signature);\n}\n\n/**\n * Compare hash algorithm specified in the armor header with signatures\n * @param {Array<String>} headers - Armor headers\n * @param {PacketList} packetlist - The packetlist with signature packets\n * @private\n */\nfunction verifyHeaders(headers, packetlist) {\n  const checkHashAlgos = function(hashAlgos) {\n    const check = packet => algo => packet.hashAlgorithm === algo;\n\n    for (let i = 0; i < packetlist.length; i++) {\n      if (packetlist[i].constructor.tag === enums.packet.signature && !hashAlgos.some(check(packetlist[i]))) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const hashAlgos = [];\n  headers.forEach(header => {\n    const hashHeader = header.match(/^Hash: (.+)$/); // get header value\n    if (hashHeader) {\n      const parsedHashIDs = hashHeader[1]\n        .replace(/\\s/g, '') // remove whitespace\n        .split(',')\n        .map(hashName => {\n          try {\n            return enums.write(enums.hash, hashName.toLowerCase());\n          } catch (e) {\n            throw new Error('Unknown hash algorithm in armor header: ' + hashName.toLowerCase());\n          }\n        });\n      hashAlgos.push(...parsedHashIDs);\n    } else {\n      throw new Error('Only \"Hash\" header allowed in cleartext signed message');\n    }\n  });\n\n  if (hashAlgos.length && !checkHashAlgos(hashAlgos)) {\n    throw new Error('Hash algorithm mismatch in armor header and signature');\n  }\n}\n\n/**\n * Creates a new CleartextMessage object from text\n * @param {Object} options\n * @param {String} options.text\n * @static\n * @async\n */\nexport async function createCleartextMessage({ text, ...rest }) {\n  if (!text) {\n    throw new Error('createCleartextMessage: must pass options object containing `text`');\n  }\n  if (!util.isString(text)) {\n    throw new Error('createCleartextMessage: options.text must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  return new CleartextMessage(text);\n}\n","// OpenPGP.js - An OpenPGP implementation in javascript\n// Copyright (C) 2016 Tankred Hase\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { fromAsync as streamFromAsync, concat as streamConcat, transformPair as streamTransformPair, pipe as streamPipe, readToEnd as streamReadToEnd, getWriter as streamGetWriter } from '@openpgp/web-stream-tools';\nimport { Message } from './message';\nimport { CleartextMessage } from './cleartext';\nimport { generate, reformat, getPreferredCompressionAlgo } from './key';\nimport defaultConfig from './config';\nimport util from './util';\nimport { checkKeyRequirements } from './key/helper';\n\n\n//////////////////////\n//                  //\n//   Key handling   //\n//                  //\n//////////////////////\n\n\n/**\n * Generates a new OpenPGP key pair. Supports RSA and ECC keys, as well as the newer Curve448 and Curve25519 keys.\n * By default, primary and subkeys will be of same type.\n * The generated primary key will have signing capabilities. By default, one subkey with encryption capabilities is also generated.\n * @param {Object} options\n * @param {Object|Array<Object>} options.userIDs - User IDs as objects: `{ name: 'Jo Doe', email: 'info@jo.com' }`\n * @param {'ecc'|'rsa'|'curve448'|'curve25519'} [options.type='ecc'] - The primary key algorithm type: ECC (default for v4 keys), RSA, Curve448 or Curve25519 (new format, default for v6 keys).\n *                                                                     Note: Curve448 and Curve25519 (new format) are not widely supported yet.\n * @param {String} [options.passphrase=(not protected)] - The passphrase used to encrypt the generated private key. If omitted or empty, the key won't be encrypted.\n * @param {Number} [options.rsaBits=4096] - Number of bits for RSA keys\n * @param {String} [options.curve='curve25519Legacy'] - Elliptic curve for ECC keys:\n *                                             curve25519Legacy (default), nistP256, nistP384, nistP521, secp256k1,\n *                                             brainpoolP256r1, brainpoolP384r1, or brainpoolP512r1\n * @param {Date} [options.date=current date] - Override the creation date of the key and the key signatures\n * @param {Number} [options.keyExpirationTime=0 (never expires)] - Number of seconds from the key creation time after which the key expires\n * @param {Array<Object>} [options.subkeys=a single encryption subkey] - Options for each subkey e.g. `[{sign: true, passphrase: '123'}]`\n *                                             default to main key options, except for `sign` parameter that defaults to false, and indicates whether the subkey should sign rather than encrypt\n * @param {'armored'|'binary'|'object'} [options.format='armored'] - format of the output keys\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object>} The generated key object in the form:\n *                                     { privateKey:PrivateKey|Uint8Array|String, publicKey:PublicKey|Uint8Array|String, revocationCertificate:String }\n * @async\n * @static\n */\nexport async function generateKey({ userIDs = [], passphrase, type, curve, rsaBits = 4096, keyExpirationTime = 0, date = new Date(), subkeys = [{}], format = 'armored', config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  if (!type && !curve) {\n    type = config.v6Keys ? 'curve25519' : 'ecc'; // default to new curve25519 for v6 keys (legacy curve25519 cannot be used with them)\n    curve = 'curve25519Legacy'; // unused with type != 'ecc'\n  } else {\n    type = type || 'ecc';\n    curve = curve || 'curve25519Legacy';\n  }\n  userIDs = toArray(userIDs);\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (userIDs.length === 0 && !config.v6Keys) {\n    throw new Error('UserIDs are required for V4 keys');\n  }\n  if (type === 'rsa' && rsaBits < config.minRSABits) {\n    throw new Error(`rsaBits should be at least ${config.minRSABits}, got: ${rsaBits}`);\n  }\n\n  const options = { userIDs, passphrase, type, rsaBits, curve, keyExpirationTime, date, subkeys };\n\n  try {\n    const { key, revocationCertificate } = await generate(options, config);\n    key.getKeys().forEach(({ keyPacket }) => checkKeyRequirements(keyPacket, config));\n\n    return {\n      privateKey: formatObject(key, format, config),\n      publicKey: formatObject(key.toPublic(), format, config),\n      revocationCertificate\n    };\n  } catch (err) {\n    throw util.wrapError('Error generating keypair', err);\n  }\n}\n\n/**\n * Reformats signature packets for a key and rewraps key object.\n * @param {Object} options\n * @param {PrivateKey} options.privateKey - Private key to reformat\n * @param {Object|Array<Object>} options.userIDs - User IDs as objects: `{ name: 'Jo Doe', email: 'info@jo.com' }`\n * @param {String} [options.passphrase=(not protected)] - The passphrase used to encrypt the reformatted private key. If omitted or empty, the key won't be encrypted.\n * @param {Number} [options.keyExpirationTime=0 (never expires)] - Number of seconds from the key creation time after which the key expires\n * @param {Date}   [options.date] - Override the creation date of the key signatures. If the key was previously used to sign messages, it is recommended\n *                                  to set the same date as the key creation time to ensure that old message signatures will still be verifiable using the reformatted key.\n * @param {'armored'|'binary'|'object'} [options.format='armored'] - format of the output keys\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object>} The generated key object in the form:\n *                                     { privateKey:PrivateKey|Uint8Array|String, publicKey:PublicKey|Uint8Array|String, revocationCertificate:String }\n * @async\n * @static\n */\nexport async function reformatKey({ privateKey, userIDs = [], passphrase, keyExpirationTime = 0, date, format = 'armored', config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  userIDs = toArray(userIDs);\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (userIDs.length === 0 && privateKey.keyPacket.version !== 6) {\n    throw new Error('UserIDs are required for V4 keys');\n  }\n  const options = { privateKey, userIDs, passphrase, keyExpirationTime, date };\n\n  try {\n    const { key: reformattedKey, revocationCertificate } = await reformat(options, config);\n\n    return {\n      privateKey: formatObject(reformattedKey, format, config),\n      publicKey: formatObject(reformattedKey.toPublic(), format, config),\n      revocationCertificate\n    };\n  } catch (err) {\n    throw util.wrapError('Error reformatting keypair', err);\n  }\n}\n\n/**\n * Revokes a key. Requires either a private key or a revocation certificate.\n *   If a revocation certificate is passed, the reasonForRevocation parameter will be ignored.\n * @param {Object} options\n * @param {Key} options.key - Public or private key to revoke\n * @param {String} [options.revocationCertificate] - Revocation certificate to revoke the key with\n * @param {Object} [options.reasonForRevocation] - Object indicating the reason for revocation\n * @param {module:enums.reasonForRevocation} [options.reasonForRevocation.flag=[noReason]{@link module:enums.reasonForRevocation}] - Flag indicating the reason for revocation\n * @param {String} [options.reasonForRevocation.string=\"\"] - String explaining the reason for revocation\n * @param {Date} [options.date] - Use the given date instead of the current time to verify validity of revocation certificate (if provided), or as creation time of the revocation signature\n * @param {'armored'|'binary'|'object'} [options.format='armored'] - format of the output key(s)\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object>} The revoked key in the form:\n *                              { privateKey:PrivateKey|Uint8Array|String, publicKey:PublicKey|Uint8Array|String } if private key is passed, or\n *                              { privateKey: null, publicKey:PublicKey|Uint8Array|String } otherwise\n * @async\n * @static\n */\nexport async function revokeKey({ key, revocationCertificate, reasonForRevocation, date = new Date(), format = 'armored', config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  try {\n    const revokedKey = revocationCertificate ?\n      await key.applyRevocationCertificate(revocationCertificate, date, config) :\n      await key.revoke(reasonForRevocation, date, config);\n\n    return revokedKey.isPrivate() ? {\n      privateKey: formatObject(revokedKey, format, config),\n      publicKey: formatObject(revokedKey.toPublic(), format, config)\n    } : {\n      privateKey: null,\n      publicKey: formatObject(revokedKey, format, config)\n    };\n  } catch (err) {\n    throw util.wrapError('Error revoking key', err);\n  }\n}\n\n/**\n * Unlock a private key with the given passphrase.\n * This method does not change the original key.\n * @param {Object} options\n * @param {PrivateKey} options.privateKey - The private key to decrypt\n * @param {String|Array<String>} options.passphrase - The user's passphrase(s)\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<PrivateKey>} The unlocked key object.\n * @async\n */\nexport async function decryptKey({ privateKey, passphrase, config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (!privateKey.isPrivate()) {\n    throw new Error('Cannot decrypt a public key');\n  }\n  const clonedPrivateKey = privateKey.clone(true);\n  const passphrases = util.isArray(passphrase) ? passphrase : [passphrase];\n\n  try {\n    await Promise.all(clonedPrivateKey.getKeys().map(key => (\n      // try to decrypt each key with any of the given passphrases\n      util.anyPromise(passphrases.map(passphrase => key.keyPacket.decrypt(passphrase)))\n    )));\n\n    await clonedPrivateKey.validate(config);\n    return clonedPrivateKey;\n  } catch (err) {\n    clonedPrivateKey.clearPrivateParams();\n    throw util.wrapError('Error decrypting private key', err);\n  }\n}\n\n/**\n * Lock a private key with the given passphrase.\n * This method does not change the original key.\n * @param {Object} options\n * @param {PrivateKey} options.privateKey - The private key to encrypt\n * @param {String|Array<String>} options.passphrase - If multiple passphrases, they should be in the same order as the packets each should encrypt\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<PrivateKey>} The locked key object.\n * @async\n */\nexport async function encryptKey({ privateKey, passphrase, config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (!privateKey.isPrivate()) {\n    throw new Error('Cannot encrypt a public key');\n  }\n  const clonedPrivateKey = privateKey.clone(true);\n\n  const keys = clonedPrivateKey.getKeys();\n  const passphrases = util.isArray(passphrase) ? passphrase : new Array(keys.length).fill(passphrase);\n  if (passphrases.length !== keys.length) {\n    throw new Error('Invalid number of passphrases given for key encryption');\n  }\n\n  try {\n    await Promise.all(keys.map(async (key, i) => {\n      const { keyPacket } = key;\n      await keyPacket.encrypt(passphrases[i], config);\n      keyPacket.clearPrivateParams();\n    }));\n    return clonedPrivateKey;\n  } catch (err) {\n    clonedPrivateKey.clearPrivateParams();\n    throw util.wrapError('Error encrypting private key', err);\n  }\n}\n\n\n///////////////////////////////////////////\n//                                       //\n//   Message encryption and decryption   //\n//                                       //\n///////////////////////////////////////////\n\n\n/**\n * Encrypts a message using public keys, passwords or both at once. At least one of `encryptionKeys`, `passwords` or `sessionKeys`\n *   must be specified. If signing keys are specified, those will be used to sign the message.\n * @param {Object} options\n * @param {Message} options.message - Message to be encrypted as created by {@link createMessage}\n * @param {PublicKey|PublicKey[]} [options.encryptionKeys] - Array of keys or single key, used to encrypt the message\n * @param {PrivateKey|PrivateKey[]} [options.signingKeys] - Private keys for signing. If omitted message will not be signed\n * @param {String|String[]} [options.passwords] - Array of passwords or a single password to encrypt the message\n * @param {Object} [options.sessionKey] - Session key in the form: `{ data:Uint8Array, algorithm:String }`\n * @param {'armored'|'binary'|'object'} [options.format='armored'] - Format of the returned message\n * @param {Signature} [options.signature] - A detached signature to add to the encrypted message\n * @param {Boolean} [options.wildcard=false] - Use a key ID of 0 instead of the public key IDs\n * @param {KeyID|KeyID[]} [options.signingKeyIDs=latest-created valid signing (sub)keys] - Array of key IDs to use for signing. Each `signingKeyIDs[i]` corresponds to `signingKeys[i]`\n * @param {KeyID|KeyID[]} [options.encryptionKeyIDs=latest-created valid encryption (sub)keys] - Array of key IDs to use for encryption. Each `encryptionKeyIDs[i]` corresponds to `encryptionKeys[i]`\n * @param {Date} [options.date=current date] - Override the creation date of the message signature\n * @param {Object|Object[]} [options.signingUserIDs=primary user IDs] - Array of user IDs to sign with, one per key in `signingKeys`, e.g. `[{ name: 'Steve Sender', email: 'steve@openpgp.org' }]`\n * @param {Object|Object[]} [options.encryptionUserIDs=primary user IDs] - Array of user IDs to encrypt for, one per key in `encryptionKeys`, e.g. `[{ name: 'Robert Receiver', email: 'robert@openpgp.org' }]`\n * @param {Object|Object[]} [options.signatureNotations=[]] - Array of notations to add to the signatures, e.g. `[{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]`\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<MaybeStream<String>|MaybeStream<Uint8Array>>} Encrypted message (string if `armor` was true, the default; Uint8Array if `armor` was false).\n * @async\n * @static\n */\nexport async function encrypt({ message, encryptionKeys, signingKeys, passwords, sessionKey, format = 'armored', signature = null, wildcard = false, signingKeyIDs = [], encryptionKeyIDs = [], date = new Date(), signingUserIDs = [], encryptionUserIDs = [], signatureNotations = [], config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkMessage(message); checkOutputMessageFormat(format);\n  encryptionKeys = toArray(encryptionKeys); signingKeys = toArray(signingKeys); passwords = toArray(passwords);\n  signingKeyIDs = toArray(signingKeyIDs); encryptionKeyIDs = toArray(encryptionKeyIDs); signingUserIDs = toArray(signingUserIDs); encryptionUserIDs = toArray(encryptionUserIDs); signatureNotations = toArray(signatureNotations);\n  if (rest.detached) {\n    throw new Error(\"The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.\");\n  }\n  if (rest.publicKeys) throw new Error('The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead');\n  if (rest.privateKeys) throw new Error('The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead');\n  if (rest.armor !== undefined) throw new Error('The `armor` option has been removed from openpgp.encrypt, pass `format` instead.');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (!signingKeys) {\n    signingKeys = [];\n  }\n\n  try {\n    if (signingKeys.length || signature) { // sign the message only if signing keys or signature is specified\n      message = await message.sign(signingKeys, encryptionKeys, signature, signingKeyIDs, date, signingUserIDs, encryptionKeyIDs, signatureNotations, config);\n    }\n    message = message.compress(\n      await getPreferredCompressionAlgo(encryptionKeys, date, encryptionUserIDs, config),\n      config\n    );\n    message = await message.encrypt(encryptionKeys, passwords, sessionKey, wildcard, encryptionKeyIDs, date, encryptionUserIDs, config);\n    if (format === 'object') return message;\n    // serialize data\n    const armor = format === 'armored';\n    const data = armor ? message.armor(config) : message.write();\n    return await convertStream(data);\n  } catch (err) {\n    throw util.wrapError('Error encrypting message', err);\n  }\n}\n\n/**\n * Decrypts a message with the user's private key, a session key or a password.\n * One of `decryptionKeys`, `sessionkeys` or `passwords` must be specified (passing a combination of these options is not supported).\n * @param {Object} options\n * @param {Message} options.message - The message object with the encrypted data\n * @param {PrivateKey|PrivateKey[]} [options.decryptionKeys] - Private keys with decrypted secret key data or session key\n * @param {String|String[]} [options.passwords] - Passwords to decrypt the message\n * @param {Object|Object[]} [options.sessionKeys] - Session keys in the form: { data:Uint8Array, algorithm:String }\n * @param {PublicKey|PublicKey[]} [options.verificationKeys] - Array of public keys or single key, to verify signatures\n * @param {Boolean} [options.expectSigned=false] - If true, data decryption fails if the message is not signed with the provided publicKeys\n * @param {'utf8'|'binary'} [options.format='utf8'] - Whether to return data as a string(Stream) or Uint8Array(Stream). If 'utf8' (the default), also normalize newlines.\n * @param {Signature} [options.signature] - Detached signature for verification\n * @param {Date} [options.date=current date] - Use the given date for verification instead of the current time\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object>} Object containing decrypted and verified message in the form:\n *\n *     {\n *       data: MaybeStream<String>, (if format was 'utf8', the default)\n *       data: MaybeStream<Uint8Array>, (if format was 'binary')\n *       filename: String,\n *       signatures: [\n *         {\n *           keyID: module:type/keyid~KeyID,\n *           verified: Promise<true>,\n *           signature: Promise<Signature>\n *         }, ...\n *       ]\n *     }\n *\n *     where `signatures` contains a separate entry for each signature packet found in the input message.\n * @async\n * @static\n */\nexport async function decrypt({ message, decryptionKeys, passwords, sessionKeys, verificationKeys, expectSigned = false, format = 'utf8', signature = null, date = new Date(), config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkMessage(message); verificationKeys = toArray(verificationKeys); decryptionKeys = toArray(decryptionKeys); passwords = toArray(passwords); sessionKeys = toArray(sessionKeys);\n  if (rest.privateKeys) throw new Error('The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead');\n  if (rest.publicKeys) throw new Error('The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  try {\n    const decrypted = await message.decrypt(decryptionKeys, passwords, sessionKeys, date, config);\n    if (!verificationKeys) {\n      verificationKeys = [];\n    }\n\n    const result = {};\n    result.signatures = signature ? await decrypted.verifyDetached(signature, verificationKeys, date, config) : await decrypted.verify(verificationKeys, date, config);\n    result.data = format === 'binary' ? decrypted.getLiteralData() : decrypted.getText();\n    result.filename = decrypted.getFilename();\n    linkStreams(result, message, ...new Set([decrypted, decrypted.unwrapCompressed()]));\n    if (expectSigned) {\n      if (verificationKeys.length === 0) {\n        throw new Error('Verification keys are required to verify message signatures');\n      }\n      if (result.signatures.length === 0) {\n        throw new Error('Message is not signed');\n      }\n      result.data = streamConcat([\n        result.data,\n        streamFromAsync(async () => {\n          await util.anyPromise(result.signatures.map(sig => sig.verified));\n          return format === 'binary' ? new Uint8Array() : '';\n        })\n      ]);\n    }\n    result.data = await convertStream(result.data);\n    return result;\n  } catch (err) {\n    throw util.wrapError('Error decrypting message', err);\n  }\n}\n\n\n//////////////////////////////////////////\n//                                      //\n//   Message signing and verification   //\n//                                      //\n//////////////////////////////////////////\n\n\n/**\n * Signs a message.\n * @param {Object} options\n * @param {CleartextMessage|Message} options.message - (cleartext) message to be signed\n * @param {PrivateKey|PrivateKey[]} options.signingKeys - Array of keys or single key with decrypted secret key data to sign cleartext\n * @param {Key|Key[]} options.recipientKeys - Array of keys or single to get the signing preferences from\n * @param {'armored'|'binary'|'object'} [options.format='armored'] - Format of the returned message\n * @param {Boolean} [options.detached=false] - If the return value should contain a detached signature\n * @param {KeyID|KeyID[]} [options.signingKeyIDs=latest-created valid signing (sub)keys] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n * @param {Date} [options.date=current date] - Override the creation date of the signature\n * @param {Object|Object[]} [options.signingUserIDs=primary user IDs] - Array of user IDs to sign with, one per key in `signingKeys`, e.g. `[{ name: 'Steve Sender', email: 'steve@openpgp.org' }]`\n * @param {Object|Object[]} [options.recipientUserIDs=primary user IDs] - Array of user IDs to get the signing preferences from, one per key in `recipientKeys`\n * @param {Object|Object[]} [options.signatureNotations=[]] - Array of notations to add to the signatures, e.g. `[{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]`\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<MaybeStream<String|Uint8Array>>} Signed message (string if `armor` was true, the default; Uint8Array if `armor` was false).\n * @async\n * @static\n */\nexport async function sign({ message, signingKeys, recipientKeys = [], format = 'armored', detached = false, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], signatureNotations = [], config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkCleartextOrMessage(message); checkOutputMessageFormat(format);\n  signingKeys = toArray(signingKeys); signingKeyIDs = toArray(signingKeyIDs); signingUserIDs = toArray(signingUserIDs); recipientKeys = toArray(recipientKeys); recipientUserIDs = toArray(recipientUserIDs); signatureNotations = toArray(signatureNotations);\n\n  if (rest.privateKeys) throw new Error('The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead');\n  if (rest.armor !== undefined) throw new Error('The `armor` option has been removed from openpgp.sign, pass `format` instead.');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (message instanceof CleartextMessage && format === 'binary') throw new Error('Cannot return signed cleartext message in binary format');\n  if (message instanceof CleartextMessage && detached) throw new Error('Cannot detach-sign a cleartext message');\n\n  if (!signingKeys || signingKeys.length === 0) {\n    throw new Error('No signing keys provided');\n  }\n\n  try {\n    let signature;\n    if (detached) {\n      signature = await message.signDetached(signingKeys, recipientKeys, undefined, signingKeyIDs, date, signingUserIDs, recipientUserIDs, signatureNotations, config);\n    } else {\n      signature = await message.sign(signingKeys, recipientKeys, undefined, signingKeyIDs, date, signingUserIDs, recipientUserIDs, signatureNotations, config);\n    }\n    if (format === 'object') return signature;\n\n    const armor = format === 'armored';\n    signature = armor ? signature.armor(config) : signature.write();\n    if (detached) {\n      signature = streamTransformPair(message.packets.write(), async (readable, writable) => {\n        await Promise.all([\n          streamPipe(signature, writable),\n          streamReadToEnd(readable).catch(() => {})\n        ]);\n      });\n    }\n    return await convertStream(signature);\n  } catch (err) {\n    throw util.wrapError('Error signing message', err);\n  }\n}\n\n/**\n * Verifies signatures of cleartext signed message\n * @param {Object} options\n * @param {CleartextMessage|Message} options.message - (cleartext) message object with signatures\n * @param {PublicKey|PublicKey[]} options.verificationKeys - Array of publicKeys or single key, to verify signatures\n * @param {Boolean} [options.expectSigned=false] - If true, verification throws if the message is not signed with the provided publicKeys\n * @param {'utf8'|'binary'} [options.format='utf8'] - Whether to return data as a string(Stream) or Uint8Array(Stream). If 'utf8' (the default), also normalize newlines.\n * @param {Signature} [options.signature] - Detached signature for verification\n * @param {Date} [options.date=current date] - Use the given date for verification instead of the current time\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object>} Object containing verified message in the form:\n *\n *     {\n *       data: MaybeStream<String>, (if `message` was a CleartextMessage)\n *       data: MaybeStream<Uint8Array>, (if `message` was a Message)\n *       signatures: [\n *         {\n *           keyID: module:type/keyid~KeyID,\n *           verified: Promise<true>,\n *           signature: Promise<Signature>\n *         }, ...\n *       ]\n *     }\n *\n *     where `signatures` contains a separate entry for each signature packet found in the input message.\n * @async\n * @static\n */\nexport async function verify({ message, verificationKeys, expectSigned = false, format = 'utf8', signature = null, date = new Date(), config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkCleartextOrMessage(message); verificationKeys = toArray(verificationKeys);\n  if (rest.publicKeys) throw new Error('The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if (message instanceof CleartextMessage && format === 'binary') throw new Error(\"Can't return cleartext message data as binary\");\n  if (message instanceof CleartextMessage && signature) throw new Error(\"Can't verify detached cleartext signature\");\n\n  try {\n    const result = {};\n    if (signature) {\n      result.signatures = await message.verifyDetached(signature, verificationKeys, date, config);\n    } else {\n      result.signatures = await message.verify(verificationKeys, date, config);\n    }\n    result.data = format === 'binary' ? message.getLiteralData() : message.getText();\n    if (message.fromStream && !signature) {\n      linkStreams(result, ...new Set([message, message.unwrapCompressed()]));\n    }\n    if (expectSigned) {\n      if (result.signatures.length === 0) {\n        throw new Error('Message is not signed');\n      }\n      result.data = streamConcat([\n        result.data,\n        streamFromAsync(async () => {\n          await util.anyPromise(result.signatures.map(sig => sig.verified));\n          return format === 'binary' ? new Uint8Array() : '';\n        })\n      ]);\n    }\n    result.data = await convertStream(result.data);\n    return result;\n  } catch (err) {\n    throw util.wrapError('Error verifying signed message', err);\n  }\n}\n\n\n///////////////////////////////////////////////\n//                                           //\n//   Session key encryption and decryption   //\n//                                           //\n///////////////////////////////////////////////\n\n/**\n * Generate a new session key object, taking the algorithm preferences of the passed public keys into account, if any.\n * @param {Object} options\n * @param {PublicKey|PublicKey[]} [options.encryptionKeys] - Array of public keys or single key used to select algorithm preferences for. If no keys are given, the algorithm will be [config.preferredSymmetricAlgorithm]{@link module:config.preferredSymmetricAlgorithm}\n * @param {Date} [options.date=current date] - Date to select algorithm preferences at\n * @param {Object|Object[]} [options.encryptionUserIDs=primary user IDs] - User IDs to select algorithm preferences for\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<{ data: Uint8Array, algorithm: String }>} Object with session key data and algorithm.\n * @async\n * @static\n */\nexport async function generateSessionKey({ encryptionKeys, date = new Date(), encryptionUserIDs = [], config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  encryptionKeys = toArray(encryptionKeys); encryptionUserIDs = toArray(encryptionUserIDs);\n  if (rest.publicKeys) throw new Error('The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  try {\n    const sessionKeys = await Message.generateSessionKey(encryptionKeys, date, encryptionUserIDs, config);\n    return sessionKeys;\n  } catch (err) {\n    throw util.wrapError('Error generating session key', err);\n  }\n}\n\n/**\n * Encrypt a symmetric session key with public keys, passwords, or both at once.\n * At least one of `encryptionKeys` or `passwords` must be specified.\n * @param {Object} options\n * @param {Uint8Array} options.data - The session key to be encrypted e.g. 16 random bytes (for aes128)\n * @param {String} options.algorithm - Algorithm of the symmetric session key e.g. 'aes128' or 'aes256'\n * @param {String} [options.aeadAlgorithm] - AEAD algorithm, e.g. 'eax' or 'ocb'\n * @param {PublicKey|PublicKey[]} [options.encryptionKeys] - Array of public keys or single key, used to encrypt the key\n * @param {String|String[]} [options.passwords] - Passwords for the message\n * @param {'armored'|'binary'} [options.format='armored'] - Format of the returned value\n * @param {Boolean} [options.wildcard=false] - Use a key ID of 0 instead of the public key IDs\n * @param {KeyID|KeyID[]} [options.encryptionKeyIDs=latest-created valid encryption (sub)keys] - Array of key IDs to use for encryption. Each encryptionKeyIDs[i] corresponds to encryptionKeys[i]\n * @param {Date} [options.date=current date] - Override the date\n * @param {Object|Object[]} [options.encryptionUserIDs=primary user IDs] - Array of user IDs to encrypt for, one per key in `encryptionKeys`, e.g. `[{ name: 'Phil Zimmermann', email: 'phil@openpgp.org' }]`\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<String|Uint8Array>} Encrypted session keys (string if `armor` was true, the default; Uint8Array if `armor` was false).\n * @async\n * @static\n */\nexport async function encryptSessionKey({ data, algorithm, aeadAlgorithm, encryptionKeys, passwords, format = 'armored', wildcard = false, encryptionKeyIDs = [], date = new Date(), encryptionUserIDs = [], config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkBinary(data); checkString(algorithm, 'algorithm'); checkOutputMessageFormat(format);\n  encryptionKeys = toArray(encryptionKeys); passwords = toArray(passwords); encryptionKeyIDs = toArray(encryptionKeyIDs); encryptionUserIDs = toArray(encryptionUserIDs);\n  if (rest.publicKeys) throw new Error('The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  if ((!encryptionKeys || encryptionKeys.length === 0) && (!passwords || passwords.length === 0)) {\n    throw new Error('No encryption keys or passwords provided.');\n  }\n\n  try {\n    const message = await Message.encryptSessionKey(data, algorithm, aeadAlgorithm, encryptionKeys, passwords, wildcard, encryptionKeyIDs, date, encryptionUserIDs, config);\n    return formatObject(message, format, config);\n  } catch (err) {\n    throw util.wrapError('Error encrypting session key', err);\n  }\n}\n\n/**\n * Decrypt symmetric session keys using private keys or passwords (not both).\n * One of `decryptionKeys` or `passwords` must be specified.\n * @param {Object} options\n * @param {Message} options.message - A message object containing the encrypted session key packets\n * @param {PrivateKey|PrivateKey[]} [options.decryptionKeys] - Private keys with decrypted secret key data\n * @param {String|String[]} [options.passwords] - Passwords to decrypt the session key\n * @param {Date} [options.date] - Date to use for key verification instead of the current time\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Object[]>} Array of decrypted session key, algorithm pairs in the form:\n *                                            { data:Uint8Array, algorithm:String }\n * @throws if no session key could be found or decrypted\n * @async\n * @static\n */\nexport async function decryptSessionKeys({ message, decryptionKeys, passwords, date = new Date(), config, ...rest }) {\n  config = { ...defaultConfig, ...config }; checkConfig(config);\n  checkMessage(message); decryptionKeys = toArray(decryptionKeys); passwords = toArray(passwords);\n  if (rest.privateKeys) throw new Error('The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead');\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  try {\n    const sessionKeys = await message.decryptSessionKeys(decryptionKeys, passwords, undefined, date, config);\n    return sessionKeys;\n  } catch (err) {\n    throw util.wrapError('Error decrypting session keys', err);\n  }\n}\n\n\n//////////////////////////\n//                      //\n//   Helper functions   //\n//                      //\n//////////////////////////\n\n\n/**\n * Input validation\n * @private\n */\nfunction checkString(data, name) {\n  if (!util.isString(data)) {\n    throw new Error('Parameter [' + (name || 'data') + '] must be of type String');\n  }\n}\nfunction checkBinary(data, name) {\n  if (!util.isUint8Array(data)) {\n    throw new Error('Parameter [' + (name || 'data') + '] must be of type Uint8Array');\n  }\n}\nfunction checkMessage(message) {\n  if (!(message instanceof Message)) {\n    throw new Error('Parameter [message] needs to be of type Message');\n  }\n}\nfunction checkCleartextOrMessage(message) {\n  if (!(message instanceof CleartextMessage) && !(message instanceof Message)) {\n    throw new Error('Parameter [message] needs to be of type Message or CleartextMessage');\n  }\n}\nfunction checkOutputMessageFormat(format) {\n  if (format !== 'armored' && format !== 'binary' && format !== 'object') {\n    throw new Error(`Unsupported format ${format}`);\n  }\n}\nconst defaultConfigPropsCount = Object.keys(defaultConfig).length;\nfunction checkConfig(config) {\n  const inputConfigProps = Object.keys(config);\n  if (inputConfigProps.length !== defaultConfigPropsCount) {\n    for (const inputProp of inputConfigProps) {\n      if (defaultConfig[inputProp] === undefined) {\n        throw new Error(`Unknown config property: ${inputProp}`);\n      }\n    }\n  }\n}\n\n/**\n * Normalize parameter to an array if it is not undefined.\n * @param {Object} param - the parameter to be normalized\n * @returns {Array<Object>|undefined} The resulting array or undefined.\n * @private\n */\nfunction toArray(param) {\n  if (param && !util.isArray(param)) {\n    param = [param];\n  }\n  return param;\n}\n\n/**\n * Convert data to or from Stream\n * @param {Object} data - the data to convert\n * @returns {Promise<Object>} The data in the respective format.\n * @async\n * @private\n */\nasync function convertStream(data) {\n  const streamType = util.isStream(data);\n  if (streamType === 'array') {\n    return streamReadToEnd(data);\n  }\n  return data;\n}\n\n/**\n * Link result.data to the input message stream for cancellation.\n * Also, forward errors in the input message and intermediate messages to result.data.\n * @param {Object} result - the data to convert\n * @param {Message} message - message object provided by the user\n * @param {Message} intermediateMessages - intermediate message object with packet streams to link\n * @returns {Object}\n * @private\n */\nfunction linkStreams(result, inputMessage, ...intermediateMessages) {\n  result.data = streamTransformPair(inputMessage.packets.stream, async (readable, writable) => {\n    await streamPipe(result.data, writable, {\n      preventClose: true\n    });\n    const writer = streamGetWriter(writable);\n    try {\n      // Forward errors in the message streams to result.data.\n      await streamReadToEnd(readable, _ => _);\n      await Promise.all(intermediateMessages.map(intermediate => streamReadToEnd(intermediate.packets.stream, _ => _)));\n      // if result.data throws, the writable will be in errored state, and `close()` fails, but its ok.\n      await writer.close();\n    } catch (e) {\n      await writer.abort(e);\n    }\n  });\n}\n\n/**\n * Convert the object to the given format\n * @param {Key|Message} object\n * @param {'armored'|'binary'|'object'} format\n * @param {Object} config - Full configuration\n * @returns {String|Uint8Array|Object}\n */\nfunction formatObject(object, format, config) {\n  switch (format) {\n    case 'object':\n      return object;\n    case 'armored':\n      return object.armor(config);\n    case 'binary':\n      return object.write();\n    default:\n      throw new Error(`Unsupported format ${format}`);\n  }\n}\n"],"names":["doneWritingPromise","Symbol","doneWritingResolve","doneWritingReject","readingIndex","ArrayStream","Array","constructor","super","Object","setPrototypeOf","this","prototype","Promise","resolve","reject","catch","isArrayStream","input","getReader","isArray","Writer","writer","getWriter","releaseLock","closed","call","stream","isStream","globalThis","ReadableStream","isPrototypeOf","_read","_readableState","Error","isUint8Array","Uint8Array","concatUint8Array","arrays","length","totalLength","i","result","pos","forEach","element","set","undefined","read","async","value","done","readToEnd","join","slice","clone","then","push","write","chunk","close","abort","reason","process","versions","doneReadingSet","WeakSet","externalBuffer","Reader","reader","bind","_releaseLock","_cancel","cancel","doneReading","has","add","e","toStream","start","controller","enqueue","toArrayStream","concat","list","some","map","transform","transformWithCancel","all","transforms","prev","transformPair","readable","writable","pipe","preventClose","concatStream","concatArrayStream","target","preventAbort","preventCancel","ready","pipeTo","transformRaw","options","transformStream","TransformStream","customCancel","backpressureChangePromiseResolve","backpressureChangePromiseReject","outputController","pulled","cancelled","pull","highWaterMark","WritableStream","error","finish","output","data","result1","result2","flush","fn","incomingTransformController","incoming","pipeDonePromise","outgoing","setTimeout","parse","returnValue","transformed","remainder","teed","tee","overwrite","passiveClone","entries","getOwnPropertyDescriptors","name","descriptor","get","defineProperty","begin","end","Infinity","bytesRead","Math","max","terminate","lastBytes","console","warn","fromAsync","subarray","destroy","arrayStream","shift","readLine","returnVal","buffer","streams.concat","lineEndIndex","indexOf","substr","unshift","readByte","byte","streams.slice","readBytes","bufferLength","bufferConcat","peekBytes","bytes","values","byteOffset","byteLength","filter","byValue","enums","curve","nistP256","p256","nistP384","p384","nistP521","p521","secp256k1","ed25519Legacy","ed25519","curve25519Legacy","curve25519","brainpoolP256r1","brainpoolP384r1","brainpoolP512r1","s2k","simple","salted","iterated","argon2","gnu","publicKey","rsaEncryptSign","rsaEncrypt","rsaSign","elgamal","dsa","ecdh","ecdsa","eddsaLegacy","aedh","aedsa","x25519","x448","ed448","symmetric","idea","tripledes","cast5","blowfish","aes128","aes192","aes256","twofish","compression","uncompressed","zip","zlib","bzip2","hash","md5","sha1","ripemd","sha256","sha384","sha512","sha224","sha3_256","sha3_512","webHash","aead","eax","ocb","gcm","experimentalGCM","packet","publicKeyEncryptedSessionKey","signature","symEncryptedSessionKey","onePassSignature","secretKey","secretSubkey","compressedData","symmetricallyEncryptedData","marker","literalData","trust","userID","publicSubkey","userAttribute","symEncryptedIntegrityProtectedData","modificationDetectionCode","aeadEncryptedData","padding","literal","binary","text","utf8","mime","standalone","certGeneric","certPersona","certCasual","certPositive","certRevocation","subkeyBinding","keyBinding","key","keyRevocation","subkeyRevocation","timestamp","thirdParty","signatureSubpacket","signatureCreationTime","signatureExpirationTime","exportableCertification","trustSignature","regularExpression","revocable","keyExpirationTime","placeholderBackwardsCompatibility","preferredSymmetricAlgorithms","revocationKey","issuerKeyID","notationData","preferredHashAlgorithms","preferredCompressionAlgorithms","keyServerPreferences","preferredKeyServer","primaryUserID","policyURI","keyFlags","signersUserID","reasonForRevocation","features","signatureTarget","embeddedSignature","issuerFingerprint","preferredAEADAlgorithms","preferredCipherSuites","certifyKeys","signData","encryptCommunication","encryptStorage","splitPrivateKey","authentication","sharedPrivateKey","armor","multipartSection","multipartLast","signed","message","privateKey","noReason","keySuperseded","keyCompromised","keyRetired","userIDInvalid","modificationDetection","v5Keys","seipdv2","type","config","preferredHashAlgorithm","preferredSymmetricAlgorithm","preferredCompressionAlgorithm","aeadProtect","parseAEADEncryptedV4KeysAsLegacy","preferredAEADAlgorithm","aeadChunkSizeByte","v6Keys","enableParsingV5Entities","s2kType","s2kIterationCountByte","s2kArgon2Params","passes","parallelism","memoryExponent","allowUnauthenticatedMessages","allowUnauthenticatedStream","minRSABits","passwordCollisionCheck","allowInsecureDecryptionWithSigningKeys","allowInsecureVerificationWithReformattedKeys","allowMissingKeyFlags","constantTimePKCS1Decryption","constantTimePKCS1DecryptionSupportedSymmetricAlgorithms","Set","ignoreUnsupportedPackets","ignoreMalformedPackets","enforceGrammar","additionalAllowedPackets","showVersion","showComment","versionString","commentString","maxUserIDLength","knownNotations","nonDeterministicSignaturesViaNotation","useEllipticFallback","rejectHashAlgorithms","rejectMessageHashAlgorithms","rejectPublicKeyAlgorithms","rejectCurves","debugMode","env","NODE_ENV","util","isString","String","nodeRequire","getNobleCurve","publicKeyAlgo","curveName","defaultConfig","nobleCurves","import","readNumber","n","writeNumber","b","readDate","Date","writeDate","time","numeric","floor","getTime","normalizeDate","now","readMPI","bytelen","readExactSubarray","leftPad","padded","offset","uint8ArrayToMPI","bin","bitSize","uint8ArrayBitLength","stripped","ceil","prefix","nbits","hexToUint8Array","hex","k","parseInt","uint8ArrayToHex","hexAlphabet","s","v","stringToUint8Array","str","streamTransform","charCodeAt","uint8ArrayToString","bs","j","fromCharCode","apply","encodeUTF8","encoder","TextEncoder","lastChunk","encode","decodeUTF8","decoder","TextDecoder","decode","streamConcat","equalsUint8Array","array1","array2","findLastIndex","arr","findFn","writeChecksum","printDebug","log","printDebugError","x","r","t","double","doubleVar","last","shiftRight","array","bits","getWebCrypto","webCrypto","crypto","subtle","getNodeCrypto","webcrypto","getNodeZlib","getNodeBuffer","Buffer","getHardwareConcurrency","navigator","hardwareConcurrency","cpus","isEmailAddress","test","canonicalizeEOL","carryOverCR","index","indices","normalized","sub","nativeEOL","copyWithin","removeTrailingSpaces","split","line","wrapError","cause","constructAllowedPackets","allowedClasses","PacketClass","tag","anyPromise","promises","exception","promise","selectUint8Array","cond","a","selectUint8","isAES","cipherAlgo","encodeChunk","decodeChunk","buf","lines","encoded","spaces","spacechars","spacechar","includes","decoded","b64ToUint8Array","base64","replace","uint8ArrayToB64","url","getType","header","match","addheader","customComment","getCheckSum","crc","len32","isLittleEndian","arr32","Uint32Array","crc_table","createcrc24","encodeBase64","from","toString","btoa","atob","ArrayBuffer","DataView","setInt16","Int16Array","verifyHeaders","headers","removeChecksum","body","lastEquals","lastIndexOf","unarmor","reSplit","reEmptyLine","headersDone","textDone","lastHeaders","decodeBase64","streamTransformPair","streamGetReader","streamGetWriter","parts","streamReadToEnd","messageType","partIndex","partTotal","emitChecksum","maybeBodyClone","streamPassiveClone","_0n","BigInt","_1n","uint8ArrayToBigInt","mod","m","reduced","modExp","exp","lsb","abs","modInv","gcd","aInput","bInput","y","xPrev","yPrev","aNegated","bNegated","q","tmp","_egcd","bigIntToNumber","number","Number","MAX_SAFE_INTEGER","getBit","bitLength","bitlen","_8n","len","bigIntToUint8Array","endian","rawLength","reverse","nodeCrypto","getRandomBytes","getRandomValues","getRandomBigInteger","min","modulus","randomProbablePrime","_30n","adds","isProbablePrime","smallPrimes","every","divisionTest","fermat","n1","d","millerRabin","nodeCryptoHashes","getHashes","nodeHash","shasum","createHash","update","digest","nobleHash","nobleHashName","webCryptoHashName","getNobleHash","nobleHashes","hashInstance","create","computeDigest","algo","getHashByteLength","hash_headers","emeEncode","keyLength","mLength","PS","count","randomBytes","getPKCS1Padding","emeDecode","randomPayload","separatorNotFound","psLen","payload","isValidPadding","emsaEncode","hashed","emLen","hashPrefix","tLen","fill","EM","sign","hashAlgo","p","u","hashName","jwk","privateToJWK","importKey","webSign","err","createSign","format","nodeSign","bnSign","verify","publicToJWK","webVerify","createVerify","nodeVerify","EM1","EM2","bnVerify","encrypt","constants","RSA_PKCS1_PADDING","publicEncrypt","nodeEncrypt","bnEncrypt","decrypt","privateDecrypt","nodeDecrypt","dq","dp","unblinder","blinder","mp","mq","h","bnDecrypt","pNum","qNum","dNum","kty","qi","ext","jwkToPrivate","knownOIDs","OID","oid","toHex","getName","readSimpleLength","writeSimpleLength","writePartialLength","power","writeTag","tag_type","writeHeader","supportsStreaming","readPacket","useStreamType","callback","callbackReturned","peekedBytes","headerByte","packetLength","packetLengthType","packetSupportsStreaming","wasPartialLength","lengthByte","TypeError","UnsupportedError","params","captureStackTrace","UnknownPacketError","MalformedPacketError","UnparseablePacket","rawContent","generate","webCryptoKey","generateKey","newErr","exportKey","A","seed","default","getPayloadSize","keyPair","fromSeed","keygen","getPreferredHashAlgo","privateKeyToJWK","RS","detached","publicKeyToJWK","validateParams","jwkPrivate","jwkPublic","privateCryptoKey","publicCryptoKey","randomData","getPublicKey","crv","isBytes","isView","abytes","lengths","aexists","instance","checkFinished","destroyed","finished","aoutput","out","outputLen","u8","u32","clean","createView","isLE","toBytes","utf8ToBytes","copyBytes","overlapBytes","complexOverlapBytes","equalBytes","diff","wrapCipher","wrappedCipher","args","nonceLength","nonce","varSizeNonce","tagl","tagLength","cipher","checkOutput","fnLength","called","assign","getOutput","expectedLength","onlyAligned","isAligned32","setBigUint64","view","_32n","_u32_max","wh","wl","setUint32","BLOCK_SIZE","ZEROS16","ZEROS32","swapLE","GHASH","blockLen","s0","s1","s2","s3","kView","k0","getUint32","k1","k2","k3","doubles","W","windows","windowSize","items","w","d0","d1","d2","d3","_updateBlock","o0","o1","o2","o3","mask","num","bytePos","bitPos","bit","e0","e1","e2","e3","b32","blocks","left","elm","digestInto","o32","res","Polyval","ghKey","hiBit","carry","_toGHASHKey","wrapConstructorWithKey","hashCons","hashC","msg","ghash","EMPTY_BLOCK","mul2","mul","sbox","box","invSbox","_","rotl32_8","byteSwap","word","genTtable","T0","T1","T2","T3","T01","T23","sbox2","Uint16Array","idx","tableEncoding","tableDecoding","xPowers","expandKeyLE","toClean","k32","Nk","subByte","applySbox","xk","expandKeyDecLE","encKey","apply0123","rounds","t0","t1","t2","t3","ctrCounter","src","dst","srcLen","ctr","c32","src32","dst32","ctr32","ctrPos","ctrNum","blockSize","processCtr","plaintext","ciphertext","cbc","iv","opts","pcks5","disablePadding","o","_out","outLen","remaining","validateBlockEncrypt","_iv","n32","tmp32","paddingByte","padPCKS","validateBlockDecrypt","ps0","ps1","ps2","ps3","lastByte","validatePCKS","cfb","processCfb","isEncrypt","next32","computeTag","AAD","aadLength","dataLength","u64Lengths","_computeTag","authKey","tagMask","deriveKeys","counter","nonceLen","g","passedTag","isBytes32","encryptBlock","block","decryptBlock","AESW","kek","a0","a1","chunks","AESKW_IV","aeskw","sum","pad","concatBytes","unsafe","getLegacyCipher","legacyCiphers","algoName","getCipherBlockSize","getCipherKeySize","getCipherParams","keySize","wrap","dataToWrap","wrappingKey","keyToWrap","wrapped","wrapKey","nobleAesKW","unwrap","wrappedData","unwrapped","unwrapKey","computeHKDF","inputKey","salt","info","importedKey","deriveBits","HKDF_INFO","ephemeralPublicKey","sharedSecret","generateEphemeralEncryptionMaterial","recomputedSharedSecret","recomputeSharedSecret","recipientA","hkdfInput","encryptionKey","wrappedKey","aesKW.wrap","aesKW.unwrap","ephemeralKeyPair","ephemeralPublicKeyJwt","recipientPublicKey","sharedSecretBuffer","public","ephemeralSecretKey","scalarMult","assertNonZeroArray","getSharedSecret","privateKeyJWK","ephemeralPublicKeyJWK","ephemeralPublicKeyReference","acc","webCurves","knownCurves","getCurves","nodeCurves","curves","keyType","node","web","payloadSize","sharedSize","wireFormatLeadingByte","CurveWithOID","oidOrName","genKeyPair","namedCurve","jwkToRawPublic","webGenKeyPair","jsGenKeyPair","createECDH","generateKeys","getPrivateKey","nodeGenKeyPair","ecdhXGenerate","eddsaGenerate","Q","secret","validateStandardParams","supportedCurves","dLittleEndian","ecdhXValidateParams","dG","checkPublicPointEnconding","V","pointSize","nobleCurve","bufX","bufY","rawPublicToJWK","ecKeyUtils","nodeBuffer","derPrivateKey","generateDer","dsaEncoding","lowS","tryFallbackVerificationForOldBug","jsVerify","verified","derPublicKey","eddsaSign","eddsaVerify","eddsaValidateParams","c","provided","computed","buildEcdhParam","public_algo","kdfParams","fingerprint","kdf","X","param","stripLeading","stripTrailing","genPublicEphemeralKey","sharedKey","ecdhXGenerateEphemeralEncryptionMaterial","recipient","webPublicEphemeralKey","jsPublicEphemeralKey","sender","computeSecret","nodePublicEphemeralKey","pkcs5.encode","Z","genPrivateEphemeralKey","ecdhXRecomputeSharedSecret","S","webPrivateEphemeralKey","jsPrivateEphemeralKey","setPrivateKey","nodePrivateEphemeralKey","C","pkcs5.decode","ECDHSymmetricKey","KDFParams","ECDHXSymmetricKey","fromObject","algorithm","followLength","publicKeyEncrypt","keyAlgo","symmetricAlgo","publicParams","rsa.encrypt","c1","c2","elgamal.encrypt","elliptic.ecdh.encrypt","ECDHSymkey","elliptic.ecdhX.encrypt","publicKeyDecrypt","publicKeyParams","privateKeyParams","sessionKeyParams","rsa.decrypt","elgamal.decrypt","elliptic.ecdh.decrypt","elliptic.ecdhX.decrypt","parsePrivateKeyParams","privateParams","getCurvePayloadSize","serializeParams","algosWithNativeRepresentation","orderedParams","keys","generateParams","keyGenOpt","modulusLength","publicExponent","publicKeyEncoding","privateKeyEncoding","generateKeyPair","jwkPrivateKey","phi","rsa.generate","elliptic.generate","elliptic.eddsa.generate","elliptic.ecdhX.generate","_2n","rde","rsa.validateParams","qSize","dsa.validateParams","pSize","threshold","elgamal.validateParams","algoModule","elliptic","elliptic.eddsaLegacy.validateParams","elliptic.eddsa.validateParams","elliptic.ecdhX.validateParams","generateSessionKey","checkSupportedCurve","elliptic.CurveWithOID","elliptic.eddsa.getPayloadSize","elliptic.ecdhX.getPayloadSize","knownAlgos","getCiphers","nodeAlgos","getPrefixRandom","prefixrandom","repeat","pt","cipherObj","createCipheriv","WebCryptoEncryptor","isSupported","encryptChunk","NobleStreamProcessor","processChunk","nobleAesCfb","aesEncrypt","cipherfn","block_size","blockc","encblock","ct","decipherObj","createDecipheriv","aesDecrypt","blockp","decblock","prevBlock","nextBlock","zeroBlock","_runCBC","nonZeroIV","mode","keyRef","missing","added","leftover","toEncrypt","encryptedBlocks","xorMut","encryptedBlock","curBlock","clearSensitiveData","forEncryption","nobleAesHelpers","getUint32Array","_runCFB","toProcess","processedBlocks","processedBlock","aLength","blockLength","rightXORMut","CMAC","CBC","padding2","nobleAesCbc","zero","one","two","OMAC","cmac","CTR","en","final","nobleAesCtr","EAX","omac","adata","omacNonce","omacAdata","ciphered","ctTag","omacCiphered","getNonce","chunkIndex","ivLength","ntz","T","xor","OCB","maxNtz","encipher","decipher","crypt","newMaxNtz","extendKeyVariables","paddedNonce","bottom","kTop","stretched","checksum","xorInput","$","cipherInput","mask_x","mask_$","constructKeyVariables","crypted","ALGO","GCM","setAAD","getAuthTag","de","setAuthTag","_key","webcryptoEmptyMessagesUnsupported","userAgent","nobleAesGcm","additionalData","getAEADMode","acceptExperimentalGCM","rsa.verify","u1","u2","dsa.verify","curveSize","elliptic.ecdsa.verify","elliptic.eddsaLegacy.verify","elliptic.eddsa.verify","rsa.sign","xr","dsa.sign","elliptic.ecdsa.sign","elliptic.eddsaLegacy.sign","elliptic.eddsa.sign","Argon2OutOfMemoryError","loadArgonWasmModule","argon2Promise","Argon2S2K","encodedM","generateSalt","produceKey","passphrase","decodedM","version","password","memorySize","GenericS2K","getCount","numBytes","rlength","prefixlen","toHash","datalen","allowedS2KTypesForEncryption","newS2KFromType","newS2KFromConfig","u16","i32","Int32Array","fleb","fdeb","clim","freb","eb","_a","fl","revfl","_b","fd","revfd","rev","hMap","cd","mb","l","co","le","rvb","sv","r_1","flt","fdt","flm","flrm","fdm","fdrm","bits16","shft","slc","ec","ind","nt","code","wbits","wbits16","hTree","f","et","sort","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","cl","cli","cln","cls","clen","cf","wfblk","dat","wblk","syms","lf","df","li","bl","dlt","mlb","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","sym","deo","adler","dopt","opt","pre","post","st","dictionary","dict","newDat","lvl","plvl","z","lst","msk_1","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","wbytes","Deflate","cb","ondata","endLen","newBuf","Inflate","bts","sl","noBuf","resize","noSt","cbuf","nbuf","bt","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","lms","dms","lpos","dsym","dend","inflt","Zlib","raw","lv","zlh","Unzlib","td","LiteralDataPacket","date","filename","setText","getText","getBytes","setBytes","setFilename","getFilename","streamParse","filename_len","filename_length","KeyID","equals","keyID","matchWildcard","isWildcard","isNull","mapToHex","fromID","wildcard","SALT_NOTATION_NAME","allowedUnhashedSubpackets","SignaturePacket","signatureType","hashAlgorithm","publicKeyAlgorithm","signatureData","unhashedSubpackets","unknownSubpackets","signedHashValue","created","signatureNeverExpires","exportable","trustLevel","trustAmount","keyNeverExpires","revocationKeyClass","revocationKeyAlgorithm","revocationKeyFingerprint","rawNotations","notations","isPrimaryUserID","reasonForRevocationFlag","reasonForRevocationString","signatureTargetPublicKeyAlgorithm","signatureTargetHashAlgorithm","signatureTargetHash","issuerKeyVersion","revoked","readSubPackets","saltLength","signatureMaterial","signatureParams","rsSize","signature.parseSignatureParams","writeParams","streamFromAsync","writeUnhashedSubPackets","getFingerprintBytes","getKeyID","saltLengthForHash","saltValue","humanReadable","critical","writeHashedSubPackets","streamSlice","streamClone","signature.sign","writeSubPacket","encodedName","readSubPacket","mypos","seconds","trusted","subpacketLengthBytes","subpacketLength","toSign","writeForHash","calculateTrailer","isMessageSignature","signature.verify","normDate","getExpirationTime","toUpperCase","isExpired","OnePassSignaturePacket","fromSignaturePacket","signaturePacket","isLast","onePassSig","flags","correspondingSig","arguments","newPacketFromTag","allowedPackets","packetType","PacketList","fromBinary","grammarValidator","delayErrors","packets","unauthenticatedError","wasStream","parsed","recordPacket","fromStream","throwUnknownPacketError","throwUnsupportedError","throwMalformedPacketError","throwDataPacketError","unparsedPacket","nextPacket","recordEnd","packetbytes","minLength","powerOf2","LN2","chunkSize","filterByTag","tags","filtered","handle","findPacket","find","indexOfTag","tagIndex","that","GrammarError","MessageType","MessageGrammarValidator","state","EmptyMessage","leadingOnePassSignatureCounter","StandaloneAdditionalAllowedData","PlaintextOrEncryptedData","EncryptedSessionKeys","CompressedDataPacket","compressed","decompress","compress","compressionName","decompressionFn","decompress_fns","compressionFn","compress_fns","compressionStreamInstantiator","ZlibStreamedConstructor","inputData","zlibStream","processedChunks","processedData","compressorOrDecompressor","pipeThrough","inputReader","bzip2Decompress","bunzipDecode","getCompressionStreamInstantiators","compressionFormat","compressor","CompressionStream","decompressor","DecompressionStream","SymEncryptedIntegrityProtectedDataPacket","aeadAlgorithm","seip","cipherAlgorithm","chunkSizeByte","encrypted","sessionKeyAlgorithm","runAEAD","cipherMode.cfb.getPrefixRandom","mdc","tohash","cipherMode.cfb.encrypt","decrypted","cipherMode.cfb.decrypt","realHash","verifyHash","isSEIPDv2","isAEADP","cipherMode.getAEADMode","tagLengthIfDecrypting","tagLengthIfEncrypting","chunkIndexSizeIfAEADEP","adataBuffer","adataArray","adataTagArray","adataView","chunkIndexArray","ivView","latestPromise","cryptedBytes","queuedBytes","derived","modeInstance","size","streamPipe","finalChunk","cryptedPromise","setInt32","desiredSize","AEADEncryptedDataPacket","PublicKeyEncryptedSessionKeyPacket","publicKeyID","publicKeyVersion","publicKeyFingerprint","sessionKey","encryptionKeyPacket","anonymousRecipient","pkesk","versionAndFingerprintLength","fingerprintLength","parseEncSessionKeyParams","encodeSessionKey","randomSessionKey","decryptedData","computedChecksum","isValidChecksum","decryptedSessionKey","isValidPayload","decodeSessionKey","hasEncryptedAlgo","sessionKeyData","SymEncryptedSessionKeyPacket","sessionKeyEncryptionAlgorithm","s2kLen","fieldsLen","PublicKeyPacket","expirationTimeV3","fromSecretKeyPacket","secretKeyPacket","keyPacket","parsePublicKeyParams","computeFingerprintAndKeyID","writePublicKey","versionOctet","lengthOctets","isDecrypted","getCreationTime","computeFingerprint","getFingerprint","hasSameFingerprintAs","other","getAlgorithmInfo","modulo","readPublicKey","SymmetricallyEncryptedDataPacket","FRE","MarkerPacket","PublicSubkeyPacket","fromSecretSubkeyPacket","secretSubkeyPacket","UserAttributePacket","attributes","usrAttr","attr","SecretKeyPacket","keyMaterial","isEncrypted","s2kUsage","isLegacyAEAD","usedModernAEAD","startOfSecretKeyData","unparseableKeyMaterial","cleartext","serializedPublicKey","optionalFieldsArr","isDummy","isMissingSecretKeyMaterial","makeDummy","clearPrivateParams","serializedPacketTag","produceEncryptionKey","associateData","cleartextWithHash","validate","validParams","keyVersion","aeadMode","derivedKey","UserIDPacket","email","comment","components","isValidEmail","firstBracket","lastBracket","potentialEmail","substring","beforeEmail","trim","firstParen","lastParen","otherUserID","SecretSubkeyPacket","TrustPacket","PaddingPacket","createPadding","Signature","packetlist","getSigningKeyIDs","readSignature","armoredSignature","binarySignature","rest","unknownOptions","generateSecretSubkey","rsaBits","generateSecretKey","getLatestValidSignature","signatures","dataToVerify","latestValid","$1","$2","toLowerCase","isDataExpired","expirationTime","getKeyExpirationTime","createBindingSignature","subkey","primaryKey","dataToSign","signatureProperties","createSignaturePacket","targetKeys","signingKeyPacket","targetUserIDs","defaultAlgo","preferredSenderAlgo","supportedAlgosPerTarget","getPrimarySelfSignature","supportedAlgosMap","Map","supportedAlgos","supportedAlgo","isSupportedHashAlgo","getStrongestSupportedHashAlgo","strongestHashAlgo","algoA","algoB","preferredCurveAlgo","elliptic.getPreferredHashAlgo","elliptic.eddsa.getPreferredHashAlgo","getPreferredCurveHashAlgo","preferredSenderAlgoIsSupported","preferredSenderAlgoStrongerThanCurveAlgo","strongestSupportedAlgo","recipientKeys","recipientUserIDs","mergeSignatures","source","dest","checkFn","sourceSig","destSig","isDataRevoked","revocations","revocationKeyIDs","revocationSignature","isHardRevocation","sanitizeKeyOptions","subkeyDefaults","validateSigningKeyPacket","validateEncryptionKeyPacket","validateDecryptionKeyPacket","checkKeyRequirements","algoInfo","User","userPacket","mainKey","selfCertifications","otherCertifications","revocationSignatures","toPacketList","user","certify","signingKeys","isPrivate","signingKey","getSigningKey","isRevoked","certificate","verifyCertificate","verificationKeys","issuerKeys","getKeys","verifyAllCertifications","certifications","certification","valid","selfCertification","sourceUser","srcSelfSig","srcRevSig","revoke","flag","string","Subkey","subkeyPacket","bindingSignatures","helper.isDataRevoked","bindingSignature","helper.getLatestValidSignature","helper.isDataExpired","keyExpiry","helper.getKeyExpirationTime","sigExpiry","helper.mergeSignatures","srcBindSig","helper.createSignaturePacket","allowedRevocationPackets","mainKeyPacketTags","keyPacketTags","privateSubkey","Key","packetListToStructure","disallowedPackets","primaryKeyID","ignoreUntil","users","subkeys","directSignatures","clonePrivateParams","getPrototypeOf","getSubkeys","getKeyIDs","getUserIDs","verifyPrimaryKey","helper.checkKeyRequirements","helper.validateSigningKeyPacket","getEncryptionKey","helper.validateEncryptionKeyPacket","directSignature","primaryKeyExpiry","selfSigKeyExpiry","selfSigExpiry","directSigKeyExpiry","getPrimaryUser","primaryUser","B","pop","cert","sourceKey","destSubkey","srcSubkey","updatedKey","usersToUpdate","dstUser","srcUser","userToUpdate","newUser","subkeysToUpdate","dstSubkey","subkeyToUpdate","newSubkey","getRevocationCertificate","applyRevocationCertificate","revocationCertificate","signPrimaryUser","privateKeys","userSign","signAllUsers","verifyPrimaryUser","verifyAllUsers","results","PublicKey","toPublic","PrivateKey","keyPackets","pubKeyPacket","pubSubkeyPacket","getDecryptionKeys","helper.validateDecryptionKeyPacket","Boolean","addSubkey","defaultOptions","getDefaultSubkeyType","helper.sanitizeKeyOptions","helper.generateSecretSubkey","helper.createBindingSignature","packetList","allowedKeyPackets","createKey","wrapKeyObject","secretSubkeyPackets","subkeyPassphrase","createPreferredAlgos","algos","preferredAlgo","getKeySignatureProperties","symmetricAlgorithms","aeadAlgorithms","flatMap","symmetricAlgorithm","userIDs","userIDPacket","subkeyOptions","subkeySignaturePacket","readKey","armoredKey","binaryKey","keyIndex","readPrivateKey","firstPrivateKeyList","readKeys","armoredKeys","binaryKeys","newKey","readPrivateKeys","oneKeyList","allowedMessagePackets","allowedSymSessionKeyPackets","allowedDetachedSignaturePackets","Message","getEncryptionKeyIDs","keyIDs","unwrapCompressed","onePassSigList","decryptionKeys","passwords","sessionKeys","symEncryptedPacketlist","symEncryptedPacket","expectedSymmetricAlgorithm","sessionKeyObjects","decryptSessionKeys","decryptedPromise","algorithmName","streamCancel","resultMsg","decryptedSessionKeyPackets","skeskPackets","skeskPacket","pkeskPackets","pkeskPacket","decryptionKey","decryptionKeyPackets","decryptionKeyPacket","serialisedPKESK","pkeskPacketCopy","seen","item","getLiteralData","encryptionKeys","aeadAlgo","selfSigs","selfSig","defaultCipherSuite","desiredCipherSuites","desiredCipherSuite","cipherSuite","defaultSymAlgo","desiredSymAlgo","getPreferredCipherSuite","symmetricAlgoName","aeadAlgoName","maybeKey","encryptionKeyIDs","aeadAlgorithmName","encryptSessionKey","pkESKeyPacket","testDecrypt","accumulator","currentValue","encryptPassword","symEncryptedSessionKeyPacket","pwd","reduce","signingKeyIDs","signingUserIDs","literalDataPacket","signaturePackets","createSignaturePackets","onePassSignaturePackets","signDetached","recipientKeyIDs","literalDataList","signatureList","correspondingSigResolve","correspondingSigReject","createVerificationObjects","verifyDetached","appendSignature","detachedSignature","trailingPacket","signingUserID","existingSigPacketlist","unverifiedSigningKey","signaturePacketPromise","verifiedSig","createVerificationObject","readMessage","armoredMessage","binaryMessage","streamType","createMessage","literalDataPacketlist","CleartextMessage","newSignature","emitHeaderAndChecksum","readCleartextMessage","cleartextMessage","checkHashAlgos","hashAlgos","check","hashHeader","parsedHashIDs","createCleartextMessage","checkConfig","toArray","helper.generateSecretKey","formatObject","reformatKey","reformattedKey","sanitize","reformat","revokeKey","revokedKey","decryptKey","clonedPrivateKey","passphrases","encryptKey","encryptionUserIDs","signatureNotations","checkMessage","checkOutputMessageFormat","publicKeys","senderAlgoSupport","recipientPrefs","getPreferredCompressionAlgo","convertStream","expectSigned","linkStreams","sig","checkCleartextOrMessage","checkBinary","checkString","defaultConfigPropsCount","inputConfigProps","inputProp","inputMessage","intermediateMessages","intermediate","object"],"mappings":"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KAAM,KAAM,KAAM,KAAM,KAAM,KACxC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KA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","x_google_ignoreList":[0,1,2,3,19,20,21,46]}